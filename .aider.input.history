
# 2024-12-22 12:03:56.724648
+yes

# 2024-12-22 12:04:18.714474
+give me list of unused functions 

# 2024-12-22 12:08:10.050169
+yes

# 2024-12-22 12:08:19.609900
+is it working?

# 2024-12-22 12:09:56.773667
+test

# 2024-12-22 12:10:17.620887
+no

# 2024-12-22 12:10:21.319317
+hello world

# 2024-12-22 12:17:57.128494
+test aider is here?

# 2024-12-22 12:18:17.030957
+give me a list of unused functions and compnents 

# 2024-12-22 12:18:45.878505
+yes

# 2024-12-22 12:19:38.151256
+remove unused files, remove unused imports, remove unused functions, remove unused packages

# 2024-12-22 12:20:47.459628
+inside the ./src/frontend remove unused functions and imports

# 2024-12-22 12:22:22.409347
+how to do that give me step by step?

# 2024-12-22 12:23:00.977039
+yes

# 2024-12-22 12:23:00.981540
+/run find ./src/frontend -type f -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx"

# 2024-12-22 12:23:00.981641
+/run find ./src/frontend -type f -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx"

# 2024-12-22 12:23:05.632831
+yes

# 2024-12-22 12:23:14.349219
+/run cat <file_path>

# 2024-12-22 12:23:14.349574
+/run cat <file_path>

# 2024-12-22 12:23:16.359237
+yes

# 2024-12-22 12:23:18.010436
+/run cat ./src/frontend/components/SomeComponent.tsx

# 2024-12-22 12:23:18.010506
+/run cat ./src/frontend/components/SomeComponent.tsx

# 2024-12-22 12:23:19.893058
+yes

# 2024-12-22 12:23:39.979494
+remove unused functions and unused imports from the frontend 

# 2024-12-22 12:23:50.025872
+yes

# 2024-12-22 12:23:50.030845
+/run cat ./src/frontend/FILE_PATH

# 2024-12-22 12:23:50.030946
+/run cat ./src/frontend/FILE_PATH

# 2024-12-22 12:23:51.909131
+yes

# 2024-12-22 12:23:53.429847
+/run cat ./src/frontend/App.tsx

# 2024-12-22 12:23:53.429978
+/run cat ./src/frontend/App.tsx

# 2024-12-22 12:23:55.168077
+yes

# 2024-12-22 12:24:38.023865
+give me a list of unused files in the frontend 

# 2024-12-22 12:25:25.143414
+yes

# 2024-12-22 12:25:57.208442
+/run cat ./src/frontend/websocket/use_socket.tsx

# 2024-12-22 12:25:57.208825
+/run cat ./src/frontend/websocket/use_socket.tsx

# 2024-12-22 12:26:01.835478
+y

# 2024-12-22 12:26:03.180932
+/run cat ./src/frontend/redux/initialData/useInitialData.tsx

# 2024-12-22 12:26:03.181154
+/run cat ./src/frontend/redux/initialData/useInitialData.tsx

# 2024-12-22 12:26:04.465545
+y

# 2024-12-22 12:26:05.533049
+/run cat ./src/frontend/contexts/BackendContext.tsx

# 2024-12-22 12:26:05.533186
+/run cat ./src/frontend/contexts/BackendContext.tsx

# 2024-12-22 12:26:06.623444
+y

# 2024-12-22 12:27:00.160631
+scan ./src/frontend/components and remove unused functions and unused import ./src/frontend/components

# 2024-12-22 12:27:28.946988
+add ./src/frontend/components to the chat

# 2024-12-22 12:27:46.313397
+chat ./src/frontend/components

# 2024-12-22 12:27:54.526029
+yes

# 2024-12-22 12:27:54.529381
+/run cat ./src/frontend/components/Actions/DeleteFile.tsx

# 2024-12-22 12:27:54.529426
+/run cat ./src/frontend/components/Actions/DeleteFile.tsx

# 2024-12-22 12:27:54.705826
+/run cat ./src/frontend/components/Actions/MultiSave.tsx

# 2024-12-22 12:27:54.705896
+/run cat ./src/frontend/components/Actions/MultiSave.tsx

# 2024-12-22 12:27:56.030507
+yes

# 2024-12-22 12:27:57.246727
+/run find ./src/frontend/components -type f -name "*.tsx" -exec cat {} \;

# 2024-12-22 12:27:57.246857
+/run find ./src/frontend/components -type f -name "*.tsx" -exec cat {} \;

# 2024-12-22 12:27:58.884320
+yes

# 2024-12-22 12:28:13.827977
+remove unused imports and unused functions ./src/frontend/components

# 2024-12-22 12:28:52.798204
+yes

# 2024-12-22 12:35:20.436000
+check ./src/frontend/components/NotifcationList/discover.tsx and enable users to click on a notification to set is_seen to true, also when a users click on a new promise shoudl expand the notifation tap and see more options like request release, object on promise with text for objections message

# 2024-12-22 12:35:37.049843
+check ./src/frontend/components/NotifcationList/discover.tsx and enable users to click on a notification to set is_seen to true, also when a users c
+lick on a new promise shoudl expand the notifation tap and see more options like request release, object on promise with text for objections messag
+e   '

# 2024-12-22 12:36:06.086010
+check ./src/frontend/components/NotifcationList/discover.tsx and enable users to click on a notification to set is_seen to true, also when a users c
+ 
+lick on a new promise shoudl expand the notifation tap and see more options like request release, object on promise with text for objections messag
+ 
+e 

# 2024-12-22 12:37:26.049011
+yes

# 2024-12-22 12:37:33.385714
+test

# 2024-12-22 12:37:52.197701
+how to do that?

# 2024-12-22 13:30:11.898725
+test

# 2024-12-22 13:32:37.727641
+Test

# 2024-12-22 13:33:23.905616
+at ./src/frontend/components/NotifcationList/discover.tsx the ExpandedNotificationContent does not show as a decent UI make it a popover compnent

# 2024-12-22 13:33:58.524702
+add ./src/frontend/components/NotifcationList/discover.tsx to the chat

# 2024-12-22 13:34:16.235542
+how to do that?

# 2024-12-22 13:34:45.499165
+yes

# 2024-12-22 13:34:45.506471
+/run cat ./src/frontend/components/NotifcationList/discover.tsx

# 2024-12-22 13:34:45.506572
+/run cat ./src/frontend/components/NotifcationList/discover.tsx

# 2024-12-22 13:34:47.836942
+y

# 2024-12-22 13:35:24.733690
+ at ./src/frontend/components/NotifcationList/discover.tsx the ExpandedNotificationContent does not show as a decent UI make it a popover compnent

# 2024-12-22 13:35:42.861467
+y

# 2024-12-22 13:36:26.971748
+can you make it draggable ?

# 2024-12-22 13:36:43.653814
+y

# 2024-12-22 13:36:43.658390
+/run npm install react-draggable

# 2024-12-22 13:36:43.658509
+/run npm install react-draggable

# 2024-12-22 13:36:57.890860
+y

# 2024-12-22 13:37:45.426941
+undo the last commit

# 2024-12-22 13:38:08.330150
+y

# 2024-12-22 13:38:08.336454
+/run git reset --hard HEAD~1

# 2024-12-22 13:38:08.336613
+/run git reset --hard HEAD~1

# 2024-12-22 13:38:25.551754
+y

# 2024-12-22 13:41:17.817608
+there is a strange issue with scrolling when ExpandedNotificationContent spear. Also, enable users to scroll over all notofication even when ExpandedNotificationContent, also allow users to close the ExpandedNotificationContent

# 2024-12-22 13:42:09.034636
+the close button is not working

# 2024-12-22 13:44:28.928171
+add this to the chat ./src/frontend/components/MainComponents/RegistrationForm.tsx and enhnace the UI of the registration forum make it look like profotional UI UX

# 2024-12-22 13:45:08.247206
+share ./src/frontend/components/MainComponents/RegistrationForm.tsx

# 2024-12-22 13:45:13.566978
+y

# 2024-12-22 13:45:43.196947
+/run npm install @mui/icons-material @mui/material @emotion/styled @emotion/react

# 2024-12-22 13:45:43.197297
+/run npm install @mui/icons-material @mui/material @emotion/styled @emotion/react

# 2024-12-22 13:45:59.567468
+y

# 2024-12-22 13:46:52.707182
+rewreite this import React, { useEffect, useState } from "react";
+import {
+  Avatar,
+  Box,
+  CircularProgress,
+  IconButton,
+  TextField,
+  Typography,
+  Paper,
+  Stepper,
+  Step,
+  StepLabel,
+  Button,
+  useTheme,
+} from "@mui/material";
+import { styled } from "@mui/material/styles";
+import { Add, PhotoCamera, ArrowForward, ArrowBack } from "@mui/icons-material";
+import { useDispatch, useSelector } from "react-redux";
+import { useSnackbar } from "notistack";
+import { convertToBytes } from "../../DataProcessing/imageToVec";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { RegisterUser, User } from "../../../declarations/backend/backend.did";
+import { handleRedux } from "../../redux/store/handleRedux";
+import RegistrationFormDialog from "../MuiComponents/RegistrationFormDialog";
+
+interface FormValues {
+  username: string;
+  bio: string;
+  first_name?: string;
+  last_name?: string;
+  email?: string;
+}
+
+const RegistrationForm: React.FC = () => {
+  const dispatch = useDispatch();
+  const { isLoggedIn, isRegistered } = useSelector(
+    (state: any) => state.uiState,
+  );
+
+  const { enqueueSnackbar, closeSnackbar } = useSnackbar();
+  const { backendActor } = useBackendContext();
+
+  const [formValues, setFormValues] = useState<FormValues>({
+    username: "",
+    bio: "",
+    first_name: "",
+    last_name: "",
+    email: "",
+  });
+  const [open, setOpen] = useState(isLoggedIn && !isRegistered);
+
+  useEffect(() => {
+    setOpen(isLoggedIn && !isRegistered);
+  }, [isLoggedIn, isRegistered]);
+
+  const [photo, setPhoto] = useState<File | null>(null);
+  const [photoByte, setPhotoByte] = useState<Uint8Array | number[] | undefined>(
+    null,
+  );
+  const [loading, setLoading] = useState(false);
+
+  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
+    const { id, value } = event.target;
+    setFormValues((prevValues) => ({ ...prevValues, [id]: value }));
+  };
+
+  const handleUploadPhoto = async (e: React.ChangeEvent<HTMLInputElement>) => {
+    const image = e.target.files?.[0];
+    if (image) {
+      try {
+        setLoading(true);
+        const imageByteData = await convertToBytes(image);
+        setPhoto(image);
+        setPhotoByte(imageByteData);
+      } catch (error) {
+        enqueueSnackbar(error.message, { variant: "error" });
+      } finally {
+        setLoading(false);
+      }
+    }
+  };
+
+  const handleRegister = async () => {
+    if (!formValues.username || !formValues.bio) {
+      enqueueSnackbar("Please fill all required fields", { variant: "error" });
+      return;
+    }
+
+    setOpen(false);
+    const loaderMessage = (
+      <span>
+        Creating account...{" "}
+        <CircularProgress size={20} style={{ marginLeft: 10 }} />
+      </span>
+    );
+    const loadingSnackbar = enqueueSnackbar(loaderMessage, { variant: "info" });
+
+    const input: RegisterUser = {
+      name: [formValues.username],
+      description: [formValues.bio],
+      photo: photoByte ? [photoByte] : [[]],
+    };
+
+    try {
+      let register: { Ok: User } | { Err: string } | undefined;
+      if (backendActor) {
+        register = await backendActor.register(input);
+        closeSnackbar(loadingSnackbar);
+      }
+      if (register?.Ok) {
+        dispatch(handleRedux("UPDATE_PROFILE", { profile: register.Ok }));
+        enqueueSnackbar(`Welcome ${register.Ok.name}, to Odoc`, {
+          variant: "success",
+        });
+      } else if (register?.Err) {
+        enqueueSnackbar(register.Err, { variant: "error" });
+        setOpen(true);
+      }
+    } catch (error) {
+      console.error("There was an issue with registration: ", error);
+      enqueueSnackbar(error.message, { variant: "error" });
+    }
+  };
+
+  const theme = useTheme();
+  const [activeStep, setActiveStep] = useState(0);
+  
+  const steps = ['Basic Info', 'Profile Details', 'Review'];
+
+  const handleNext = () => {
+    setActiveStep((prevStep) => prevStep + 1);
+    if (activeStep === steps.length - 1) {
+      handleRegister();
+    }
+  };
+
+  const handleBack = () => {
+    setActiveStep((prevStep) => prevStep - 1);
+  };
+
+  const StyledPaper = styled(Paper)(({ theme }) => ({
+    padding: theme.spacing(4),
+    borderRadius: theme.spacing(2),
+    boxShadow: '0 8px 32px rgba(0, 0, 0, 0.08)',
+    background: 'rgba(255, 255, 255, 0.95)',
+    backdropFilter: 'blur(10px)',
+  }));
+
+  const StyledAvatar = styled(Avatar)(({ theme }) => ({
+    width: 120,
+    height: 120,
+    cursor: 'pointer',
+    transition: 'transform 0.2s, box-shadow 0.2s',
+    '&:hover': {
+      transform: 'scale(1.05)',
+      boxShadow: '0 4px 20px rgba(0, 0, 0, 0.15)',
+    },
+  }));
+
+  const renderStepContent = (step: number) => {
+    switch (step) {
+      case 0:
+        return (
+          <Box sx={{ mt: 2 }}>
+            <TextField
+              required
+              id="username"
+              label="Username"
+              type="text"
+              fullWidth
+              variant="outlined"
+              value={formValues.username}
+              onChange={handleChange}
+              sx={{ mb: 3 }}
+            />
+            <TextField
+              id="email"
+              label="Email"
+              type="email"
+              fullWidth
+              variant="outlined"
+              value={formValues.email || ""}
+              onChange={handleChange}
+            />
+          </Box>
+        );
+      case 1:
+        return (
+          <Box sx={{ mt: 2 }}>
+            <Box
+              sx={{
+                display: "flex",
+                flexDirection: "column",
+                alignItems: "center",
+                mb: 3,
+              }}
+            >
+              <input
+                accept="image/*"
+                id="photo"
+                type="file"
+                style={{ display: "none" }}
+                onChange={handleUploadPhoto}
+              />
+              <label htmlFor="photo">
+                <StyledAvatar
+                  src={photo ? URL.createObjectURL(photo) : undefined}
+                  alt="Profile Photo"
+                >
+                  {!photo && <PhotoCamera sx={{ fontSize: 40 }} />}
+                </StyledAvatar>
+              </label>
+              <Typography variant="subtitle1" sx={{ mt: 1, mb: 1 }}>
+                Upload Profile Photo
+              </Typography>
+              {loading && <CircularProgress size={24} />}
+            </Box>
+            <Box sx={{ display: "flex", gap: 2, mb: 3 }}>
+              <TextField
+                id="first_name"
+                label="First Name"
+                type="text"
+                fullWidth
+                variant="outlined"
+                value={formValues.first_name || ""}
+                onChange={handleChange}
+              />
+              <TextField
+                id="last_name"
+                label="Last Name"
+                type="text"
+                fullWidth
+                variant="outlined"
+                value={formValues.last_name || ""}
+                onChange={handleChange}
+              />
+            </Box>
+            <TextField
+              required
+              multiline
+              rows={4}
+              id="bio"
+              label="Bio"
+              type="text"
+              fullWidth
+              variant="outlined"
+              value={formValues.bio}
+              onChange={handleChange}
+              placeholder="Tell us about yourself..."
+            />
+          </Box>
+        );
+      case 2:
+        return (
+          <Box sx={{ mt: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Review Your Information
+            </Typography>
+            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
+              <StyledAvatar
+                src={photo ? URL.createObjectURL(photo) : undefined}
+                sx={{ width: 80, height: 80, mr: 2 }}
+              />
+              <Box>
+                <Typography variant="h6">
+                  {formValues.username}
+                </Typography>
+                <Typography color="textSecondary">
+                  {formValues.email}
+                </Typography>
+              </Box>
+            </Box>
+            <Typography variant="body1" paragraph>
+              {formValues.bio}
+            </Typography>
+            <Typography variant="body2" color="textSecondary">
+              {formValues.first_name} {formValues.last_name}
+            </Typography>
+          </Box>
+        );
+      default:
+        return null;
+    }
+  };
+
+  return (
+    <RegistrationFormDialog
+      title="Create Your Account"
+      description="Join our community in just a few steps"
+      inputFields={
+        <StyledPaper>
+          <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
+            {steps.map((label) => (
+              <Step key={label}>
+                <StepLabel>{label}</StepLabel>
+              </Step>
+            ))}
+          </Stepper>
+        <>
+          <Box
+            sx={{
+              display: "flex",
+              flexDirection: "column",
+              alignItems: "center",
+              marginBottom: 2,
+            }}
+          >
+            <input
+              accept="image/*"
+              id="photo"
+              type="file"
+              style={{ display: "none" }}
+              onChange={handleUploadPhoto}
+            />
+            <label htmlFor="photo">
+              <IconButton component="span">
+                <Avatar
+                  src={photo ? URL.createObjectURL(photo) : undefined}
+                  alt="Profile Photo"
+                  sx={{ width: 100, height: 100 }}
+                >
+                  <Add />
+                </Avatar>
+              </IconButton>
+            </label>
+            <Typography variant="subtitle1">Upload Photo</Typography>
+            {loading && (
+              <CircularProgress size={20} style={{ marginTop: 10 }} />
+            )}
+          </Box>
+          <Box sx={{ marginBottom: 2 }}>
+            <TextField
+              required
+              id="username"
+              label="Username"
+              type="text"
+              fullWidth
+              variant="outlined"
+              value={formValues.username}
+              onChange={handleChange}
+            />
+          </Box>
+          <Box
+            sx={{
+              display: "flex",
+              justifyContent: "space-between",
+              marginBottom: 2,
+            }}
+          >
+            <TextField
+              id="first_name"
+              label="First Name"
+              type="text"
+              fullWidth
+              variant="outlined"
+              value={formValues.first_name || ""}
+              onChange={handleChange}
+              sx={{ marginRight: 1 }}
+            />
+            <TextField
+              id="last_name"
+              label="Last Name"
+              type="text"
+              fullWidth
+              variant="outlined"
+              value={formValues.last_name || ""}
+              onChange={handleChange}
+            />
+          </Box>
+          <Box sx={{ marginBottom: 2 }}>
+            <TextField
+              id="email"
+              label="Email"
+              type="email"
+              fullWidth
+              variant="outlined"
+              value={formValues.email || ""}
+              onChange={handleChange}
+            />
+          </Box>
+          <Box sx={{ marginBottom: 2 }}>
+            <TextField
+              required
+              multiline
+              id="bio"
+              label="Bio"
+              type="text"
+              fullWidth
+              variant="outlined"
+              value={formValues.bio}
+              onChange={handleChange}
+            />
+          </Box>
+        </>
+      }
+      buttons={[
+        {
+          name: "Back",
+          onClick: handleBack,
+          disabled: activeStep === 0,
+          startIcon: <ArrowBack />,
+          sx: { mr: 1 }
+        },
+        {
+          name: activeStep === steps.length - 1 ? "Complete Registration" : "Next",
+          onClick: handleNext,
+          endIcon: activeStep === steps.length - 1 ? undefined : <ArrowForward />,
+          variant: "contained",
+          color: "primary"
+        }
+      ]}
+      open={open}
+      maxWidth="md"
+    />
+  );
+};
+
+export default RegistrationForm;
+

# 2024-12-22 13:48:18.522811
+enhance the look of the registeration forum and do not use RegistrationFormDialog

# 2024-12-22 13:50:23.474738
+share the files ./src/frontend/App.tsx and ./src/frontend/components/MainComponents/Index.tsx

# 2024-12-22 13:50:41.226640
+how to do that

# 2024-12-22 13:50:47.846252
+y

# 2024-12-22 13:51:37.641257
+there is an issue now, the registeration forum apear behinde the top nav bar, eather make it show on top or make it show a bit bellow 

# 2024-12-22 13:53:37.494634
+Uncaught (in promise) ReferenceError: setOpen is not defined
+

# 2024-12-22 13:54:12.388052
+after registeration refresh the page

# 2024-12-22 13:57:23.344580
+1. when registeration complete refresh the entire app, 2. when registeration capmplete call the backend backendActor?.register... 

# 2024-12-22 13:59:44.946362
+how to add ./src/frontend/pages/profile/discover.tsx to the chat

# 2024-12-22 13:59:55.051096
+how to do that

# 2024-12-22 14:00:25.153786
+./src/frontend/pages/profile/discover.tsx can you enable users to update, name, descrption and photo

# 2024-12-22 14:00:43.283039
+how ?

# 2024-12-22 14:00:51.303887
+do it

# 2024-12-22 14:01:23.689451
+./src/frontend/pages/profile/index.tsxyes

# 2024-12-22 14:01:26.183829
+y

# 2024-12-22 14:01:41.412913
+enable uers to update, name, descrption and photo

# 2024-12-22 14:03:59.758994
+1. keep the rest of the compnent and the rest of the data showing also check if currentUser.id ==profile.id otherwise do not allow users to update  import React from "react";
+import { AgCharts } from "ag-charts-react";
+import {
+  Container,
+  Box,
+  Card,
+  CardContent,
+  Typography,
+  Grid,
+  Avatar,
+  Rating,
+  Divider,
+  Button,
+} from "@mui/material";
+import Friends from "./friends";
+import { useSelector } from "react-redux";
+
+const ProfilePage = ({
+  profile,
+  history,
+  friends,
+  onUnfriend,
+  onAcceptFriend,
+  onCancelFriend,
+}) => {
+  const { isDarkMode } = useSelector((state: any) => state.uiState);
+  // Handle completely missing props with default empty objects
+  const safeProfile = profile || {};
+  const safeHistory = history || {};
+  const safeFriends = friends || [];
+
+  const {
+    id = "",
+    name = "Anonymous",
+    description = "",
+    photo = new Uint8Array(),
+  } = safeProfile;
+
+  const {
+    rates_by_actions = [],
+    rates_by_others = [],
+    actions_rate = 0,
+    users_rate = 0,
+  } = safeHistory;
+
+  // Ensure arrays are defined
+  const safeRatesByActions = Array.isArray(rates_by_actions)
+    ? rates_by_actions
+    : [];
+  const safeRatesByOthers = Array.isArray(rates_by_others)
+    ? rates_by_others
+    : [];
+
+  // Convert action ratings to chart data with safe access
+  const actionRatingsData = safeRatesByActions.map((rating) => ({
+    date: new Date(rating?.date || 0).toLocaleDateString(),
+    rating: rating?.rating || 0,
+    spent: rating?.spent || 0,
+    received: rating?.received || 0,
+    promises: rating?.promises || 0,
+  }));
+
+  // Calculate statistics with safe calculations
+  const totalSpent = safeRatesByActions.reduce(
+    (sum, rating) => sum + (rating?.spent || 0),
+    0,
+  );
+  const totalReceived = safeRatesByActions.reduce(
+    (sum, rating) => sum + (rating?.received || 0),
+    0,
+  );
+  const averageRating = safeRatesByOthers.length
+    ? safeRatesByOthers.reduce(
+        (sum, rating) => sum + (rating?.rating || 0),
+        0,
+      ) / safeRatesByOthers.length
+    : 0;
+
+  // AG Charts configuration
+  const chartOptions = {
+    title: {
+      text: "Actions history",
+      fontSize: 18,
+      color: isDarkMode ? "#ffffff" : "#000000", // Responsive title color
+    },
+    data: actionRatingsData, // Your data input
+    background: {
+      fill: isDarkMode ? "#1e1e1e" : "#fefefe", // Dark/light background
+    },
+    theme: isDarkMode ? "ag-dark" : "ag-default", // Switch AG Charts theme dynamically
+    series: [
+      {
+        type: "line",
+        xKey: "date",
+        yKey: "rating",
+        yName: "Rating",
+        stroke: isDarkMode ? "#F44336" : "#D32F2F", // Responsive line color
+        marker: {
+          enabled: true,
+          fill: isDarkMode ? "#F44336" : "#D32F2F", // Marker color
+          stroke: isDarkMode ? "#ffffff" : "#000000", // Marker border
+        },
+        tooltip: { enabled: true },
+      },
+      {
+        type: "line",
+        xKey: "date",
+        yKey: "spent",
+        yName: "Spent",
+        stroke: isDarkMode ? "#4FC3F7" : "#0288D1",
+        marker: {
+          enabled: true,
+          fill: isDarkMode ? "#4FC3F7" : "#0288D1",
+          stroke: isDarkMode ? "#ffffff" : "#000000",
+        },
+        tooltip: { enabled: true },
+      },
+      {
+        type: "line",
+        xKey: "date",
+        yKey: "received",
+        yName: "Received",
+        stroke: isDarkMode ? "#81C784" : "#388E3C",
+        marker: {
+          enabled: true,
+          fill: isDarkMode ? "#81C784" : "#388E3C",
+          stroke: isDarkMode ? "#ffffff" : "#000000",
+        },
+        tooltip: { enabled: true },
+      },
+      {
+        type: "line",
+        xKey: "date",
+        yKey: "promises",
+        yName: "Promises",
+        stroke: isDarkMode ? "#FFD54F" : "#FBC02D",
+        marker: {
+          enabled: true,
+          fill: isDarkMode ? "#FFD54F" : "#FBC02D",
+          stroke: isDarkMode ? "#ffffff" : "#000000",
+        },
+        tooltip: { enabled: true },
+      },
+    ],
+    axes: [
+      {
+        type: "category",
+        position: "bottom",
+        line: { color: isDarkMode ? "#aaaaaa" : "#000000" }, // Axes line color
+        tick: { color: isDarkMode ? "#aaaaaa" : "#000000" }, // Axes tick color
+        label: { color: isDarkMode ? "#ffffff" : "#000000" }, // X-axis label color
+      },
+      {
+        type: "number",
+        position: "left",
+        line: { color: isDarkMode ? "#aaaaaa" : "#000000" },
+        tick: { color: isDarkMode ? "#aaaaaa" : "#000000" },
+        label: { color: isDarkMode ? "#ffffff" : "#000000" }, // Y-axis label color
+      },
+    ],
+    legend: {
+      position: "bottom",
+      item: {
+        label: {
+          color: isDarkMode ? "#ffffff" : "#000000", // Legend text color
+        },
+      },
+    },
+  };
+
+  // Function to safely convert photo to base64
+  const getPhotoSrc = (photoData) => {
+    try {
+      return photoData && Object.keys(photoData).length > 0
+        ? `data:image/jpeg;base64,${Buffer.from(photoData).toString("base64")}`
+        : "";
+    } catch (e) {
+      console.error("Error converting photo:", e);
+      return "";
+    }
+  };
+
+  return (
+    <Container maxWidth="lg" sx={{ py: 4 }}>
+      {/* User Header */}
+      <Card sx={{ mb: 4 }}>
+        <CardContent>
+          <Box display="flex" alignItems="flex-start" gap={3}>
+            <Avatar
+              src={getPhotoSrc(photo)}
+              alt={name}
+              sx={{ width: 96, height: 96 }}
+            >
+              {name?.charAt(0) || "A"}
+            </Avatar>
+            <Box>
+              <Typography variant="h4" gutterBottom>
+                {name || "Anonymous"}
+              </Typography>
+              <Typography variant="body1" color="text.secondary">
+                {id || "No id available"}
+              </Typography>
+              <Typography variant="body1" color="text.secondary">
+                {description || "No description available"}
+              </Typography>
+            </Box>
+          </Box>
+        </CardContent>
+      </Card>
+
+      {/* Stats Overview */}
+      <Grid container spacing={3} sx={{ mb: 4 }}>
+        <Grid item xs={12} md={4}>
+          <Card>
+            <CardContent>
+              <Typography variant="h6" color="text.secondary" gutterBottom>
+                Rating
+              </Typography>
+              <Box display="flex" flexDirection="column" gap={1}>
+                <Rating value={averageRating} precision={0.1} readOnly />
+                <Typography variant="h4">{averageRating.toFixed(2)}</Typography>
+              </Box>
+            </CardContent>
+          </Card>
+        </Grid>
+
+        <Grid item xs={12} md={4}>
+          <Card>
+            <CardContent>
+              <Typography variant="h6" color="text.secondary" gutterBottom>
+                Total Spent
+              </Typography>
+              <Typography variant="h4">${totalSpent.toFixed(2)}</Typography>
+            </CardContent>
+          </Card>
+        </Grid>
+
+        <Grid item xs={12} md={4}>
+          <Card>
+            <CardContent>
+              <Typography variant="h6" color="text.secondary" gutterBottom>
+                Total Received
+              </Typography>
+              <Typography variant="h4">${totalReceived.toFixed(2)}</Typography>
+            </CardContent>
+          </Card>
+        </Grid>
+      </Grid>
+
+      {/* Chart */}
+      <Card sx={{ mb: 4 }}>
+        <CardContent>
+          <Box sx={{ height: 400 }}>
+            {actionRatingsData.length > 0 ? (
+              <AgCharts options={chartOptions} />
+            ) : (
+              <Box
+                height="100%"
+                display="flex"
+                alignItems="center"
+                justifyContent="center"
+              >
+                <Typography color="text.secondary">
+                  No transaction history available
+                </Typography>
+              </Box>
+            )}
+          </Box>
+        </CardContent>
+      </Card>
+
+      {/* Friends Section */}
+      <Card>
+        <CardContent>
+          <Typography variant="h6" gutterBottom>
+            Friends
+          </Typography>
+          <Friends currentUser={profile} friends={friends} />
+        </CardContent>
+      </Card>
+
+      {/* Recent Ratings */}
+      <Card sx={{ mt: 4 }}>
+        <CardContent>
+          <Typography variant="h6" gutterBottom>
+            Recent Ratings
+          </Typography>
+          {safeRatesByOthers.length > 0 ? (
+            <Box>
+              {safeRatesByOthers.slice(0, 5).map((rating, index) => (
+                <Box key={rating?.id || index}>
+                  <Box py={2}>
+                    <Box
+                      display="flex"
+                      justifyContent="space-between"
+                      alignItems="flex-start"
+                    >
+                      <Box>
+                        <Rating
+                          value={rating?.rating || 0}
+                          precision={0.1}
+                          readOnly
+                          size="small"
+                        />
+                        <Typography
+                          variant="body2"
+                          color="text.secondary"
+                          sx={{ mt: 1 }}
+                        >
+                          {rating?.comment || "No comment"}
+                        </Typography>
+                      </Box>
+                      <Typography variant="caption" color="text.secondary">
+                        {new Date(rating?.date || 0).toLocaleDateString()}
+                      </Typography>
+                    </Box>
+                  </Box>
+                  {index < safeRatesByOthers.length - 1 && <Divider />}
+                </Box>
+              ))}
+            </Box>
+          ) : (
+            <Box py={2} textAlign="center">
+              <Typography color="text.secondary">
+                No ratings available
+              </Typography>
+            </Box>
+          )}
+        </CardContent>
+      </Card>
+    </Container>
+  );
+};
+
+export default ProfilePage;
+import React, { useState, useEffect } from 'react';
+import {
+  Container,
+  Paper,
+  Typography,
+  TextField,
+  Button,
+  Avatar,
+  Box,
+  IconButton,
+  CircularProgress,
+  Stack,
+  useTheme,
+} from '@mui/material';
+import { PhotoCamera, Edit } from '@mui/icons-material';
+import { useDispatch, useSelector } from 'react-redux';
+import { useSnackbar } from 'notistack';
+import { convertToBytes } from '../../DataProcessing/imageToVec';
+import { useBackendContext } from '../../contexts/BackendContext';
+import { handleRedux } from '../../redux/store/handleRedux';
+import { convertToBlobLink } from '../../DataProcessing/imageToVec';
+
+const ProfilePage = () => {
+  const theme = useTheme();
+  const dispatch = useDispatch();
+  const { enqueueSnackbar } = useSnackbar();
+  const { backendActor } = useBackendContext();
+  const profile = useSelector((state: any) => state.filesState.profile);
+
+  const [isEditing, setIsEditing] = useState(false);
+  const [loading, setLoading] = useState(false);
+  const [formValues, setFormValues] = useState({
+    name: '',
+    description: '',
+  });
+  const [photo, setPhoto] = useState<File | null>(null);
+  const [photoByte, setPhotoByte] = useState<Uint8Array | number[] | undefined>(null);
+
+  useEffect(() => {
+    if (profile) {
+      setFormValues({
+        name: profile.name,
+        description: profile.description || '',
+      });
+    }
+  }, [profile]);
+
+  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
+    const { name, value } = event.target;
+    setFormValues((prev) => ({ ...prev, [name]: value }));
+  };
+
+  const handleUploadPhoto = async (e: React.ChangeEvent<HTMLInputElement>) => {
+    const image = e.target.files?.[0];
+    if (image) {
+      try {
+        setLoading(true);
+        const imageByteData = await convertToBytes(image);
+        setPhoto(image);
+        setPhotoByte(imageByteData);
+      } catch (error) {
+        enqueueSnackbar(error.message, { variant: 'error' });
+      } finally {
+        setLoading(false);
+      }
+    }
+  };
+
+  const handleUpdate = async () => {
+    if (!backendActor) {
+      enqueueSnackbar('Backend not initialized', { variant: 'error' });
+      return;
+    }
+
+    try {
+      setLoading(true);
+      const updateData = {
+        name: [formValues.name],
+        description: [formValues.description],
+        photo: photoByte ? [photoByte] : undefined,
+      };
+
+      const result = await backendActor.update_profile(updateData);
+      
+      if (result.Ok) {
+        dispatch(handleRedux('UPDATE_PROFILE', { profile: result.Ok }));
+        enqueueSnackbar('Profile updated successfully', { variant: 'success' });
+        setIsEditing(false);
+      } else if (result.Err) {
+        enqueueSnackbar(result.Err, { variant: 'error' });
+      }
+    } catch (error) {
+      console.error('Profile update error:', error);
+      enqueueSnackbar('Failed to update profile', { variant: 'error' });
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  if (!profile) {
+    return (
+      <Box display="flex" justifyContent="center" alignItems="center" minHeight="80vh">
+        <CircularProgress />
+      </Box>
+    );
+  }
+
+  const imageLink = convertToBlobLink(profile.photo);
+
+  return (
+    <Container maxWidth="md" sx={{ mt: 4, mb: 4 }}>
+      <Paper elevation={3} sx={{ p: 4, borderRadius: 2 }}>
+        <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
+          <Typography variant="h4">Profile</Typography>
+          <IconButton 
+            onClick={() => setIsEditing(!isEditing)}
+            color={isEditing ? 'primary' : 'default'}
+          >
+            <Edit />
+          </IconButton>
+        </Box>
+
+        <Box display="flex" flexDirection="column" alignItems="center" mb={4}>
+          <input
+            accept="image/*"
+            id="profile-photo"
+            type="file"
+            style={{ display: 'none' }}
+            onChange={handleUploadPhoto}
+            disabled={!isEditing}
+          />
+          <label htmlFor="profile-photo">
+            <Box position="relative" display="inline-block">
+              <Avatar
+                src={photo ? URL.createObjectURL(photo) : imageLink}
+                alt={profile.name}
+                sx={{
+                  width: 150,
+                  height: 150,
+                  border: `4px solid ${theme.palette.primary.main}`,
+                  cursor: isEditing ? 'pointer' : 'default',
+                  transition: 'opacity 0.3s',
+                  '&:hover': isEditing ? {
+                    opacity: 0.8,
+                  } : {},
+                }}
+              />
+              {isEditing && (
+                <IconButton
+                  sx={{
+                    position: 'absolute',
+                    bottom: 0,
+                    right: 0,
+                    backgroundColor: 'rgba(0, 0, 0, 0.5)',
+                    '&:hover': {
+                      backgroundColor: 'rgba(0, 0, 0, 0.7)',
+                    },
+                  }}
+                  component="span"
+                >
+                  <PhotoCamera sx={{ color: 'white' }} />
+                </IconButton>
+              )}
+            </Box>
+          </label>
+        </Box>
+
+        <Stack spacing={3}>
+          <TextField
+            fullWidth
+            label="Name"
+            name="name"
+            value={formValues.name}
+            onChange={handleChange}
+            disabled={!isEditing}
+            variant="outlined"
+          />
+
+          <TextField
+            fullWidth
+            label="Bio"
+            name="description"
+            value={formValues.description}
+            onChange={handleChange}
+            disabled={!isEditing}
+            multiline
+            rows={4}
+            variant="outlined"
+          />
+
+          {isEditing && (
+            <Stack direction="row" spacing={2} sx={{ mt: 2 }}>
+              <Button
+                fullWidth
+                variant="outlined"
+                onClick={() => {
+                  setIsEditing(false);
+                  setFormValues({
+                    name: profile.name,
+                    description: profile.description || '',
+                  });
+                  setPhoto(null);
+                  setPhotoByte(null);
+                }}
+              >
+                Cancel
+              </Button>
+              <Button
+                fullWidth
+                variant="contained"
+                onClick={handleUpdate}
+                disabled={loading}
+              >
+                {loading ? <CircularProgress size={24} /> : 'Save Changes'}
+              </Button>
+            </Stack>
+          )}
+        </Stack>
+      </Paper>
+    </Container>
+  );
+};
+
+export default ProfilePage;
+

# 2024-12-22 14:07:19.060705
+enable users to update name, and sescrption wile keeping the rest of the fetures

# 2024-12-22 14:14:32.620442
+add this ./frontend/pages/profile/friends.tsx to the chat

# 2024-12-22 14:14:46.561282
+yes

# 2024-12-22 14:15:07.977617
+add this to the chat ./src/frontend/components/Chat/chatWindow.tsx

# 2024-12-22 14:15:13.688841
+yes

# 2024-12-22 14:17:01.166263
+add ./src/frontend/pages/Discover/discover.tsx to the chat

# 2024-12-22 14:17:06.478233
+yes

# 2024-12-22 14:21:01.151104
+Notice there is a user avatar with messages option and with profile options in Dsocver page and another one in Friends compnent. Make One compnent called user avatar that has profile, messages, and review, also when click profile it should take you to user?id=<profile.id>, when click on messages it should show messages window with that user, when click on review should be able to sbumit a rview and call backendActor?.rate_user(user: Principal, mut rating: Rating) -> Result<(), String>

# 2024-12-22 14:21:51.947279
+y

# 2024-12-22 14:22:30.749692
+use the UserAvatarMenu in dscover and in friends

# 2024-12-22 14:22:50.813636
+yes

# 2024-12-22 14:24:18.852022
+how to do that?

# 2024-12-22 14:25:23.351267
+yes

# 2024-12-22 14:26:16.315676
+use messsage from ./src/frontend/components/Chat/chatWindow.tsx

# 2024-12-22 14:26:23.945521
+y

# 2024-12-22 14:26:56.251140
+how to do that?

# 2024-12-22 14:35:22.769104
+for UserAvatarmenu when click open chat open the chat just like here import React, { useState, useCallback } from "react";
+import {
+  List,
+  ListItem,
+  ListItemAvatar,
+  Avatar,
+  ListItemText,
+  Button,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  Typography,
+  Rating,
+  Stack,
+  Chip,
+  IconButton, Paper, TextField, Divider,
+} from "@mui/material";
+import {
+  Check as CheckIcon,
+  Close as CloseIcon,
+  PersonRemove as PersonRemoveIcon,
+} from "@mui/icons-material";
+import ChatWindow from "../../components/Chat/chatWindow";
+interface Review {
+  rating: number;
+  comment: string;
+  timestamp: string;
+  reviewerId: string;
+  reviewerName: string;
+}
+
+interface User {
+  id: string;
+  name: string;
+  description: string;
+  photo: string;
+  reviews?: Review[];
+  averageRating?: number;
+}
+
+interface Friend {
+  id: string;
+  sender: User;
+  receiver: User;
+  confirmed: boolean;
+}
+
+interface Chat {
+  id: string;
+  name: string;
+  messages: Array<{
+    id: string;
+    sender: string;
+    content: string;
+    timestamp: string;
+  }>;
+  members: string[];
+  admins: string[];
+}
+
+interface ChatWindowPosition {
+  x: number;
+  y: number;
+}
+
+interface FriendsListProps {
+  friends: Friend[];
+  currentUser: User;
+  onAcceptFriend: (friendId: string) => void;
+  onRejectFriend: (friendId: string) => void;
+  onCancelRequest: (friendId: string) => void;
+  onUnfriend: (friendId: string) => void;
+  onSendMessage: (userId: string, message: string) => void;
+  onRateUser: (userId: string, rating: number) => void;
+}
+
+const FriendsList: React.FC<FriendsListProps> = ({
+  friends,
+  currentUser,
+  onAcceptFriend,
+  onRejectFriend,
+  onCancelRequest,
+  onUnfriend,
+  onSendMessage,
+  onRateUser,
+}) => {
+  const [selectedUser, setSelectedUser] = useState<User | null>(null);
+  const [rating, setRating] = useState<number>(0);
+  const [review, setReview] = useState<string>("");
+  const [activeChats, setActiveChats] = useState<Map<string, Chat>>(new Map());
+  const [chatPositions, setChatPositions] = useState<
+    Map<string, ChatWindowPosition>
+  >(new Map());
+
+  const handleProfileClose = () => {
+    setSelectedUser(null);
+    setRating(0);
+  };
+
+  const handleSubmitReview = () => {
+    if (selectedUser && rating > 0) {
+      const newReview: Review = {
+        rating,
+        comment: review,
+        timestamp: new Date().toISOString(),
+        reviewerId: currentUser?.id || "",
+        reviewerName: currentUser?.name || "",
+      };
+      onRateUser(selectedUser.id, rating);
+      // Reset form
+      setRating(0);
+      setReview("");
+    }
+  };
+
+  const handleOpenChat = useCallback(
+    (user: User) => {
+      const chatId = `chat-${user.id}`;
+      if (!activeChats.has(chatId)) {
+        const newChat: Chat = {
+          id: chatId,
+          name: user.name,
+          messages: [],
+          members: [currentUser.id, user.id],
+          admins: [currentUser.id],
+        };
+
+        setActiveChats(new Map(activeChats.set(chatId, newChat)));
+
+        // Set initial position for new chat window
+        const position = {
+          x: window.innerWidth - 350 - activeChats.size * 20,
+          y: window.innerHeight - 450 - activeChats.size * 20,
+        };
+        setChatPositions(new Map(chatPositions.set(chatId, position)));
+      }
+      setSelectedUser(null);
+    },
+    [activeChats, chatPositions, currentUser && currentUser.id],
+  );
+
+  const handleCloseChat = useCallback((chatId: string) => {
+    setActiveChats((prevChats) => {
+      const newChats = new Map(prevChats);
+      newChats.delete(chatId);
+      return newChats;
+    });
+    setChatPositions((prevPositions) => {
+      const newPositions = new Map(prevPositions);
+      newPositions.delete(chatId);
+      return newPositions;
+    });
+  }, []);
+
+  const handleChatPositionChange = useCallback(
+    (chatId: string, position: ChatWindowPosition) => {
+      setChatPositions(
+        (prevPositions) => new Map(prevPositions.set(chatId, position)),
+      );
+    },
+    [],
+  );
+
+  const getFriendStatus = (friend: Friend) => {
+    const isSender = friend.sender.id === currentUser?.id;
+    if (friend.confirmed) {
+      return {
+        status: "Friends",
+        actions: (
+          <IconButton
+            color="error"
+            onClick={() => onUnfriend(friend.id)}
+            title="Unfriend"
+          >
+            <PersonRemoveIcon />
+          </IconButton>
+        ),
+      };
+    }
+    if (isSender) {
+      return {
+        status: "Request Sent",
+        actions: (
+          <IconButton
+            color="warning"
+            onClick={() => onCancelRequest(friend.id)}
+            title="Cancel Request"
+          >
+            <CloseIcon />
+          </IconButton>
+        ),
+      };
+    }
+    return {
+      status: "Request Received",
+      actions: (
+        <Stack direction="row" spacing={1}>
+          <IconButton
+            color="success"
+            onClick={() => onAcceptFriend(friend.id)}
+            title="Accept"
+          >
+            <CheckIcon />
+          </IconButton>
+          <IconButton
+            color="error"
+            onClick={() => onRejectFriend(friend.id)}
+            title="Reject"
+          >
+            <CloseIcon />
+          </IconButton>
+        </Stack>
+      ),
+    };
+  };
+
+  return (
+    <>
+      <List>
+        {friends.map((friend) => {
+          const otherUser =
+            friend.sender.id === currentUser?.id
+              ? friend.receiver
+              : friend.sender;
+          const { status, actions } = getFriendStatus(friend);
+
+          return (
+            <ListItem key={friend.id} secondaryAction={actions}>
+              <ListItemAvatar>
+                <Avatar
+                  src={`data:image/jpeg;base64,${otherUser.photo}`}
+                  onClick={() => setSelectedUser(otherUser)}
+                  sx={{ cursor: "pointer" }}
+                />
+              </ListItemAvatar>
+              <ListItemText
+                primary={otherUser.name}
+                secondary={
+                  <Stack direction="row" spacing={1} alignItems="center">
+                    <Chip
+                      label={status}
+                      size="small"
+                      color={friend.confirmed ? "success" : "default"}
+                    />
+                  </Stack>
+                }
+              />
+            </ListItem>
+          );
+        })}
+      </List>
+
+      <Dialog
+        open={!!selectedUser}
+        onClose={handleProfileClose}
+        maxWidth="md"
+        fullWidth
+      >
+        {selectedUser && (
+          <>
+            <DialogTitle>
+              <Stack direction="row" spacing={2} alignItems="center">
+                <Avatar
+                  src={`data:image/jpeg;base64,${selectedUser.photo}`}
+                  sx={{ width: 56, height: 56 }}
+                />
+                <Typography variant="h6">{selectedUser.name}</Typography>
+              </Stack>
+            </DialogTitle>
+            <DialogContent>
+              <Stack spacing={3}>
+                <Typography variant="body1">
+                  {selectedUser.description}
+                </Typography>
+
+                <Stack spacing={2}>
+
+                  {selectedUser.reviews?.map((review, index) => (
+                    <Paper
+                      key={index}
+                      sx={{ p: 2, bgcolor: "background.default" }}
+                    >
+                      <Stack spacing={1}>
+                        <Stack
+                          direction="row"
+                          justifyContent="space-between"
+                          alignItems="center"
+                        >
+                          <Typography variant="subtitle2">
+                            {review.reviewerName}
+                          </Typography>
+                          <Rating value={review.rating} readOnly size="small" />
+                        </Stack>
+                        <Typography variant="body2">
+                          {review.comment}
+                        </Typography>
+                        <Typography variant="caption" color="text.secondary">
+                          {new Date(review.timestamp).toLocaleDateString()}
+                        </Typography>
+                      </Stack>
+                    </Paper>
+                  ))}
+
+                  <Divider sx={{ my: 2 }} />
+
+                  <Typography variant="subtitle1">Write a Review</Typography>
+                  <Rating
+                    value={rating}
+                    onChange={(_, newValue) => handleRating(newValue)}
+                  />
+                  <TextField
+                    label="Your Review"
+                    multiline
+                    rows={3}
+                    value={review}
+                    onChange={(e) => setReview(e.target.value)}
+                    fullWidth
+                  />
+                </Stack>
+              </Stack>
+            </DialogContent>
+            <DialogActions>
+              <Button onClick={handleProfileClose}>Close</Button>
+              <Button
+                onClick={handleSubmitReview}
+                variant="outlined"
+                color="primary"
+                disabled={!rating || !review.trim()}
+              >
+                Submit Review
+              </Button>
+              <Button
+                onClick={() => handleOpenChat(selectedUser)}
+                variant="contained"
+                color="primary"
+              >
+                Open Chat
+              </Button>
+            </DialogActions>
+          </>
+        )}
+      </Dialog>
+
+      {/* Render active chat windows */}
+      {Array.from(activeChats.entries()).map(([chatId, chat]) => (
+        <ChatWindow
+          key={chatId}
+          chat={chat}
+          onClose={handleCloseChat}
+          position={chatPositions.get(chatId) || { x: 0, y: 0 }}
+          onPositionChange={handleChatPositionChange}
+        />
+      ))}
+    </>
+  );
+};
+
+export default FriendsList;
+ as you can see we are using import ChatWindow from "../../components/Chat/chatWindow";
+from ./src/frontend/components/Chat/chatWindow.tsx

# 2024-12-22 14:37:19.928794
+use the UserAvatarMenu here ./src/frontend/pages/profile/friends.tsx and remove the current avtar 

# 2024-12-22 14:37:35.963562
+how to do that?

# 2024-12-22 14:37:47.060355
+how to do that

# 2024-12-22 14:37:53.159916
+y

# 2024-12-22 14:39:34.562005
+import React, { useState, useCallback } from 'react';
+import { 
+  Avatar, 
+  IconButton, 
+  Menu, 
+  MenuItem, 
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  Button,
+  Rating,
+  TextField,
+  Typography
+} from '@mui/material';
+import ChatWindow from '../../components/Chat/chatWindow';
+import { useNavigate } from 'react-router-dom';
+import { Person, Message, Star } from '@mui/icons-material';
+import { useBackendContext } from '../../contexts/BackendContext';
+import { useSnackbar } from 'notistack';
+
+interface UserAvatarMenuProps {
+  user: {
+    id: string;
+    name: string;
+    photo?: Uint8Array;
+  };
+  onMessageClick?: () => void;
+}
+
+const UserAvatarMenu: React.FC<UserAvatarMenuProps> = ({ user, onMessageClick }) => {
+  const navigate = useNavigate();
+  const { backendActor } = useBackendContext();
+  const { enqueueSnackbar } = useSnackbar();
+  
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [reviewOpen, setReviewOpen] = useState(false);
+  const [rating, setRating] = useState<number>(0);
+  const [comment, setComment] = useState('');
+
+  const handleClick = (event: React.MouseEvent<HTMLElement>) => {
+    setAnchorEl(event.currentTarget);
+  };
+
+  const handleClose = () => {
+    setAnchorEl(null);
+  };
+
+  const handleProfile = () => {
+    navigate(`/user?id=${user.id}`);
+    handleClose();
+  };
+
+  const [activeChat, setActiveChat] = useState<any>(null);
+  const [chatPosition, setChatPosition] = useState({ x: 0, y: 0 });
+
+  const handleMessage = useCallback(() => {
+    const chatId = `chat-${user.id}`;
+    if (!activeChat) {
+      const newChat = {
+        id: chatId,
+        name: user.name,
+        messages: [],
+        members: [user.id],
+        admins: [user.id]
+      };
+
+      // Set initial position for chat window
+      const position = {
+        x: window.innerWidth - 350,
+        y: window.innerHeight - 450
+      };
+      setChatPosition(position);
+      setActiveChat(newChat);
+    }
+    handleClose();
+  }, [user, activeChat]);
+
+  const handleCloseChat = useCallback(() => {
+    setActiveChat(null);
+  }, []);
+
+  const handleChatPositionChange = useCallback((chatId: string, position: { x: number, y: number }) => {
+    setChatPosition(position);
+  }, []);
+
+  const handleSendMessage = async (chatId: string, message: string) => {
+    try {
+      if (onMessageClick) {
+        await onMessageClick();
+      }
+      
+      const result = await backendActor?.send_message({
+        recipient: user.id,
+        content: message,
+        timestamp: BigInt(Date.now())
+      });
+
+      if (result?.Ok) {
+        enqueueSnackbar('Message sent successfully', { variant: 'success' });
+      } else if (result?.Err) {
+        throw new Error(result.Err);
+      }
+    } catch (error) {
+      console.error('Error sending message:', error);
+      enqueueSnackbar(error.message || 'Failed to send message', { variant: 'error' });
+    }
+  };
+
+  const handleReviewClick = () => {
+    setReviewOpen(true);
+    handleClose();
+  };
+
+  const handleReviewSubmit = async () => {
+    try {
+      const result = await backendActor?.rate_user(user.id, {
+        rating,
+        comment,
+        date: BigInt(Date.now())
+      });
+
+      if (result?.Ok) {
+        enqueueSnackbar('Review submitted successfully', { variant: 'success' });
+      } else if (result?.Err) {
+        enqueueSnackbar(result.Err, { variant: 'error' });
+      }
+    } catch (error) {
+      console.error('Error submitting review:', error);
+      enqueueSnackbar('Failed to submit review', { variant: 'error' });
+    }
+    setReviewOpen(false);
+    setRating(0);
+    setComment('');
+  };
+
+  const getPhotoSrc = (photoData?: Uint8Array) => {
+    try {
+      return photoData && photoData.length > 0
+        ? `data:image/jpeg;base64,${Buffer.from(photoData).toString('base64')}`
+        : '';
+    } catch (e) {
+      console.error('Error converting photo:', e);
+      return '';
+    }
+  };
+
+  return (
+    <>
+      <IconButton onClick={handleClick}>
+        <Avatar 
+          src={getPhotoSrc(user.photo)}
+          alt={user.name}
+        >
+          {user.name?.charAt(0) || 'A'}
+        </Avatar>
+      </IconButton>
+
+      <Menu
+        anchorEl={anchorEl}
+        open={Boolean(anchorEl)}
+        onClose={handleClose}
+      >
+        <MenuItem onClick={handleProfile}>
+          <Person sx={{ mr: 1 }} /> Profile
+        </MenuItem>
+        <MenuItem onClick={handleMessage}>
+          <Message sx={{ mr: 1 }} /> Message
+        </MenuItem>
+        <MenuItem onClick={handleReviewClick}>
+          <Star sx={{ mr: 1 }} /> Review
+        </MenuItem>
+      </Menu>
+
+      <Dialog open={reviewOpen} onClose={() => setReviewOpen(false)}>
+        <DialogTitle>Review {user.name}</DialogTitle>
+        <DialogContent>
+          <Typography component="legend">Rating</Typography>
+          <Rating
+            value={rating}
+            onChange={(_, newValue) => setRating(newValue || 0)}
+          />
+          <TextField
+            autoFocus
+            margin="dense"
+            label="Comment"
+            fullWidth
+            multiline
+            rows={4}
+            value={comment}
+            onChange={(e) => setComment(e.target.value)}
+          />
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={() => setReviewOpen(false)}>Cancel</Button>
+          <Button onClick={handleReviewSubmit}>Submit Review</Button>
+        </DialogActions>
+      </Dialog>
+
+      {activeChat && (
+        <ChatWindow
+          chat={activeChat}
+          onClose={handleCloseChat}
+          position={chatPosition}
+          onPositionChange={handleChatPositionChange}
+          onSendMessage={handleSendMessage}
+        />
+      )}
+    </>
+  );
+};
+
+export default UserAvatarMenu;
+when submit a review call backendActor?.fn rate_user(user: Principal, mut rating: Rating) -> Result<(), String> {

# 2024-12-22 14:42:13.103674
+note export interface Rating {
+  'id' : string,
+  'date' : number,
+  'user_id' : Principal,
+  'comment' : string,
+  'rating' : number,
+}

# 2024-12-22 15:45:23.686197
+yes

# 2024-12-22 15:45:26.684399
+Uncaught SyntaxError: Unexpected identifier 'ActionRating' (at backend.did?t=1734853316012&import:1:6)

# 2024-12-22 15:45:51.386215
+y

# 2024-12-22 15:46:21.289783
+how to set the api provider key

# 2024-12-22 15:47:20.627027
+test

# 2024-12-22 15:47:32.528982
+no

# 2024-12-22 15:47:38.979462
+Uncaught SyntaxError: Unexpected identifier 'ActionRating' (at backend.did?t=1734853316012&import:1:6)

# 2024-12-22 15:48:29.078119
+type ActionRating = record {
+  id : text;
+  action_type : ActionType;
+  date : float64;
+  received_promises : float64;
+  spent : float64;
+  rating : float64;
+  received : float64;
+  promises : float64;
+};
+type ActionType = variant { Payment : CPayment };
+type AddOwnerArgs = record { owner : principal };
+type AddSwapArgs = record {
+  token0 : principal;
+  token1 : principal;
+  pool_canister : principal;
+};
+type AppMessage = record {
+  "text" : text;
+  notification : opt Notification;
+  timestamp : nat64;
+};
+type Approve = record {
+  fee : opt nat;
+  from : Index_Account;
+  memo : opt blob;
+  created_at_time : opt nat64;
+  amount : nat;
+  expected_allowance : opt nat;
+  expires_at : opt nat64;
+  spender : Index_Account;
+};
+type Burn = record {
+  from : Index_Account;
+  memo : opt blob;
+  created_at_time : opt nat64;
+  amount : nat;
+  spender : opt Index_Account;
+};
+type CCell = record { id : text; field : text; value : text };
+type CColumn = record {
+  id : text;
+  field : text;
+  formula_string : text;
+  column_type : text;
+  filters : vec Filter;
+  permissions : vec PermissionType;
+  name : text;
+  editable : bool;
+  deletable : bool;
+};
+type CContract = record {
+  id : text;
+  creator : principal;
+  date_created : float64;
+  name : text;
+  rows : vec CRow;
+  columns : vec CColumn;
+};
+type CPayment = record {
+  id : text;
+  status : PaymentStatus;
+  date_created : float64;
+  date_released : float64;
+  cells : vec CCell;
+  contract_id : text;
+  sender : principal;
+  amount : float64;
+  receiver : principal;
+};
+type CRow = record { id : text; cells : vec CCell };
+type CanisterOutputCertifiedMessages = record {
+  messages : vec CanisterOutputMessage;
+  cert : blob;
+  tree : blob;
+  is_end_of_queue : bool;
+};
+type CanisterOutputMessage = record {
+  key : text;
+  content : blob;
+  client_key : ClientKey;
+};
+type CanisterWsCloseArguments = record { client_key : ClientKey };
+type CanisterWsGetMessagesArguments = record { nonce : nat64 };
+type CanisterWsMessageArguments = record { msg : WebsocketMessage };
+type CanisterWsOpenArguments = record {
+  gateway_principal : principal;
+  client_nonce : nat64;
+};
+type Chat = record {
+  id : text;
+  creator : principal;
+  members : vec principal;
+  messages : vec Message;
+  name : text;
+  workspaces : vec text;
+  admins : vec principal;
+};
+type ClientKey = record { client_principal : principal; client_nonce : nat64 };
+type Column = record {
+  id : text;
+  _type : text;
+  field : text;
+  filters : vec Filter;
+  permissions : vec PermissionType;
+  dataValidator : opt text;
+  editable : bool;
+  formula : opt Formula;
+};
+type ContentData = variant { Comment : text; Image : vec nat64; Table : Table };
+type ContentNode = record {
+  id : text;
+  _type : text;
+  value : text;
+  data : opt ContentData;
+  "text" : text;
+  children : vec text;
+  language : text;
+  indent : nat64;
+  listStart : nat64;
+  parent : opt text;
+  listStyleType : text;
+};
+type Contract = variant { SharesContract : text };
+type ContractNotification = record { contract_type : text; contract_id : text };
+type ContractPermissionType = variant {
+  Add : principal;
+  Edit : principal;
+  View : principal;
+  AnyOneView;
+  AnyOneEdite;
+  AnyOneAdd;
+};
+type CustomContract = record {
+  id : text;
+  permissions : vec ContractPermissionType;
+  creator : text;
+  date_created : float64;
+  payments : vec CPayment;
+  name : text;
+  formulas : vec Formula;
+  contracts : vec CContract;
+  date_updated : float64;
+  promises : vec CPayment;
+};
+type Error = variant {
+  OwnerAlreadyExists;
+  InsufficientAllowance : record { allowance : nat };
+  SwapAlreadyExists;
+  InsufficientBalance : record { balance : nat };
+  InvalidPrincipal;
+  IcCdkError : record { message : text };
+  OwnerNotFound;
+  SwapNotFound;
+  SwapTokenNotFound;
+  Forbidden;
+  AmountTooSmall;
+};
+type Exchange = record {
+  to : text;
+  _type : ExchangeType;
+  date_created : float64;
+  from : text;
+  amount : float64;
+};
+type ExchangeType = variant { Withdraw; Deposit; LocalSend; LocalReceive };
+type Execute = variant { TransferNft; TransferToken; TransferUsdt : CPayment };
+type FEChat = record {
+  id : text;
+  creator : UserFE;
+  members : vec principal;
+  messages : vec Message;
+  name : text;
+  workspaces : vec text;
+  admins : vec UserFE;
+};
+type FileIndexing = record { id : text; new_index : nat64; parent : opt text };
+type FileNode = record {
+  id : text;
+  permission : ShareFilePermission;
+  content_id : opt text;
+  share_id : opt text;
+  name : text;
+  workspaces : vec text;
+  children : vec text;
+  author : text;
+  users_permissions : vec record { principal; ShareFilePermission };
+  parent : opt text;
+};
+type Filter = record {
+  name : text;
+  operations : vec Operation;
+  formula : opt text;
+};
+type Formula = record { column_id : text; execute : Execute };
+type Friend = record {
+  id : text;
+  sender : User;
+  confirmed : bool;
+  receiver : User;
+};
+type FriendRequestNotification = record { friend : Friend };
+type GetErrorLogsArgs = record { start : opt nat64; length : opt nat64 };
+type GetTransactions = record {
+  balance : nat;
+  transactions : vec TransactionWithId;
+  oldest_tx_id : opt nat;
+};
+type Index_Account = record { owner : principal; subaccount : opt blob };
+type InitialData = record {
+  FilesContents : opt vec record { text; vec ContentNode };
+  Contracts : vec record { text; StoredContract };
+  Files : vec FileNode;
+  Friends : vec Friend;
+  Profile : User;
+  DiscoverUsers : vec record { text; User };
+  Wallet : Wallet;
+};
+type Log = record { level : LogLevel; message : text; timestamp : nat64 };
+type LogLevel = variant { Error; Info; Debug };
+type Message = record {
+  id : text;
+  date : nat64;
+  sender : principal;
+  seen_by : vec principal;
+  message : text;
+  chat_id : text;
+};
+type Mint = record {
+  to : Index_Account;
+  memo : opt blob;
+  created_at_time : opt nat64;
+  amount : nat;
+};
+type NoteContent = variant {
+  CustomContract : record { text; CPayment };
+  ContractUpdate : ContractNotification;
+  FriendRequest : FriendRequestNotification;
+  AcceptFriendRequest;
+  ApproveShareRequest : text;
+  CPaymentContract : record { CPayment; PaymentAction };
+  Unfriend;
+  ReceivedDeposit : text;
+  ApplyShareRequest : text;
+  NewMessage : Message;
+  RemovedFromChat : text;
+};
+type Notification = record {
+  id : text;
+  is_seen : bool;
+  content : NoteContent;
+  time : float64;
+  sender : principal;
+  receiver : principal;
+};
+type Operation = variant { Equal; Contains; Bigger; BiggerOrEqual };
+type PayArgs = record {
+  token : principal;
+  memo : nat64;
+  to_merchant : principal;
+  amount : nat;
+};
+type PaymentAction = variant {
+  RequestCancellation : CPayment;
+  Released;
+  Objected;
+  Accepted;
+  Update;
+  Cancelled;
+  Promise;
+};
+type PaymentStatus = variant {
+  None;
+  RequestCancellation;
+  Released;
+  Objected : text;
+  Confirmed;
+  ConfirmedCancellation;
+  ApproveHighPromise;
+  HighPromise;
+};
+type PermissionType = variant {
+  Edit : principal;
+  View : principal;
+  AnyOneView;
+  AnyOneEdite;
+};
+type Post = record {
+  id : text;
+  creator : text;
+  date_created : nat64;
+  votes_up : vec principal;
+  tags : vec text;
+  content_tree : vec ContentNode;
+  votes_down : vec principal;
+};
+type PostUser = record {
+  id : text;
+  creator : UserFE;
+  date_created : nat64;
+  votes_up : vec principal;
+  tags : vec text;
+  content_tree : vec ContentNode;
+  votes_down : vec principal;
+};
+type Rating = record {
+  id : text;
+  date : float64;
+  user_id : principal;
+  comment : text;
+  rating : float64;
+};
+type RegisterUser = record {
+  name : opt text;
+  description : opt text;
+  photo : opt blob;
+};
+type RemoveSwapArgs = record { token0 : principal; token1 : principal };
+type Result = variant { Ok : User; Err : text };
+type Result_1 = variant { Ok; Err : Error };
+type Result_10 = variant { Ok : ShareFile; Err : text };
+type Result_11 = variant {
+  Ok : record { FileNode; vec ContentNode };
+  Err : text;
+};
+type Result_12 = variant { Ok : UserProfile; Err : text };
+type Result_13 = variant { Ok; Err };
+type Result_14 = variant { Ok : CanisterOutputCertifiedMessages; Err : text };
+type Result_2 = variant { Ok; Err : text };
+type Result_3 = variant { Ok : GetTransactions; Err : Error };
+type Result_4 = variant { Ok : text; Err : text };
+type Result_5 = variant { Ok : WorkSpace; Err : text };
+type Result_6 = variant { Ok : Wallet; Err : Error };
+type Result_7 = variant { Ok : StoredContract; Err : text };
+type Result_8 = variant { Ok : InitialData; Err : text };
+type Result_9 = variant { Ok : Post; Err : text };
+type Row = record {
+  id : text;
+  contract : opt Contract;
+  cells : opt vec record { text; text };
+};
+type ShareFile = record { id : text; owner : principal };
+type ShareFileInput = record {
+  id : text;
+  permission : ShareFilePermission;
+  owner : principal;
+  users_permissions : vec record { principal; ShareFilePermission };
+};
+type ShareFilePermission = variant { CanComment; None; CanView; CanUpdate };
+type StoredContract = variant { CustomContract : CustomContract };
+type Table = record { rows : vec Row; columns : vec Column };
+type Transaction = record {
+  burn : opt Burn;
+  kind : text;
+  mint : opt Mint;
+  approve : opt Approve;
+  timestamp : nat64;
+  transfer : opt Transfer;
+};
+type TransactionWithId = record { id : nat; transaction : Transaction };
+type Transfer = record {
+  to : Index_Account;
+  fee : opt nat;
+  from : Index_Account;
+  memo : opt blob;
+  created_at_time : opt nat64;
+  amount : nat;
+  spender : opt Index_Account;
+};
+type User = record { id : text; name : text; description : text; photo : blob };
+type UserFE = record { id : text; name : text };
+type UserProfile = record {
+  id : principal;
+  actions_rate : float64;
+  balance : float64;
+  rates_by_actions : vec ActionRating;
+  name : text;
+  description : text;
+  total_debt : float64;
+  spent : float64;
+  rates_by_others : vec Rating;
+  users_rate : float64;
+  users_interacted : float64;
+  photo : blob;
+  debts : vec text;
+  received : float64;
+};
+type Wallet = record {
+  balance : float64;
+  owner : text;
+  total_debt : float64;
+  spent : float64;
+  exchanges : vec Exchange;
+  debts : vec record { text; float64 };
+  received : float64;
+};
+type WebsocketMessage = record {
+  sequence_num : nat64;
+  content : blob;
+  client_key : ClientKey;
+  timestamp : nat64;
+  is_service_message : bool;
+};
+type WorkSpace = record {
+  id : text;
+  files : vec text;
+  creator : principal;
+  members : vec principal;
+  chats : vec text;
+  name : text;
+  admins : vec principal;
+};
+service : () -> {
+  accept_friend_request : (text) -> (Result);
+  add_owner : (AddOwnerArgs) -> (Result_1);
+  add_swap : (AddSwapArgs) -> (Result_1);
+  approve_high_promise : (CPayment) -> (Result_2);
+  cancel_friend_request : (text) -> (Result);
+  check_external_transactions : (nat) -> (Result_3);
+  confirmed_c_payment : (CPayment) -> (Result_2);
+  confirmed_cancellation : (CPayment) -> (Result_2);
+  counter : () -> (nat64) query;
+  create_new_file : (text, opt text) -> (FileNode);
+  delete_chat : (text) -> (Result_4);
+  delete_custom_contract : (text) -> (Result_2);
+  delete_file : (text) -> (opt FileNode);
+  delete_post : (text) -> (Result_2);
+  delete_work_space : (WorkSpace) -> (Result_5);
+  deposit_ckusdt : () -> (Result_6);
+  get_all_files : () -> (vec FileNode) query;
+  get_all_files_content : () -> (vec record { text; vec ContentNode }) query;
+  get_chats_notifications : () -> (vec Message) query;
+  get_contract : (text, text) -> (Result_7) query;
+  get_file : (text) -> (opt FileNode) query;
+  get_file_content : (text) -> (opt vec ContentNode) query;
+  get_filtered_posts : (opt vec text, opt text) -> (vec PostUser) query;
+  get_friends : () -> (vec Friend) query;
+  get_initial_data : () -> (Result_8) query;
+  get_logs : (GetErrorLogsArgs) -> (vec Log) query;
+  get_more_files : (float32) -> (
+      vec FileNode,
+      vec record { text; vec ContentNode },
+    ) query;
+  get_my_chats : () -> (vec FEChat) query;
+  get_owners : () -> (vec principal) query;
+  get_post : (text) -> (Result_9) query;
+  get_posts : (nat64, nat64) -> (vec PostUser) query;
+  get_share_file : (text) -> (Result_10) query;
+  get_shared_file : (text) -> (Result_11);
+  get_swaps : () -> (vec record { principal; principal }) query;
+  get_user : (text) -> (Result) query;
+  get_user_notifications : () -> (vec Notification) query;
+  get_user_profile : (principal) -> (Result_12) query;
+  get_work_spaces : () -> (vec WorkSpace) query;
+  internal_transaction : (float64, text, ExchangeType) -> (Result_2);
+  make_new_chat_room : (Chat) -> (Result_4);
+  message_is_seen : (Message) -> (Result_2);
+  move_file : (text, opt text) -> (Result_13);
+  multi_updates : (
+      vec FileNode,
+      vec vec record { text; vec ContentNode },
+      vec StoredContract,
+      vec FileIndexing,
+    ) -> (Result_4);
+  object_on_cancel : (CPayment, text) -> (Result_2);
+  pay : (PayArgs) -> (Result_1);
+  rate_user : (principal, Rating) -> (Result_2);
+  register : (RegisterUser) -> (Result);
+  reject_friend_request : (text) -> (Result);
+  remove_owner : (AddOwnerArgs) -> (Result_1);
+  remove_swap : (RemoveSwapArgs) -> (Result_1);
+  save_post : (Post) -> (Result_2);
+  save_work_space : (WorkSpace) -> (Result_5);
+  search_files_content : (text, bool) -> (
+      vec record { text; vec ContentNode },
+    ) query;
+  search_posts : (text) -> (vec PostUser) query;
+  see_notifications : (text) -> (Result_4);
+  send_friend_request : (text) -> (Result);
+  send_message : (opt principal, Message) -> (Result_4);
+  share_file : (ShareFileInput) -> (Result_10);
+  unfriend : (text) -> (Result);
+  update_chat : (Chat) -> (Result_4);
+  update_user_profile : (RegisterUser) -> (Result);
+  vote_down : (text) -> (Result_9);
+  vote_up : (text) -> (Result_9);
+  withdraw_ckusdt : (nat64, text) -> (Result_6);
+  ws_close : (CanisterWsCloseArguments) -> (Result_2);
+  ws_get_messages : (CanisterWsGetMessagesArguments) -> (Result_14) query;
+  ws_message : (CanisterWsMessageArguments, opt AppMessage) -> (Result_2);
+  ws_open : (CanisterWsOpenArguments) -> (Result_2);
+}
+

# 2024-12-22 15:48:40.582060
+y

# 2024-12-22 15:49:04.054849
+yes

# 2024-12-22 15:50:43.097157
+restart everything dfx start --clean and dfx deploy backend internet identy sh scripts/deploy_ledger.sh and yarn start and make suer to update .env by updating internet identiy id

# 2024-12-22 15:50:45.068452
+y

# 2024-12-22 15:50:58.057170
+/run dfx stop

# 2024-12-22 15:50:58.057381
+/run dfx stop

# 2024-12-22 15:50:59.357829
+/run dfx start --clean

# 2024-12-22 15:50:59.357969
+/run dfx start --clean

# 2024-12-22 15:50:59.938625
+/run dfx deploy internet_identity --network local

# 2024-12-22 15:50:59.938854
+/run dfx deploy internet_identity --network local

# 2024-12-22 15:51:00.675110
+/run dfx deploy backend --network local

# 2024-12-22 15:51:00.675325
+/run dfx deploy backend --network local

# 2024-12-22 15:51:01.409227
+/run sh scripts/deploy_ledger.sh

# 2024-12-22 15:51:01.409524
+/run sh scripts/deploy_ledger.sh

# 2024-12-22 15:51:45.748339
+y

# 2024-12-22 15:51:50.935701
+/run dfx canister id internet_identity

# 2024-12-22 15:51:50.936094
+/run dfx canister id internet_identity

# 2024-12-22 15:51:53.081698
+y

# 2024-12-22 15:51:54.450351
+/run yarn start

# 2024-12-22 15:51:54.450511
+/run yarn start

# 2024-12-22 15:51:58.078386
+y

# 2024-12-22 15:52:27.180195
+run dfx deploy internet idenjty and get the id and update .env file

# 2024-12-22 15:52:39.779426
+n

# 2024-12-22 15:52:48.883501
+no

# 2024-12-22 15:52:58.402263
+y

# 2024-12-22 16:08:25.612944
+load posts in ./src/frontend/pages/discover.tsx then store them in redux ./src/frontend/redux/reducers/filesReducer.ts then view posts in ./src/frontend/pages/Discover/discover.tsx giving that export interface PostUser {
+  'id' : string,
+  'creator' : UserFE,
+  'date_created' : bigint,
+  'votes_up' : Array<Principal>,
+  'tags' : Array<string>,
+  'content_tree' : Array<ContentNode>,
+  'votes_down' : Array<Principal>,
+} export interface UserFE { 'id' : string, 'name' : string } export interface ContentNode {
+  'id' : string,
+  '_type' : string,
+  'value' : string,
+  'data' : [] | [ContentData],
+  'text' : string,
+  'children' : Array<string>,
+  'language' : string,
+  'indent' : bigint,
+  'listStart' : bigint,
+  'parent' : [] | [string],
+  'listStyleType' : string,
+}

# 2024-12-22 16:08:33.145684
+yes

# 2024-12-22 16:10:16.305639
+/undo

# 2024-12-22 16:15:24.041640
+// import React, { useEffect } from "react";
+// import "../styles/LandingPage.css";
+// import { Button, Divider, Grid } from "@mui/material";
+// import { useSelector } from "react-redux";
+// import CreatePost from "./CreateNewPost";
+// import { PostUser } from "../../../declarations/backend/backend.did";
+// import { useSnackbar } from "notistack";
+// import FilterPosts from "./PostsFilters";
+// import ViewPost from "./ViewUpdatePost";
+// import { useBackendContext } from "../../contexts/BackendContext";
+//
+// const Discover = () => {
+//   const { backendActor } = useBackendContext();
+//   const { searchValue } = useSelector((state: any) => state.uiState);
+//   const { isLoggedIn } = useSelector((state: any) => state.uiState);
+//
+//   const [posts, setPosts] = React.useState<Array<PostUser>>([]); //TODO use redux for this
+//
+//   const [current_page, setPage] = React.useState<number>(0);
+//   const { enqueueSnackbar } = useSnackbar();
+//   useEffect(() => {
+//     let timeoutId: NodeJS.Timeout;
+//
+//     const delayedSearch = async () => {
+//       // TODO later add a Button for deep search_popper in cuz query can cost cycles.
+//       if (searchValue.length > 0) {
+//         let res: Array<PostUser> = await backendActor.search_posts(searchValue);
+//         res && setPosts(res);
+//       } else {
+//         setPage(0);
+//         setPosts([]);
+//         await set_posts();
+//       }
+//     };
+//
+//     // Clear the previous timeout
+//     clearTimeout(timeoutId);
+//
+//     // Set a new timeout
+//     timeoutId = setTimeout(delayedSearch, 300);
+//
+//     // Cleanup function
+//     return () => clearTimeout(timeoutId);
+//   }, [searchValue]);
+//
+//   async function set_posts() {
+//     posts.length > 0 && setPage(posts.length);
+//     let res: Array<PostUser> = await backendActor.get_posts(
+//       BigInt(current_page),
+//       BigInt(current_page + 10),
+//     );
+//
+//     if (res && res.length > 0) {
+//       setPosts((pre) => {
+//         return posts.length == 0 ? [...res] : [...pre, ...res];
+//       });
+//     } else if (res && res.length == 0) {
+//       enqueueSnackbar("There are no more posts to load.", { variant: "info" });
+//     } else {
+//       enqueueSnackbar("undefined Error getting posts.", { variant: "error" });
+//     }
+//   }
+//
+//   useEffect(() => {
+//     (async () => {
+//       await set_posts();
+//     })();
+//   }, []);
+//
+//   return (
+//     <Grid
+//       sx={{
+//         marginLeft: "20%",
+//         marginRight: "20%",
+//       }}
+//     >
+//       {isLoggedIn && <CreatePost setPosts={setPosts} />}
+//       <Divider />
+//       <FilterPosts initPosts={posts} setPage={setPage} setPosts={setPosts} />
+//       {posts &&
+//         posts.map((post: PostUser) => {
+//           return (
+//             <Grid
+//               item
+//               sx={{
+//                 my: 1,
+//                 // mx: 'auto',
+//               }}
+//             >
+//               <ViewPost setPosts={setPosts} post={post} />
+//             </Grid>
+//           );
+//         })}
+//
+//       <Button
+//         onClick={async () => {
+//           await set_posts();
+//         }}
+//       >
+//         Load more
+//       </Button>
+//     </Grid>
+//   );
+// };
+// export default Discover;
+
+import React, { useState } from "react";
+import {
+  Card,
+  CardContent,
+  CardHeader,
+  Avatar,
+  Button,
+  TextField,
+  IconButton,
+  Typography,
+  Popover,
+  Box,
+  Paper,
+} from "@mui/material";
+import {
+  Favorite as HeartIcon,
+  ThumbDown as ThumbsDownIcon,
+  Share as ShareIcon,
+  Comment as MessageCircleIcon,
+  Send as SendIcon,
+  Reply as ReplyIcon,
+  Email as MailIcon,
+  Person as UserIcon,
+} from "@mui/icons-material";
+import SearchIcon from "@mui/icons-material/Search";
+
+const UserAvatar = ({ user, size = "medium" }) => {
+  const [anchorEl, setAnchorEl] = useState(null);
+
+  const handleClick = (event) => {
+    setAnchorEl(event.currentTarget);
+  };
+
+  const handleClose = () => {
+    setAnchorEl(null);
+  };
+
+  const open = Boolean(anchorEl);
+
+  return (
+    <>
+      <Avatar
+        src={user.avatarUrl}
+        alt={user.name}
+        onClick={handleClick}
+        sx={{
+          width: size === "small" ? 32 : 40,
+          height: size === "small" ? 32 : 40,
+          cursor: "pointer",
+        }}
+      >
+        {!user.avatarUrl && user.name.charAt(0)}
+      </Avatar>
+
+      <Popover
+        open={open}
+        anchorEl={anchorEl}
+        onClose={handleClose}
+        anchorOrigin={{
+          vertical: "bottom",
+          horizontal: "center",
+        }}
+        transformOrigin={{
+          vertical: "top",
+          horizontal: "center",
+        }}
+      >
+        <Box sx={{ p: 2, width: 250 }}>
+          <Box
+            sx={{
+              display: "flex",
+              flexDirection: "column",
+              alignItems: "center",
+              mb: 2,
+            }}
+          >
+            <Avatar
+              src={user.avatarUrl}
+              alt={user.name}
+              sx={{ width: 60, height: 60, mb: 1 }}
+            >
+              {!user.avatarUrl && user.name.charAt(0)}
+            </Avatar>
+            <Typography variant="subtitle1">{user.name}</Typography>
+            <Typography variant="body2" color="text.secondary">
+              @{user.username}
+            </Typography>
+          </Box>
+          <Box sx={{ display: "flex", gap: 1 }}>
+            <Button
+              variant="contained"
+              fullWidth
+              startIcon={<UserIcon />}
+              onClick={() =>
+                (window.location.href = `/profile/${user.username}`)
+              }
+            >
+              Profile
+            </Button>
+            <Button
+              variant="outlined"
+              fullWidth
+              startIcon={<MailIcon />}
+              onClick={() =>
+                (window.location.href = `/messages/${user.username}`)
+              }
+            >
+              Message
+            </Button>
+          </Box>
+        </Box>
+      </Popover>
+    </>
+  );
+};
+
+const Comment = ({ comment, onReply, level = 0 }) => {
+  const [showReplyInput, setShowReplyInput] = useState(false);
+  const [replyContent, setReplyContent] = useState("");
+
+  const handleReplySubmit = () => {
+    if (!replyContent.trim()) return;
+    onReply(comment.id, replyContent);
+    setReplyContent("");
+    setShowReplyInput(false);
+  };
+
+  return (
+    <Box sx={{ ml: level * 3, mb: 2 }}>
+      <Paper variant="outlined" sx={{ p: 2 }}>
+        <Box sx={{ display: "flex", gap: 1, mb: 1 }}>
+          <UserAvatar user={comment.user} size="small" />
+          <Box>
+            <Typography variant="subtitle2">{comment.user.name}</Typography>
+            <Typography variant="caption" color="text.secondary">
+              {comment.timestamp}
+            </Typography>
+          </Box>
+        </Box>
+        <Typography variant="body2" sx={{ mb: 1 }}>
+          {comment.content}
+        </Typography>
+        <Button
+          size="small"
+          startIcon={<ReplyIcon />}
+          onClick={() => setShowReplyInput(!showReplyInput)}
+        >
+          Reply
+        </Button>
+      </Paper>
+
+      {showReplyInput && (
+        <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
+          <TextField
+            size="small"
+            fullWidth
+            placeholder="Write a reply..."
+            value={replyContent}
+            onChange={(e) => setReplyContent(e.target.value)}
+          />
+          <IconButton onClick={handleReplySubmit} color="primary">
+            <SendIcon />
+          </IconButton>
+        </Box>
+      )}
+
+      {comment.replies?.map((reply) => (
+        <Comment
+          key={reply.id}
+          comment={reply}
+          onReply={onReply}
+          level={level + 1}
+        />
+      ))}
+    </Box>
+  );
+};
+
+const SearchField = ({ searchQuery, setSearchQuery }) => {
+  return (
+    <Card sx={{ mb: 3 }}>
+      <CardContent>
+        <TextField
+          fullWidth
+          placeholder="Search posts by content or user..."
+          value={searchQuery}
+          onChange={(e) => setSearchQuery(e.target.value)}
+          InputProps={{
+            startAdornment: (
+              <Box sx={{ color: "text.secondary", mr: 1 }}>
+                <SearchIcon />
+              </Box>
+            ),
+          }}
+        />
+      </CardContent>
+    </Card>
+  );
+};
+
+const SocialPosts = () => {
+  const currentUser = {
+    id: 1,
+    name: "John Doe",
+    username: "johndoe",
+    avatarUrl: null,
+  };
+
+  const [posts, setPosts] = useState([
+    {
+      id: 1,
+      content: "This is my first post!",
+      likes: 0,
+      dislikes: 0,
+      comments: [],
+      isLiked: false,
+      isDisliked: false,
+      user: {
+        id: 2,
+        name: "Jane Smith",
+        username: "janesmith",
+        avatarUrl: null,
+      },
+    },
+  ]);
+
+  const [newPostContent, setNewPostContent] = useState("");
+  const [commentInputs, setCommentInputs] = useState({});
+  const [showComments, setShowComments] = useState({});
+
+  const handleNewPost = () => {
+    if (!newPostContent.trim()) return;
+
+    setPosts([
+      {
+        id: Date.now(),
+        content: newPostContent,
+        likes: 0,
+        dislikes: 0,
+        comments: [],
+        isLiked: false,
+        isDisliked: false,
+        user: currentUser,
+      },
+      ...posts,
+    ]);
+    setNewPostContent("");
+  };
+
+  const [searchQuery, setSearchQuery] = useState("");
+
+  // Add this function after other handler functions
+  const filteredPosts = posts.filter(
+    (post) =>
+      post.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
+      post.user.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
+      post.user.username.toLowerCase().includes(searchQuery.toLowerCase()),
+  );
+
+  const handleLike = (postId) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          if (post.isLiked) {
+            return { ...post, likes: post.likes - 1, isLiked: false };
+          } else {
+            if (post.isDisliked) {
+              return {
+                ...post,
+                likes: post.likes + 1,
+                dislikes: post.dislikes - 1,
+                isLiked: true,
+                isDisliked: false,
+              };
+            }
+            return { ...post, likes: post.likes + 1, isLiked: true };
+          }
+        }
+        return post;
+      }),
+    );
+  };
+
+  const handleDislike = (postId) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          if (post.isDisliked) {
+            return { ...post, dislikes: post.dislikes - 1, isDisliked: false };
+          } else {
+            if (post.isLiked) {
+              return {
+                ...post,
+                likes: post.likes - 1,
+                dislikes: post.dislikes + 1,
+                isLiked: false,
+                isDisliked: true,
+              };
+            }
+            return { ...post, dislikes: post.dislikes + 1, isDisliked: true };
+          }
+        }
+        return post;
+      }),
+    );
+  };
+
+  const handleShare = (postId) => {
+    alert("Share functionality would go here!");
+  };
+
+  const toggleComments = (postId) => {
+    setShowComments((prev) => ({
+      ...prev,
+      [postId]: !prev[postId],
+    }));
+  };
+
+  const handleComment = (postId) => {
+    if (!commentInputs[postId]?.trim()) return;
+
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          return {
+            ...post,
+            comments: [
+              ...post.comments,
+              {
+                id: Date.now(),
+                content: commentInputs[postId],
+                timestamp: new Date().toLocaleString(),
+                replies: [],
+                user: currentUser,
+              },
+            ],
+          };
+        }
+        return post;
+      }),
+    );
+
+    setCommentInputs((prev) => ({
+      ...prev,
+      [postId]: "",
+    }));
+  };
+
+  const handleReply = (postId, commentId, replyContent) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          const updatedComments = addReplyToComment(post.comments, commentId, {
+            id: Date.now(),
+            content: replyContent,
+            timestamp: new Date().toLocaleString(),
+            replies: [],
+            user: currentUser,
+          });
+          return { ...post, comments: updatedComments };
+        }
+        return post;
+      }),
+    );
+  };
+
+  const addReplyToComment = (comments, commentId, reply) => {
+    return comments.map((comment) => {
+      if (comment.id === commentId) {
+        return {
+          ...comment,
+          replies: [...(comment.replies || []), reply],
+        };
+      }
+      if (comment.replies?.length) {
+        return {
+          ...comment,
+          replies: addReplyToComment(comment.replies, commentId, reply),
+        };
+      }
+      return comment;
+    });
+  };
+
+  return (
+    <Box sx={{ maxWidth: 800, mx: "auto", p: 2 }}>
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Box sx={{ display: "flex", gap: 2, mb: 2 }}>
+            <UserAvatar user={currentUser} />
+            <TextField
+              fullWidth
+              multiline
+              rows={2}
+              placeholder="What's on your mind?"
+              value={newPostContent}
+              onChange={(e) => setNewPostContent(e.target.value)}
+            />
+          </Box>
+          <Button variant="contained" fullWidth onClick={handleNewPost}>
+            Post
+          </Button>
+        </CardContent>
+      </Card>
+
+      <SearchField searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
+
+      {filteredPosts.map((post) => (
+        <Card key={post.id} sx={{ mb: 2 }}>
+          <CardHeader
+            avatar={<UserAvatar user={post.user} />}
+            title={post.user.name}
+            subheader={`@${post.user.username}`}
+          />
+          <CardContent>
+            <Typography variant="body1">{post.content}</Typography>
+
+            <Box
+              sx={{ display: "flex", justifyContent: "space-between", mt: 2 }}
+            >
+              <Box sx={{ display: "flex", gap: 1 }}>
+                <Button
+                  startIcon={<HeartIcon />}
+                  onClick={() => handleLike(post.id)}
+                  color={post.isLiked ? "primary" : "inherit"}
+                >
+                  {post.likes}
+                </Button>
+                <Button
+                  startIcon={<ThumbsDownIcon />}
+                  onClick={() => handleDislike(post.id)}
+                  color={post.isDisliked ? "error" : "inherit"}
+                >
+                  {post.dislikes}
+                </Button>
+                <Button
+                  startIcon={<MessageCircleIcon />}
+                  onClick={() => toggleComments(post.id)}
+                >
+                  {post.comments.length}
+                </Button>
+              </Box>
+              <IconButton onClick={() => handleShare(post.id)}>
+                <ShareIcon />
+              </IconButton>
+            </Box>
+
+            {showComments[post.id] && (
+              <Box sx={{ mt: 2 }}>
+                <Box sx={{ display: "flex", gap: 1, mb: 2 }}>
+                  <TextField
+                    size="small"
+                    fullWidth
+                    placeholder="Write a comment..."
+                    value={commentInputs[post.id] || ""}
+                    onChange={(e) =>
+                      setCommentInputs((prev) => ({
+                        ...prev,
+                        [post.id]: e.target.value,
+                      }))
+                    }
+                  />
+                  <IconButton
+                    onClick={() => handleComment(post.id)}
+                    color="primary"
+                  >
+                    <SendIcon />
+                  </IconButton>
+                </Box>
+
+                <Box sx={{ mt: 2 }}>
+                  {post.comments.map((comment) => (
+                    <Comment
+                      key={comment.id}
+                      comment={comment}
+                      onReply={(commentId, content) =>
+                        handleReply(post.id, commentId, content)
+                      }
+                    />
+                  ))}
+                </Box>
+              </Box>
+            )}
+          </CardContent>
+        </Card>
+      ))}
+    </Box>
+  );
+};
+
+export default SocialPosts;
+ remove the commented code, get posts from backendActor?.search_posts... enable users to create new posts by calling backendAcotr?.save_post also enable all other actions use std::time::{Duration, SystemTime};
+// use std::sync::atomic::Ordering;
+// use candid::Principal;
+use ic_cdk::caller;
+use ic_cdk_macros::update;
+
+use crate::discover::Post;
+
+// Move it to util
+pub fn time_diff(i: u64, f: u64) -> Duration {
+    let date_created_duration = Duration::from_nanos(f);
+    let current_time_duration = Duration::from_nanos(i);
+    current_time_duration - date_created_duration
+}
+
+#[update]
+fn save_post(mut post: Post) -> Result<(), String> {
+    if caller().to_string() == *"2vxsx-fae" {
+        return Err("Anonymous users not allowed to create posts".to_string());
+    }
+    let original_post = Post::get(post.id.clone());
+    if let Ok(p) = original_post.clone() {
+        post.votes_up = p.votes_up;
+        post.votes_down = p.votes_down;
+        post.date_created = p.date_created.clone();
+    } else {
+        let posts = Post::get_latest_posts();
+        post.date_created = ic_cdk::api::time();
+
+        if posts.len() >= 2 {
+            // TODO make sure the ordering is correct, otherwise the hours, and minutes may be not accurate
+            //     it should take the posted dates, but it may take the last post in the array instead of the actual last post
+            //     print("dif is hre----");
+            //     let x = posts.last().unwrap().date_created.clone() - posts.first().unwrap().date_created.clone();
+            //     print(x.to_string());
+
+            let one_day = 86400;
+            let diff = time_diff(
+                posts.last().unwrap().date_created.clone(),
+                ic_cdk::api::time(),
+            );
+            if diff < Duration::from_secs(one_day.clone()) {
+                let hours = &one_day - diff.as_secs();
+                let remainder = (one_day - diff.as_secs()) % 3600;
+                let msg = format!(
+                    "please wait {} hours and {} minutes",
+                    hours / 3600,
+                    remainder / 60
+                );
+                return Err(msg);
+            }
+        }
+        post.votes_up = vec![];
+        post.votes_down = vec![];
+        post.date_created = ic_cdk::api::time();
+    }
+    // if post.creator != caller().to_string(); {Err}
+    post.creator = caller().to_string();
+    post.save();
+    Ok(())
+}
+
+#[update]
+fn delete_post(id: String) -> Result<(), String> {
+    let post = Post::get(id.clone())?;
+    if post.creator != caller().to_string() {
+        return Err("Only the post creator can delete this.".to_string());
+    };
+    Post::delete(id)
+}
+
+#[update]
+fn vote_up(id: String) -> Result<Post, String> {
+    let mut post = Post::get(id.clone())?;
+    if caller().to_string() == post.creator {
+        return Err("You can't vote on your own post".to_string());
+    }
+    if post.votes_up.contains(&caller()) {
+        return Err("You have already voted on this post.".to_string());
+    }
+
+    post.votes_up.push(caller());
+    if post.votes_down.contains(&caller()) {
+        post.votes_down.retain(|x| x != &caller());
+    }
+    post.save();
+
+    Ok(post)
+}
+
+#[update]
+fn vote_down(id: String) -> Result<Post, String> {
+    let mut post = Post::get(id.clone())?;
+    if caller().to_string() == post.creator {
+        return Err("You can't vote on your own post".to_string());
+    }
+    if post.votes_down.contains(&caller()) {
+        return Err("You have already voted on this post.".to_string());
+    }
+    post.votes_down.push(caller());
+    if post.votes_up.contains(&caller()) {
+        post.votes_up.retain(|x| x != &caller());
+    }
+    post.save();
+    // let content: NoteContent = NoteContent::PostVote(id.clone());
+    // let new_note = Notification {
+    //     id: COUNTER.fetch_add(1, Ordering::SeqCst).to_string(),
+    //     sender: caller(),
+    //     receiver: Principal::from_text("2vxsx-fae").unwrap(),
+    //     content,
+    //     is_seen: false,
+    // };
+    // new_note.send();
+    // Send to everyone
+    // TODO in the frontend connect two websockts
+    //  1. with the user principal
+    //  2. with the `2vxsx-fae` principal
+    Ok(post)
+}
+

# 2024-12-22 16:16:45.570309
+
+import React, { useState } from "react";
+import {
+  Card,
+  CardContent,
+  CardHeader,
+  Avatar,
+  Button,
+  TextField,
+  IconButton,
+  Typography,
+  Popover,
+  Box,
+  Paper,
+} from "@mui/material";
+import {
+  Favorite as HeartIcon,
+  ThumbDown as ThumbsDownIcon,
+  Share as ShareIcon,
+  Comment as MessageCircleIcon,
+  Send as SendIcon,
+  Reply as ReplyIcon,
+  Email as MailIcon,
+  Person as UserIcon,
+} from "@mui/icons-material";
+import SearchIcon from "@mui/icons-material/Search";
+
+const UserAvatar = ({ user, size = "medium" }) => {
+  const [anchorEl, setAnchorEl] = useState(null);
+
+  const handleClick = (event) => {
+    setAnchorEl(event.currentTarget);
+  };
+
+  const handleClose = () => {
+    setAnchorEl(null);
+  };
+
+  const open = Boolean(anchorEl);
+
+  return (
+    <>
+      <Avatar
+        src={user.avatarUrl}
+        alt={user.name}
+        onClick={handleClick}
+        sx={{
+          width: size === "small" ? 32 : 40,
+          height: size === "small" ? 32 : 40,
+          cursor: "pointer",
+        }}
+      >
+        {!user.avatarUrl && user.name.charAt(0)}
+      </Avatar>
+
+      <Popover
+        open={open}
+        anchorEl={anchorEl}
+        onClose={handleClose}
+        anchorOrigin={{
+          vertical: "bottom",
+          horizontal: "center",
+        }}
+        transformOrigin={{
+          vertical: "top",
+          horizontal: "center",
+        }}
+      >
+        <Box sx={{ p: 2, width: 250 }}>
+          <Box
+            sx={{
+              display: "flex",
+              flexDirection: "column",
+              alignItems: "center",
+              mb: 2,
+            }}
+          >
+            <Avatar
+              src={user.avatarUrl}
+              alt={user.name}
+              sx={{ width: 60, height: 60, mb: 1 }}
+            >
+              {!user.avatarUrl && user.name.charAt(0)}
+            </Avatar>
+            <Typography variant="subtitle1">{user.name}</Typography>
+            <Typography variant="body2" color="text.secondary">
+              @{user.username}
+            </Typography>
+          </Box>
+          <Box sx={{ display: "flex", gap: 1 }}>
+            <Button
+              variant="contained"
+              fullWidth
+              startIcon={<UserIcon />}
+              onClick={() =>
+                (window.location.href = `/profile/${user.username}`)
+              }
+            >
+              Profile
+            </Button>
+            <Button
+              variant="outlined"
+              fullWidth
+              startIcon={<MailIcon />}
+              onClick={() =>
+                (window.location.href = `/messages/${user.username}`)
+              }
+            >
+              Message
+            </Button>
+          </Box>
+        </Box>
+      </Popover>
+    </>
+  );
+};
+
+const Comment = ({ comment, onReply, level = 0 }) => {
+  const [showReplyInput, setShowReplyInput] = useState(false);
+  const [replyContent, setReplyContent] = useState("");
+
+  const handleReplySubmit = () => {
+    if (!replyContent.trim()) return;
+    onReply(comment.id, replyContent);
+    setReplyContent("");
+    setShowReplyInput(false);
+  };
+
+  return (
+    <Box sx={{ ml: level * 3, mb: 2 }}>
+      <Paper variant="outlined" sx={{ p: 2 }}>
+        <Box sx={{ display: "flex", gap: 1, mb: 1 }}>
+          <UserAvatar user={comment.user} size="small" />
+          <Box>
+            <Typography variant="subtitle2">{comment.user.name}</Typography>
+            <Typography variant="caption" color="text.secondary">
+              {comment.timestamp}
+            </Typography>
+          </Box>
+        </Box>
+        <Typography variant="body2" sx={{ mb: 1 }}>
+          {comment.content}
+        </Typography>
+        <Button
+          size="small"
+          startIcon={<ReplyIcon />}
+          onClick={() => setShowReplyInput(!showReplyInput)}
+        >
+          Reply
+        </Button>
+      </Paper>
+
+      {showReplyInput && (
+        <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
+          <TextField
+            size="small"
+            fullWidth
+            placeholder="Write a reply..."
+            value={replyContent}
+            onChange={(e) => setReplyContent(e.target.value)}
+          />
+          <IconButton onClick={handleReplySubmit} color="primary">
+            <SendIcon />
+          </IconButton>
+        </Box>
+      )}
+
+      {comment.replies?.map((reply) => (
+        <Comment
+          key={reply.id}
+          comment={reply}
+          onReply={onReply}
+          level={level + 1}
+        />
+      ))}
+    </Box>
+  );
+};
+
+const SearchField = ({ searchQuery, setSearchQuery }) => {
+  return (
+    <Card sx={{ mb: 3 }}>
+      <CardContent>
+        <TextField
+          fullWidth
+          placeholder="Search posts by content or user..."
+          value={searchQuery}
+          onChange={(e) => setSearchQuery(e.target.value)}
+          InputProps={{
+            startAdornment: (
+              <Box sx={{ color: "text.secondary", mr: 1 }}>
+                <SearchIcon />
+              </Box>
+            ),
+          }}
+        />
+      </CardContent>
+    </Card>
+  );
+};
+
+const SocialPosts = () => {
+  const currentUser = {
+    id: 1,
+    name: "John Doe",
+    username: "johndoe",
+    avatarUrl: null,
+  };
+
+  const [posts, setPosts] = useState([
+    {
+      id: 1,
+      content: "This is my first post!",
+      likes: 0,
+      dislikes: 0,
+      comments: [],
+      isLiked: false,
+      isDisliked: false,
+      user: {
+        id: 2,
+        name: "Jane Smith",
+        username: "janesmith",
+        avatarUrl: null,
+      },
+    },
+  ]);
+
+  const [newPostContent, setNewPostContent] = useState("");
+  const [commentInputs, setCommentInputs] = useState({});
+  const [showComments, setShowComments] = useState({});
+
+  const handleNewPost = () => {
+    if (!newPostContent.trim()) return;
+
+    setPosts([
+      {
+        id: Date.now(),
+        content: newPostContent,
+        likes: 0,
+        dislikes: 0,
+        comments: [],
+        isLiked: false,
+        isDisliked: false,
+        user: currentUser,
+      },
+      ...posts,
+    ]);
+    setNewPostContent("");
+  };
+
+  const [searchQuery, setSearchQuery] = useState("");
+
+  // Add this function after other handler functions
+  const filteredPosts = posts.filter(
+    (post) =>
+      post.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
+      post.user.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
+      post.user.username.toLowerCase().includes(searchQuery.toLowerCase()),
+  );
+
+  const handleLike = (postId) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          if (post.isLiked) {
+            return { ...post, likes: post.likes - 1, isLiked: false };
+          } else {
+            if (post.isDisliked) {
+              return {
+                ...post,
+                likes: post.likes + 1,
+                dislikes: post.dislikes - 1,
+                isLiked: true,
+                isDisliked: false,
+              };
+            }
+            return { ...post, likes: post.likes + 1, isLiked: true };
+          }
+        }
+        return post;
+      }),
+    );
+  };
+
+  const handleDislike = (postId) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          if (post.isDisliked) {
+            return { ...post, dislikes: post.dislikes - 1, isDisliked: false };
+          } else {
+            if (post.isLiked) {
+              return {
+                ...post,
+                likes: post.likes - 1,
+                dislikes: post.dislikes + 1,
+                isLiked: false,
+                isDisliked: true,
+              };
+            }
+            return { ...post, dislikes: post.dislikes + 1, isDisliked: true };
+          }
+        }
+        return post;
+      }),
+    );
+  };
+
+  const handleShare = (postId) => {
+    alert("Share functionality would go here!");
+  };
+
+  const toggleComments = (postId) => {
+    setShowComments((prev) => ({
+      ...prev,
+      [postId]: !prev[postId],
+    }));
+  };
+
+  const handleComment = (postId) => {
+    if (!commentInputs[postId]?.trim()) return;
+
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          return {
+            ...post,
+            comments: [
+              ...post.comments,
+              {
+                id: Date.now(),
+                content: commentInputs[postId],
+                timestamp: new Date().toLocaleString(),
+                replies: [],
+                user: currentUser,
+              },
+            ],
+          };
+        }
+        return post;
+      }),
+    );
+
+    setCommentInputs((prev) => ({
+      ...prev,
+      [postId]: "",
+    }));
+  };
+
+  const handleReply = (postId, commentId, replyContent) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          const updatedComments = addReplyToComment(post.comments, commentId, {
+            id: Date.now(),
+            content: replyContent,
+            timestamp: new Date().toLocaleString(),
+            replies: [],
+            user: currentUser,
+          });
+          return { ...post, comments: updatedComments };
+        }
+        return post;
+      }),
+    );
+  };
+
+  const addReplyToComment = (comments, commentId, reply) => {
+    return comments.map((comment) => {
+      if (comment.id === commentId) {
+        return {
+          ...comment,
+          replies: [...(comment.replies || []), reply],
+        };
+      }
+      if (comment.replies?.length) {
+        return {
+          ...comment,
+          replies: addReplyToComment(comment.replies, commentId, reply),
+        };
+      }
+      return comment;
+    });
+  };
+
+  return (
+    <Box sx={{ maxWidth: 800, mx: "auto", p: 2 }}>
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Box sx={{ display: "flex", gap: 2, mb: 2 }}>
+            <UserAvatar user={currentUser} />
+            <TextField
+              fullWidth
+              multiline
+              rows={2}
+              placeholder="What's on your mind?"
+              value={newPostContent}
+              onChange={(e) => setNewPostContent(e.target.value)}
+            />
+          </Box>
+          <Button variant="contained" fullWidth onClick={handleNewPost}>
+            Post
+          </Button>
+        </CardContent>
+      </Card>
+
+      <SearchField searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
+
+      {filteredPosts.map((post) => (
+        <Card key={post.id} sx={{ mb: 2 }}>
+          <CardHeader
+            avatar={<UserAvatar user={post.user} />}
+            title={post.user.name}
+            subheader={`@${post.user.username}`}
+          />
+          <CardContent>
+            <Typography variant="body1">{post.content}</Typography>
+
+            <Box
+              sx={{ display: "flex", justifyContent: "space-between", mt: 2 }}
+            >
+              <Box sx={{ display: "flex", gap: 1 }}>
+                <Button
+                  startIcon={<HeartIcon />}
+                  onClick={() => handleLike(post.id)}
+                  color={post.isLiked ? "primary" : "inherit"}
+                >
+                  {post.likes}
+                </Button>
+                <Button
+                  startIcon={<ThumbsDownIcon />}
+                  onClick={() => handleDislike(post.id)}
+                  color={post.isDisliked ? "error" : "inherit"}
+                >
+                  {post.dislikes}
+                </Button>
+                <Button
+                  startIcon={<MessageCircleIcon />}
+                  onClick={() => toggleComments(post.id)}
+                >
+                  {post.comments.length}
+                </Button>
+              </Box>
+              <IconButton onClick={() => handleShare(post.id)}>
+                <ShareIcon />
+              </IconButton>
+            </Box>
+
+            {showComments[post.id] && (
+              <Box sx={{ mt: 2 }}>
+                <Box sx={{ display: "flex", gap: 1, mb: 2 }}>
+                  <TextField
+                    size="small"
+                    fullWidth
+                    placeholder="Write a comment..."
+                    value={commentInputs[post.id] || ""}
+                    onChange={(e) =>
+                      setCommentInputs((prev) => ({
+                        ...prev,
+                        [post.id]: e.target.value,
+                      }))
+                    }
+                  />
+                  <IconButton
+                    onClick={() => handleComment(post.id)}
+                    color="primary"
+                  >
+                    <SendIcon />
+                  </IconButton>
+                </Box>
+
+                <Box sx={{ mt: 2 }}>
+                  {post.comments.map((comment) => (
+                    <Comment
+                      key={comment.id}
+                      comment={comment}
+                      onReply={(commentId, content) =>
+                        handleReply(post.id, commentId, content)
+                      }
+                    />
+                  ))}
+                </Box>
+              </Box>
+            )}
+          </CardContent>
+        </Card>
+      ))}
+    </Box>
+  );
+};
+
+export default SocialPosts;
+ get real posts from backendActor.searchPosts instead of deummy posts also enable all other actions use std::time::{Duration, SystemTime};
+// use std::sync::atomic::Ordering;
+// use candid::Principal;
+use ic_cdk::caller;
+use ic_cdk_macros::update;
+
+use crate::discover::Post;
+
+// Move it to util
+pub fn time_diff(i: u64, f: u64) -> Duration {
+    let date_created_duration = Duration::from_nanos(f);
+    let current_time_duration = Duration::from_nanos(i);
+    current_time_duration - date_created_duration
+}
+
+#[update]
+fn save_post(mut post: Post) -> Result<(), String> {
+    if caller().to_string() == *"2vxsx-fae" {
+        return Err("Anonymous users not allowed to create posts".to_string());
+    }
+    let original_post = Post::get(post.id.clone());
+    if let Ok(p) = original_post.clone() {
+        post.votes_up = p.votes_up;
+        post.votes_down = p.votes_down;
+        post.date_created = p.date_created.clone();
+    } else {
+        let posts = Post::get_latest_posts();
+        post.date_created = ic_cdk::api::time();
+
+        if posts.len() >= 2 {
+            // TODO make sure the ordering is correct, otherwise the hours, and minutes may be not accurate
+            //     it should take the posted dates, but it may take the last post in the array instead of the actual last post
+            //     print("dif is hre----");
+            //     let x = posts.last().unwrap().date_created.clone() - posts.first().unwrap().date_created.clone();
+            //     print(x.to_string());
+
+            let one_day = 86400;
+            let diff = time_diff(
+                posts.last().unwrap().date_created.clone(),
+                ic_cdk::api::time(),
+            );
+            if diff < Duration::from_secs(one_day.clone()) {
+                let hours = &one_day - diff.as_secs();
+                let remainder = (one_day - diff.as_secs()) % 3600;
+                let msg = format!(
+                    "please wait {} hours and {} minutes",
+                    hours / 3600,
+                    remainder / 60
+                );
+                return Err(msg);
+            }
+        }
+        post.votes_up = vec![];
+        post.votes_down = vec![];
+        post.date_created = ic_cdk::api::time();
+    }
+    // if post.creator != caller().to_string(); {Err}
+    post.creator = caller().to_string();
+    post.save();
+    Ok(())
+}
+
+#[update]
+fn delete_post(id: String) -> Result<(), String> {
+    let post = Post::get(id.clone())?;
+    if post.creator != caller().to_string() {
+        return Err("Only the post creator can delete this.".to_string());
+    };
+    Post::delete(id)
+}
+
+#[update]
+fn vote_up(id: String) -> Result<Post, String> {
+    let mut post = Post::get(id.clone())?;
+    if caller().to_string() == post.creator {
+        return Err("You can't vote on your own post".to_string());
+    }
+    if post.votes_up.contains(&caller()) {
+        return Err("You have already voted on this post.".to_string());
+    }
+
+    post.votes_up.push(caller());
+    if post.votes_down.contains(&caller()) {
+        post.votes_down.retain(|x| x != &caller());
+    }
+    post.save();
+
+    Ok(post)
+}
+
+#[update]
+fn vote_down(id: String) -> Result<Post, String> {
+    let mut post = Post::get(id.clone())?;
+    if caller().to_string() == post.creator {
+        return Err("You can't vote on your own post".to_string());
+    }
+    if post.votes_down.contains(&caller()) {
+        return Err("You have already voted on this post.".to_string());
+    }
+    post.votes_down.push(caller());
+    if post.votes_up.contains(&caller()) {
+        post.votes_up.retain(|x| x != &caller());
+    }
+    post.save();
+    // let content: NoteContent = NoteContent::PostVote(id.clone());
+    // let new_note = Notification {
+    //     id: COUNTER.fetch_add(1, Ordering::SeqCst).to_string(),
+    //     sender: caller(),
+    //     receiver: Principal::from_text("2vxsx-fae").unwrap(),
+    //     content,
+    //     is_seen: false,
+    // };
+    // new_note.send();
+    // Send to everyone
+    // TODO in the frontend connect two websockts
+    //  1. with the user principal
+    //  2. with the `2vxsx-fae` principal
+    Ok(post)
+}
+ // make a query that get post order from older to newer
+
+use crate::discover::{Post, PostUser, UserFE};
+use ic_cdk_macros::query;
+use std::collections::HashMap;
+
+use crate::files_content::ContentNode;
+use crate::storage_schema::FileId;
+use crate::user::User;
+use crate::POSTS;
+
+#[query]
+fn get_posts(start: usize, count: usize) -> Vec<PostUser> {
+    Post::get_pagination(start, count)
+}
+
+#[query]
+fn get_filtered_posts(tags: Option<Vec<String>>, creator: Option<String>) -> Vec<PostUser> {
+    Post::get_filtered(tags, creator)
+    // paginate the first 50 posts
+    // let start = 0;
+    // let count = 50;
+    // let actual_count = usize::min(count, posts.len() - start.clone());
+    // posts
+    //     .into_iter()
+    //     .skip(start)
+    //     .take(actual_count)
+    //     .collect()
+}
+
+#[query]
+fn search_posts(text_to_find: String) -> Vec<PostUser> {
+    POSTS.with(|posts| {
+        let posts = posts.borrow();
+
+        let filtered_user_posts = posts
+            .iter()
+            .flat_map(|(_, post)| {
+                let content_tree = post.content_tree.clone();
+                content_tree
+                    .iter()
+                    .filter(|node| node.text.contains(&text_to_find))
+                    .map(move |node| {
+                        let user = User::get_user_from_text_principal(&post.creator).unwrap();
+                        let creator = UserFE {
+                            id: user.id.clone(),
+                            name: user.name.clone(),
+                        };
+                        PostUser {
+                            id: post.id.clone(),
+                            content_tree: post.content_tree.clone(),
+                            tags: post.tags.clone(),
+                            creator,
+                            date_created: post.date_created,
+                            votes_up: post.votes_up.clone(),
+                            votes_down: post.votes_down.clone(),
+                        }
+                    })
+                    .collect::<Vec<PostUser>>()
+            })
+            .collect::<Vec<PostUser>>();
+
+        filtered_user_posts
+    })
+}
+
+// #[query]
+// fn search_posts(text_to_find: String) -> Vec<String> {
+//
+//     POSTS.with(|posts| {
+//         let posts = posts.borrow();
+//
+//         let filtered_post_ids = posts
+//             .values()
+//             .filter(|post| post.content_tree.values().any(|node| node.text.contains(&text_to_find)))
+//             .map(|post| post.id.clone())
+//             .collect::<Vec<String>>();
+//
+//         filtered_post_ids
+//     })
+// }
+
+// #[query]
+// fn search_posts(text_to_find: String) -> Vec<String> {
+//     POSTS.with(|posts| {
+//         let posts = posts.borrow();
+//
+//         let filtered_node_ids = posts
+//             .values()
+//             .flat_map(|post| post.content_tree.values().filter(|node| node.text.contains(&text_to_find)).map(|node| node.id.clone()))
+//             .collect::<Vec<String>>();
+//
+//         filtered_node_ids
+//     })
+// }
+
+#[query]
+fn get_post(id: String) -> Result<Post, String> {
+    Post::get(id)
+}
+

# 2024-12-22 16:17:01.637284
+yes

# 2024-12-22 16:18:02.152804
+you don't understand, this file ./src/frontend/pages/Discover/discover.tsx have dummy data, also does not create real post in the backend fix that

# 2024-12-22 16:18:08.804735
+yes

# 2024-12-22 16:18:15.077393
+/run cat ./src/frontend/pages/Discover/discover.tsx

# 2024-12-22 16:18:15.077552
+/run cat ./src/frontend/pages/Discover/discover.tsx

# 2024-12-22 16:18:17.172578
+ye

# 2024-12-22 16:25:31.767416
+./src/frontend/pages/Discover/discover.tsx use react data from backendActor?.search_posts(searchValue); to render the real posts

# 2024-12-22 16:26:02.120111
+yes

# 2024-12-22 16:27:02.558987
+ther ewas a mistake retrwite again

# 2024-12-22 16:27:14.049176
+y

# 2024-12-22 16:27:50.586067
+[plugin:vite:esbuild] Transform failed with 1 error:
+/Users/ahmed/Desktop/odoc/src/frontend/pages/Discover/discover.tsx:443:12: ERROR: Expected ")" but found "sx"
+/Users/ahmed/Desktop/odoc/src/frontend/pages/Discover/discover.tsx:443:12
+Expected ")" but found "sx"
+441|        </Button>
+442|      </Grid>
+443|        <Card sx={{ mb: 3 }}>
+   |              ^
+444|          <CardContent>
+445|            <Box sx={{ display: "flex", gap: 2, mb: 2 }}>
+    at failureErrorWithLog (/Users/ahmed/Desktop/odoc/node_modules/vite/node_modules/esbuild/lib/main.js:1472:15)
+    at /Users/ahmed/Desktop/odoc/node_modules/vite/node_modules/esbuild/lib/main.js:755:50
+    at responseCallbacks.<computed> (/Users/ahmed/Desktop/odoc/node_modules/vite/node_modules/esbuild/lib/main.js:622:9)
+    at handleIncomingPacket (/Users/ahmed/Desktop/odoc/node_modules/vite/node_modules/esbuild/lib/main.js:677:12)
+    at Socket.readFromStdout (/Users/ahmed/Desktop/odoc/node_modules/vite/node_modules/esbuild/lib/main.js:600:7)
+    at Socket.emit (node:events:520:28)
+    at addChunk (node:internal/streams/readable:559:12)
+    at readableAddChunkPushByteMode (node:internal/streams/readable:510:3)
+    at Readable.push (node:internal/streams/readable:390:5)
+    at Pipe.onStreamRead (node:internal/stream_base_commons:191:23
+Click outside, press Esc key, or fix the code to dismiss.
+You can also disable this overlay by setting server.hmr.overlay to false in vite.config.ts.

# 2024-12-22 16:27:52.290884
+y

# 2024-12-22 16:35:29.101775
+i have this import React, { useState } from "react";
+import {
+  Box,
+  Button,
+  Card,
+  CardContent,
+  CardHeader,
+  IconButton,
+  Paper,
+  TextField,
+  Typography,
+} from "@mui/material";
+import {
+  Comment as MessageCircleIcon,
+  Favorite as HeartIcon,
+  Reply as ReplyIcon,
+  Send as SendIcon,
+  Share as ShareIcon,
+  ThumbDown as ThumbsDownIcon,
+} from "@mui/icons-material";
+import SearchIcon from "@mui/icons-material/Search";
+import UserAvatarMenu from "../../components/MainComponents/UserAvatarMenu";
+
+const Comment = ({ comment, onReply, level = 0 }) => {
+  const [showReplyInput, setShowReplyInput] = useState(false);
+  const [replyContent, setReplyContent] = useState("");
+
+  const handleReplySubmit = () => {
+    if (!replyContent.trim()) return;
+    onReply(comment.id, replyContent);
+    setReplyContent("");
+    setShowReplyInput(false);
+  };
+
+  return (
+    <Box sx={{ ml: level * 3, mb: 2 }}>
+      <Paper variant="outlined" sx={{ p: 2 }}>
+        <Box sx={{ display: "flex", gap: 1, mb: 1 }}>
+          <UserAvatarMenu user={comment.user} size="small" />
+          <Box>
+            <Typography variant="subtitle2">{comment.user.name}</Typography>
+            <Typography variant="caption" color="text.secondary">
+              {comment.timestamp}
+            </Typography>
+          </Box>
+        </Box>
+        <Typography variant="body2" sx={{ mb: 1 }}>
+          {comment.content}
+        </Typography>
+        <Button
+          size="small"
+          startIcon={<ReplyIcon />}
+          onClick={() => setShowReplyInput(!showReplyInput)}
+        >
+          Reply
+        </Button>
+      </Paper>
+
+      {showReplyInput && (
+        <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
+          <TextField
+            size="small"
+            fullWidth
+            placeholder="Write a reply..."
+            value={replyContent}
+            onChange={(e) => setReplyContent(e.target.value)}
+          />
+          <IconButton onClick={handleReplySubmit} color="primary">
+            <SendIcon />
+          </IconButton>
+        </Box>
+      )}
+
+      {comment.replies?.map((reply) => (
+        <Comment
+          key={reply.id}
+          comment={reply}
+          onReply={onReply}
+          level={level + 1}
+        />
+      ))}
+    </Box>
+  );
+};
+
+const SearchField = ({ searchQuery, setSearchQuery }) => {
+  return (
+    <Card sx={{ mb: 3 }}>
+      <CardContent>
+        <TextField
+          fullWidth
+          placeholder="Search posts by content or user..."
+          value={searchQuery}
+          onChange={(e) => setSearchQuery(e.target.value)}
+          InputProps={{
+            startAdornment: (
+              <Box sx={{ color: "text.secondary", mr: 1 }}>
+                <SearchIcon />
+              </Box>
+            ),
+          }}
+        />
+      </CardContent>
+    </Card>
+  );
+};
+
+const SocialPosts = () => {
+  const currentUser = {
+    id: 1,
+    name: "John Doe",
+    username: "johndoe",
+    avatarUrl: null,
+  };
+
+  const [posts, setPosts] = useState([
+    {
+      id: 1,
+      content: "This is my first post!",
+      likes: 0,
+      dislikes: 0,
+      comments: [],
+      isLiked: false,
+      isDisliked: false,
+      user: {
+        id: 2,
+        name: "Jane Smith",
+        username: "janesmith",
+        avatarUrl: null,
+      },
+    },
+  ]);
+
+  const [newPostContent, setNewPostContent] = useState("");
+  const [commentInputs, setCommentInputs] = useState({});
+  const [showComments, setShowComments] = useState({});
+
+  const handleNewPost = () => {
+    if (!newPostContent.trim()) return;
+
+    setPosts([
+      {
+        id: Date.now(),
+        content: newPostContent,
+        likes: 0,
+        dislikes: 0,
+        comments: [],
+        isLiked: false,
+        isDisliked: false,
+        user: currentUser,
+      },
+      ...posts,
+    ]);
+    setNewPostContent("");
+  };
+
+  const [searchQuery, setSearchQuery] = useState("");
+
+  // Add this function after other handler functions
+  const filteredPosts = posts.filter(
+    (post) =>
+      post.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
+      post.user.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
+      post.user.username.toLowerCase().includes(searchQuery.toLowerCase()),
+  );
+
+  const handleLike = (postId) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          if (post.isLiked) {
+            return { ...post, likes: post.likes - 1, isLiked: false };
+          } else {
+            if (post.isDisliked) {
+              return {
+                ...post,
+                likes: post.likes + 1,
+                dislikes: post.dislikes - 1,
+                isLiked: true,
+                isDisliked: false,
+              };
+            }
+            return { ...post, likes: post.likes + 1, isLiked: true };
+          }
+        }
+        return post;
+      }),
+    );
+  };
+
+  const handleDislike = (postId) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          if (post.isDisliked) {
+            return { ...post, dislikes: post.dislikes - 1, isDisliked: false };
+          } else {
+            if (post.isLiked) {
+              return {
+                ...post,
+                likes: post.likes - 1,
+                dislikes: post.dislikes + 1,
+                isLiked: false,
+                isDisliked: true,
+              };
+            }
+            return { ...post, dislikes: post.dislikes + 1, isDisliked: true };
+          }
+        }
+        return post;
+      }),
+    );
+  };
+
+  const handleShare = (postId) => {
+    alert("Share functionality would go here!");
+  };
+
+  const toggleComments = (postId) => {
+    setShowComments((prev) => ({
+      ...prev,
+      [postId]: !prev[postId],
+    }));
+  };
+
+  const handleComment = (postId) => {
+    if (!commentInputs[postId]?.trim()) return;
+
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          return {
+            ...post,
+            comments: [
+              ...post.comments,
+              {
+                id: Date.now(),
+                content: commentInputs[postId],
+                timestamp: new Date().toLocaleString(),
+                replies: [],
+                user: currentUser,
+              },
+            ],
+          };
+        }
+        return post;
+      }),
+    );
+
+    setCommentInputs((prev) => ({
+      ...prev,
+      [postId]: "",
+    }));
+  };
+
+  const handleReply = (postId, commentId, replyContent) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          const updatedComments = addReplyToComment(post.comments, commentId, {
+            id: Date.now(),
+            content: replyContent,
+            timestamp: new Date().toLocaleString(),
+            replies: [],
+            user: currentUser,
+          });
+          return { ...post, comments: updatedComments };
+        }
+        return post;
+      }),
+    );
+  };
+
+  const addReplyToComment = (comments, commentId, reply) => {
+    return comments.map((comment) => {
+      if (comment.id === commentId) {
+        return {
+          ...comment,
+          replies: [...(comment.replies || []), reply],
+        };
+      }
+      if (comment.replies?.length) {
+        return {
+          ...comment,
+          replies: addReplyToComment(comment.replies, commentId, reply),
+        };
+      }
+      return comment;
+    });
+  };
+
+  return (
+    <Box sx={{ maxWidth: 800, mx: "auto", p: 2 }}>
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Box sx={{ display: "flex", gap: 2, mb: 2 }}>
+            <UserAvatarMenu user={currentUser} />
+            <TextField
+              fullWidth
+              multiline
+              rows={2}
+              placeholder="What's on your mind?"
+              value={newPostContent}
+              onChange={(e) => setNewPostContent(e.target.value)}
+            />
+          </Box>
+          <Button variant="contained" fullWidth onClick={handleNewPost}>
+            Post
+          </Button>
+        </CardContent>
+      </Card>
+
+      <SearchField searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
+
+      {filteredPosts.map((post) => (
+        <Card key={post.id} sx={{ mb: 2 }}>
+          <CardHeader
+            avatar={<UserAvatarMenu user={post.user} />}
+            title={post.user.name}
+            subheader={`@${post.user.username}`}
+          />
+          <CardContent>
+            <Typography variant="body1">{post.content}</Typography>
+
+            <Box
+              sx={{ display: "flex", justifyContent: "space-between", mt: 2 }}
+            >
+              <Box sx={{ display: "flex", gap: 1 }}>
+                <Button
+                  startIcon={<HeartIcon />}
+                  onClick={() => handleLike(post.id)}
+                  color={post.isLiked ? "primary" : "inherit"}
+                >
+                  {post.likes}
+                </Button>
+                <Button
+                  startIcon={<ThumbsDownIcon />}
+                  onClick={() => handleDislike(post.id)}
+                  color={post.isDisliked ? "error" : "inherit"}
+                >
+                  {post.dislikes}
+                </Button>
+                <Button
+                  startIcon={<MessageCircleIcon />}
+                  onClick={() => toggleComments(post.id)}
+                >
+                  {post.comments.length}
+                </Button>
+              </Box>
+              <IconButton onClick={() => handleShare(post.id)}>
+                <ShareIcon />
+              </IconButton>
+            </Box>
+
+            {showComments[post.id] && (
+              <Box sx={{ mt: 2 }}>
+                <Box sx={{ display: "flex", gap: 1, mb: 2 }}>
+                  <TextField
+                    size="small"
+                    fullWidth
+                    placeholder="Write a comment..."
+                    value={commentInputs[post.id] || ""}
+                    onChange={(e) =>
+                      setCommentInputs((prev) => ({
+                        ...prev,
+                        [post.id]: e.target.value,
+                      }))
+                    }
+                  />
+                  <IconButton
+                    onClick={() => handleComment(post.id)}
+                    color="primary"
+                  >
+                    <SendIcon />
+                  </IconButton>
+                </Box>
+
+                <Box sx={{ mt: 2 }}>
+                  {post.comments.map((comment) => (
+                    <Comment
+                      key={comment.id}
+                      comment={comment}
+                      onReply={(commentId, content) =>
+                        handleReply(post.id, commentId, content)
+                      }
+                    />
+                  ))}
+                </Box>
+              </Box>
+            )}
+          </CardContent>
+        </Card>
+      ))}
+    </Box>
+  );
+};
+
+export default SocialPosts;
+ at the file ./src/frontend/pages/Discover/discover.tsx instead of using dummy posts use real posts that come from backendActor?.search_posts(

# 2024-12-22 16:35:41.189563
+ok

# 2024-12-22 16:36:15.727599
+y

# 2024-12-22 16:41:20.659658
+note export interface Post {
+  'id' : string,
+  'creator' : string,
+  'date_created' : bigint,
+  'votes_up' : Array<Principal>,
+  'tags' : Array<string>,
+  'content_tree' : Array<ContentNode>,
+  'votes_down' : Array<Principal>,
+}

# 2024-12-22 16:42:06.161660
+field data -> Invalid opt variant {Comment:text; Image:vec nat64; Table:record {rows:vec record {id:text; contract:opt variant {SharesContract:text}; cells:opt vec record {text; text}}; columns:vec record {id:text; _type:text; field:text; filters:vec record {name:text; operations:vec variant {Equal; Contains; Bigger; BiggerOrEqual}; formula:opt text}; permissions:vec variant {Edit:principal; View:principal; AnyOneView; AnyOneEdite}; dataValidator:opt text; editable:bool; formula:opt record {column_id:text; execute:variant {TransferNft; TransferToken; TransferUsdt:record {id:text; status:variant {None; RequestCancellation; Released; Objected:text; Confirmed; ConfirmedCancellation; ApproveHighPromise; HighPromise}; date_created:float64; date_released:float64; cells:vec record {id:text; field:text; value:text}; contract_id:text; sender:principal; amount:float64; receiver:principal}}}}}} argument: null
+

# 2024-12-22 16:58:05.768728
+import React, { useState, useEffect } from "react";
+import { Principal } from "@dfinity/principal";
+import {
+  Box,
+  Button,
+  Card,
+  CardContent,
+  CardHeader,
+  IconButton,
+  Paper,
+  TextField,
+  Typography,
+} from "@mui/material";
+import {
+  Comment as MessageCircleIcon,
+  Favorite as HeartIcon,
+  Reply as ReplyIcon,
+  Send as SendIcon,
+  Share as ShareIcon,
+  ThumbDown as ThumbsDownIcon,
+} from "@mui/icons-material";
+import SearchIcon from "@mui/icons-material/Search";
+import UserAvatarMenu from "../../components/MainComponents/UserAvatarMenu";
+import { useBackendContext } from "../../contexts/BackendContext";
+import {
+  ContentNode,
+  Post,
+  PostUser,
+} from "../../../declarations/backend/backend.did";
+import { useSelector } from "react-redux";
+import { randomString } from "../../DataProcessing/dataSamples";
+import EditorComponent from "../../components/EditorComponent";
+
+const Comment = ({ comment, onReply, level = 0 }) => {
+  const [showReplyInput, setShowReplyInput] = useState(false);
+  const [replyContent, setReplyContent] = useState("");
+
+  const handleReplySubmit = () => {
+    if (!replyContent.trim()) return;
+    onReply(comment.id, replyContent);
+    setReplyContent("");
+    setShowReplyInput(false);
+  };
+
+  return (
+    <Box sx={{ ml: level * 3, mb: 2 }}>
+      <Paper variant="outlined" sx={{ p: 2 }}>
+        <Box sx={{ display: "flex", gap: 1, mb: 1 }}>
+          {comment.user && <UserAvatarMenu user={comment.user} size="small" />}
+          <Box>
+            <Typography variant="subtitle2">{comment.user.name}</Typography>
+            <Typography variant="caption" color="text.secondary">
+              {comment.timestamp}
+            </Typography>
+          </Box>
+        </Box>
+        <Typography variant="body2" sx={{ mb: 1 }}>
+          {comment.content}
+        </Typography>
+        <Button
+          size="small"
+          startIcon={<ReplyIcon />}
+          onClick={() => setShowReplyInput(!showReplyInput)}
+        >
+          Reply
+        </Button>
+      </Paper>
+
+      {showReplyInput && (
+        <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
+          <TextField
+            size="small"
+            fullWidth
+            placeholder="Write a reply..."
+            value={replyContent}
+            onChange={(e) => setReplyContent(e.target.value)}
+          />
+          <IconButton onClick={handleReplySubmit} color="primary">
+            <SendIcon />
+          </IconButton>
+        </Box>
+      )}
+
+      {comment.replies?.map((reply) => (
+        <Comment
+          key={reply.id}
+          comment={reply}
+          onReply={onReply}
+          level={level + 1}
+        />
+      ))}
+    </Box>
+  );
+};
+
+const SearchField = ({ searchQuery, setSearchQuery }) => {
+  return (
+    <Card sx={{ mb: 3 }}>
+      <CardContent>
+        <TextField
+          fullWidth
+          placeholder="Search posts by content or user..."
+          value={searchQuery}
+          onChange={(e) => setSearchQuery(e.target.value)}
+          InputProps={{
+            startAdornment: (
+              <Box sx={{ color: "text.secondary", mr: 1 }}>
+                <SearchIcon />
+              </Box>
+            ),
+          }}
+        />
+      </CardContent>
+    </Card>
+  );
+};
+
+const SocialPosts = () => {
+  const { backendActor } = useBackendContext();
+  const [posts, setPosts] = useState<Array<PostUser>>([]);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState<string | null>(null);
+  const { profile } = useSelector((state: any) => state.filesState);
+  const currentUser = profile;
+
+  useEffect(() => {
+    const fetchPosts = async () => {
+      try {
+        if (!backendActor) return;
+        const result = await backendActor.get_posts(BigInt(0), BigInt(20));
+        setPosts(result);
+        setError(null);
+      } catch (err) {
+        console.error("Failed to fetch posts:", err);
+        setError("Failed to load posts. Please try again later.");
+      } finally {
+        setLoading(false);
+      }
+    };
+
+    fetchPosts();
+  }, [backendActor]);
+
+  const [newPostContent, setNewPostContent] = useState<Array<ContentNode>>(null);
+  const [commentInputs, setCommentInputs] = useState({});
+  const [showComments, setShowComments] = useState({});
+
+  const handleNewPost = async () => {
+    // if (!newPostContent.trim() || !backendActor) return;
+
+    try {
+      // const content: ContentNode = {}
+      const newPost: Post = {
+        id: randomString(),
+        creator: profile.id,
+        date_created: BigInt(Date.now() * 1e6),
+        votes_up: [],
+        tags: [],
+        content_tree: newPostContent,
+        votes_down: [],
+      };
+      // const newPost: Post = {
+      //   id: randomString(),
+      //   creator: Principal.fromText("2vxsx-fae").toString(),
+      //   date_created: BigInt(Date.now()),
+      //   votes_up: [],
+      //   votes_down: [],
+      //   tags: [],
+      //   content_tree: newPostContent.split('\n').map(text => ({
+      //     id: crypto.randomUUID(),
+      //     _type: "paragraph",
+      //     value: text,
+      //     data: [],
+      //     text: text,
+      //     children: [],
+      //     language: "",
+      //     indent: BigInt(0),
+      //     listStart: BigInt(0),
+      //     parent: null,
+      //     listStyleType: "",
+      //   })),
+      // };
+
+      const result = await backendActor.save_post(newPost);
+      if ("Ok" in result) {
+        const updatedPosts = await backendActor.get_posts(
+          BigInt(0),
+          BigInt(20),
+        );
+        setPosts(updatedPosts);
+        setNewPostContent("");
+      } else {
+        console.error("Failed to create post:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error creating post:", err);
+    }
+  };
+
+  const [searchQuery, setSearchQuery] = useState("");
+
+  // Add this function after other handler functions
+  const filteredPosts = posts.filter((post) => {
+    const contentText = post.content_tree
+      .map((node) => node.text)
+      .join(" ")
+      .toLowerCase();
+    return (
+      contentText.includes(searchQuery.toLowerCase()) ||
+      (post.creator &&
+        post.creator.name.toLowerCase().includes(searchQuery.toLowerCase()))
+    );
+  });
+
+  const handleVoteUp = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_up(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote up:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting up:", err);
+    }
+  };
+
+  const handleVoteDown = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_down(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote down:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting down:", err);
+    }
+  };
+
+  const handleShare = (postId) => {
+    alert("Share functionality would go here!");
+  };
+
+  const toggleComments = (postId) => {
+    setShowComments((prev) => ({
+      ...prev,
+      [postId]: !prev[postId],
+    }));
+  };
+
+  const handleComment = (postId) => {
+    if (!commentInputs[postId]?.trim()) return;
+
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          return {
+            ...post,
+            comments: [
+              ...post.comments,
+              {
+                id: Date.now(),
+                content: commentInputs[postId],
+                timestamp: new Date().toLocaleString(),
+                replies: [],
+                user: currentUser,
+              },
+            ],
+          };
+        }
+        return post;
+      }),
+    );
+
+    setCommentInputs((prev) => ({
+      ...prev,
+      [postId]: "",
+    }));
+  };
+
+  const handleReply = (postId, commentId, replyContent) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          const updatedComments = addReplyToComment(post.comments, commentId, {
+            id: Date.now(),
+            content: replyContent,
+            timestamp: new Date().toLocaleString(),
+            replies: [],
+            user: currentUser,
+          });
+          return { ...post, comments: updatedComments };
+        }
+        return post;
+      }),
+    );
+  };
+
+  const addReplyToComment = (comments, commentId, reply) => {
+    return comments.map((comment) => {
+      if (comment.id === commentId) {
+        return {
+          ...comment,
+          replies: [...(comment.replies || []), reply],
+        };
+      }
+      if (comment.replies?.length) {
+        return {
+          ...comment,
+          replies: addReplyToComment(comment.replies, commentId, reply),
+        };
+      }
+      return comment;
+    });
+  };
+
+  return (
+    <Box sx={{ maxWidth: 800, mx: "auto", p: 2 }}>
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Box sx={{ display: "flex", gap: 2, mb: 2 }}>
+            {currentUser && <UserAvatarMenu user={currentUser} />}
+            <EditorComponent
+              // readOnly={!isAuthoer}
+              // id={current_file.id}
+              contentEditable={true}
+              onChange={setNewPostContent}
+              // editorKey={editorKey}
+              content={[]}
+            />
+            {/*<TextField*/}
+            {/*  fullWidth*/}
+            {/*  multiline*/}
+            {/*  rows={2}*/}
+            {/*  placeholder="What's on your mind?"*/}
+            {/*  value={newPostContent}*/}
+            {/*  onChange={(e) => setNewPostContent(e.target.value)}*/}
+            {/*/>*/}
+          </Box>
+          <Button variant="contained" fullWidth onClick={handleNewPost}>
+            Post
+          </Button>
+        </CardContent>
+      </Card>
+
+      <SearchField searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
+
+      {filteredPosts.map((post: PostUser) => (
+        <Card key={post.id} sx={{ mb: 2 }}>
+          <CardHeader
+            avatar={post.user && <UserAvatarMenu user={post.user} />}
+            title={post.user && post.user.name}
+            subheader={`@${post.user && post.user.name}`}
+          />
+          <CardContent>
+            <Typography variant="body1">
+              {post.content_tree.map((node) => node.text).join(" ")}
+            </Typography>
+
+            <Box
+              sx={{ display: "flex", justifyContent: "space-between", mt: 2 }}
+            >
+              <Box sx={{ display: "flex", gap: 1 }}>
+                <Button
+                  startIcon={<HeartIcon />}
+                  onClick={() => handleVoteUp(post.id)}
+                  color={
+                    post.votes_up.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "primary"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_up.length}
+                </Button>
+                <Button
+                  startIcon={<ThumbsDownIcon />}
+                  onClick={() => handleVoteDown(post.id)}
+                  color={
+                    post.votes_down.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "error"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_down.length}
+                </Button>
+                <Button
+                  startIcon={<MessageCircleIcon />}
+                  onClick={() => toggleComments(post.id)}
+                >
+                  {post.comments && post.comments.length}
+                </Button>
+              </Box>
+              <IconButton onClick={() => handleShare(post.id)}>
+                <ShareIcon />
+              </IconButton>
+            </Box>
+
+            {showComments[post.id] && (
+              <Box sx={{ mt: 2 }}>
+                <Box sx={{ display: "flex", gap: 1, mb: 2 }}>
+                  <TextField
+                    size="small"
+                    fullWidth
+                    placeholder="Write a comment..."
+                    value={commentInputs[post.id] || ""}
+                    onChange={(e) =>
+                      setCommentInputs((prev) => ({
+                        ...prev,
+                        [post.id]: e.target.value,
+                      }))
+                    }
+                  />
+                  <IconButton
+                    onClick={() => handleComment(post.id)}
+                    color="primary"
+                  >
+                    <SendIcon />
+                  </IconButton>
+                </Box>
+
+                <Box sx={{ mt: 2 }}>
+                  {post.comments &&
+                    post.comments.map((comment) => (
+                      <Comment
+                        key={comment.id}
+                        comment={comment}
+                        onReply={(commentId, content) =>
+                          handleReply(post.id, commentId, content)
+                        }
+                      />
+                    ))}
+                </Box>
+              </Box>
+            )}
+          </CardContent>
+        </Card>
+      ))}
+    </Box>
+  );
+};
+
+export default SocialPosts;
+ fix this 1. use <EditorComponent for post content 2. note the data look like this {  "filteredPosts": [    {      "id": "o0bduo",      "creator": {        "id": "omwxg-jy7vb-dyi54-xw2ih-rx2a3-yan33-dwkbw-bjjb5-h6gd2-e5eq4-nae",        "name": "a"      },      "date_created": "1734857075048701000",      "votes_up": [],      "tags": [],      "content_tree": [],      "votes_down": []    }  ]} render them acordencly 

# 2024-12-22 17:01:50.474239
+note {  "newPostContent": [    {      "children": [        {          "text": "test"        }      ],      "type": "p",      "id": "8d2q1"    }  ]} while export interface ContentNode {
+  'id' : string,
+  '_type' : string,
+  'value' : string,
+  'data' : [] | [ContentData],
+  'text' : string,
+  'children' : Array<string>,
+  'language' : string,
+  'indent' : bigint,
+  'listStart' : bigint,
+  'parent' : [] | [string],
+  'listStyleType' : string,
+} serlize the data acordengly import React, { useState, useEffect } from "react";
+import { Principal } from "@dfinity/principal";
+import {
+  Box,
+  Button,
+  Card,
+  CardContent,
+  CardHeader,
+  IconButton,
+  Paper,
+  TextField,
+  Typography,
+} from "@mui/material";
+import {
+  Comment as MessageCircleIcon,
+  Favorite as HeartIcon,
+  Reply as ReplyIcon,
+  Send as SendIcon,
+  Share as ShareIcon,
+  ThumbDown as ThumbsDownIcon,
+} from "@mui/icons-material";
+import SearchIcon from "@mui/icons-material/Search";
+import UserAvatarMenu from "../../components/MainComponents/UserAvatarMenu";
+import { useBackendContext } from "../../contexts/BackendContext";
+import {
+  ContentNode,
+  Post,
+  PostUser,
+} from "../../../declarations/backend/backend.did";
+import { useSelector } from "react-redux";
+import { randomString } from "../../DataProcessing/dataSamples";
+import EditorComponent from "../../components/EditorComponent";
+import { logger } from "../../DevUtils/logData";
+
+const Comment = ({ comment, onReply, level = 0 }) => {
+  const [showReplyInput, setShowReplyInput] = useState(false);
+  const [replyContent, setReplyContent] = useState("");
+
+  const handleReplySubmit = () => {
+    if (!replyContent.trim()) return;
+    onReply(comment.id, replyContent);
+    setReplyContent("");
+    setShowReplyInput(false);
+  };
+
+  return (
+    <Box sx={{ ml: level * 3, mb: 2 }}>
+      <Paper variant="outlined" sx={{ p: 2 }}>
+        <Box sx={{ display: "flex", gap: 1, mb: 1 }}>
+          {comment.user && <UserAvatarMenu user={comment.user} size="small" />}
+          <Box>
+            <Typography variant="subtitle2">{comment.user.name}</Typography>
+            <Typography variant="caption" color="text.secondary">
+              {comment.timestamp}
+            </Typography>
+          </Box>
+        </Box>
+        <Typography variant="body2" sx={{ mb: 1 }}>
+          {comment.content}
+        </Typography>
+        <Button
+          size="small"
+          startIcon={<ReplyIcon />}
+          onClick={() => setShowReplyInput(!showReplyInput)}
+        >
+          Reply
+        </Button>
+      </Paper>
+
+      {showReplyInput && (
+        <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
+          <TextField
+            size="small"
+            fullWidth
+            placeholder="Write a reply..."
+            value={replyContent}
+            onChange={(e) => setReplyContent(e.target.value)}
+          />
+          <IconButton onClick={handleReplySubmit} color="primary">
+            <SendIcon />
+          </IconButton>
+        </Box>
+      )}
+
+      {comment.replies?.map((reply) => (
+        <Comment
+          key={reply.id}
+          comment={reply}
+          onReply={onReply}
+          level={level + 1}
+        />
+      ))}
+    </Box>
+  );
+};
+
+const SearchField = ({ searchQuery, setSearchQuery }) => {
+  return (
+    <Card sx={{ mb: 3 }}>
+      <CardContent>
+        <TextField
+          fullWidth
+          placeholder="Search posts by content or user..."
+          value={searchQuery}
+          onChange={(e) => setSearchQuery(e.target.value)}
+          InputProps={{
+            startAdornment: (
+              <Box sx={{ color: "text.secondary", mr: 1 }}>
+                <SearchIcon />
+              </Box>
+            ),
+          }}
+        />
+      </CardContent>
+    </Card>
+  );
+};
+
+const SocialPosts = () => {
+  const { backendActor } = useBackendContext();
+  const [posts, setPosts] = useState<Array<PostUser>>([]);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState<string | null>(null);
+  const { profile } = useSelector((state: any) => state.filesState);
+  const currentUser = profile;
+
+  useEffect(() => {
+    const fetchPosts = async () => {
+      try {
+        if (!backendActor) return;
+        const result = await backendActor.get_posts(BigInt(0), BigInt(20));
+        setPosts(result);
+        setError(null);
+      } catch (err) {
+        console.error("Failed to fetch posts:", err);
+        setError("Failed to load posts. Please try again later.");
+      } finally {
+        setLoading(false);
+      }
+    };
+
+    fetchPosts();
+  }, [backendActor]);
+
+  const [newPostContent, setNewPostContent] =
+    useState<Array<ContentNode>>(null);
+  const [commentInputs, setCommentInputs] = useState({});
+  const [showComments, setShowComments] = useState({});
+  logger({ newPostContent });
+
+  const handleNewPost = async () => {
+    // if (!newPostContent.trim() || !backendActor) return;
+
+    try {
+      // const content: ContentNode = {}
+      const newPost: Post = {
+        id: randomString(),
+        creator: profile.id,
+        date_created: BigInt(Date.now() * 1e6),
+        votes_up: [],
+        tags: [],
+        content_tree: newPostContent,
+        votes_down: [],
+      };
+      // const newPost: Post = {
+      //   id: randomString(),
+      //   creator: Principal.fromText("2vxsx-fae").toString(),
+      //   date_created: BigInt(Date.now()),
+      //   votes_up: [],
+      //   votes_down: [],
+      //   tags: [],
+      //   content_tree: newPostContent.split('\n').map(text => ({
+      //     id: crypto.randomUUID(),
+      //     _type: "paragraph",
+      //     value: text,
+      //     data: [],
+      //     text: text,
+      //     children: [],
+      //     language: "",
+      //     indent: BigInt(0),
+      //     listStart: BigInt(0),
+      //     parent: null,
+      //     listStyleType: "",
+      //   })),
+      // };
+
+      const result = await backendActor.save_post(newPost);
+      if ("Ok" in result) {
+        const updatedPosts = await backendActor.get_posts(
+          BigInt(0),
+          BigInt(20),
+        );
+        setPosts(updatedPosts);
+        setNewPostContent("");
+      } else {
+        console.error("Failed to create post:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error creating post:", err);
+    }
+  };
+
+  const [searchQuery, setSearchQuery] = useState("");
+
+  // Add this function after other handler functions
+  const filteredPosts = posts.filter((post) => {
+    const contentText = post.content_tree
+      .map((node) => node.text)
+      .join(" ")
+      .toLowerCase();
+    return (
+      contentText.includes(searchQuery.toLowerCase()) ||
+      post.creator?.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
+      false
+    );
+  });
+  logger({ filteredPosts });
+
+  const handleVoteUp = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_up(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote up:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting up:", err);
+    }
+  };
+
+  const handleVoteDown = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_down(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote down:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting down:", err);
+    }
+  };
+
+  const handleShare = (postId) => {
+    alert("Share functionality would go here!");
+  };
+
+  const toggleComments = (postId) => {
+    setShowComments((prev) => ({
+      ...prev,
+      [postId]: !prev[postId],
+    }));
+  };
+
+  const handleComment = (postId) => {
+    if (!commentInputs[postId]?.trim()) return;
+
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          return {
+            ...post,
+            comments: [
+              ...post.comments,
+              {
+                id: Date.now(),
+                content: commentInputs[postId],
+                timestamp: new Date().toLocaleString(),
+                replies: [],
+                user: currentUser,
+              },
+            ],
+          };
+        }
+        return post;
+      }),
+    );
+
+    setCommentInputs((prev) => ({
+      ...prev,
+      [postId]: "",
+    }));
+  };
+
+  const handleReply = (postId, commentId, replyContent) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          const updatedComments = addReplyToComment(post.comments, commentId, {
+            id: Date.now(),
+            content: replyContent,
+            timestamp: new Date().toLocaleString(),
+            replies: [],
+            user: currentUser,
+          });
+          return { ...post, comments: updatedComments };
+        }
+        return post;
+      }),
+    );
+  };
+
+  const addReplyToComment = (comments, commentId, reply) => {
+    return comments.map((comment) => {
+      if (comment.id === commentId) {
+        return {
+          ...comment,
+          replies: [...(comment.replies || []), reply],
+        };
+      }
+      if (comment.replies?.length) {
+        return {
+          ...comment,
+          replies: addReplyToComment(comment.replies, commentId, reply),
+        };
+      }
+      return comment;
+    });
+  };
+
+  return (
+    <Box sx={{ maxWidth: 800, mx: "auto", p: 2 }}>
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mb: 2 }}>
+            <Box>
+              <EditorComponent
+                contentEditable={true}
+                onChange={setNewPostContent}
+                content={[]}
+              />
+            </Box>
+          </Box>
+          <Button variant="contained" fullWidth onClick={handleNewPost}>
+            Post
+          </Button>
+        </CardContent>
+      </Card>
+
+      <SearchField searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
+
+      {filteredPosts.map((post: PostUser) => (
+        <Card key={post.id} sx={{ mb: 2 }}>
+          <CardHeader
+            avatar={post.creator && <UserAvatarMenu user={post.creator} />}
+            title={post.creator && post.creator.name}
+            subheader={new Date(
+              Number(post.date_created) / 1e6,
+            ).toLocaleString()}
+          />
+          <CardContent>
+            {post.content_tree && post.content_tree.length > 0 ? (
+              <EditorComponent
+                contentEditable={false}
+                content={post.content_tree}
+                onChange={() => {}}
+              />
+            ) : (
+              <Typography variant="body2" color="text.secondary">
+                No content
+              </Typography>
+            )}
+
+            <Box
+              sx={{ display: "flex", justifyContent: "space-between", mt: 2 }}
+            >
+              <Box sx={{ display: "flex", gap: 1 }}>
+                <Button
+                  startIcon={<HeartIcon />}
+                  onClick={() => handleVoteUp(post.id)}
+                  color={
+                    post.votes_up.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "primary"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_up.length}
+                </Button>
+                <Button
+                  startIcon={<ThumbsDownIcon />}
+                  onClick={() => handleVoteDown(post.id)}
+                  color={
+                    post.votes_down.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "error"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_down.length}
+                </Button>
+                <Button
+                  startIcon={<MessageCircleIcon />}
+                  onClick={() => toggleComments(post.id)}
+                >
+                  {post.comments && post.comments.length}
+                </Button>
+              </Box>
+              <IconButton onClick={() => handleShare(post.id)}>
+                <ShareIcon />
+              </IconButton>
+            </Box>
+
+            {showComments[post.id] && (
+              <Box sx={{ mt: 2 }}>
+                <Box sx={{ display: "flex", gap: 1, mb: 2 }}>
+                  <TextField
+                    size="small"
+                    fullWidth
+                    placeholder="Write a comment..."
+                    value={commentInputs[post.id] || ""}
+                    onChange={(e) =>
+                      setCommentInputs((prev) => ({
+                        ...prev,
+                        [post.id]: e.target.value,
+                      }))
+                    }
+                  />
+                  <IconButton
+                    onClick={() => handleComment(post.id)}
+                    color="primary"
+                  >
+                    <SendIcon />
+                  </IconButton>
+                </Box>
+
+                <Box sx={{ mt: 2 }}>
+                  {post.comments &&
+                    post.comments.map((comment) => (
+                      <Comment
+                        key={comment.id}
+                        comment={comment}
+                        onReply={(commentId, content) =>
+                          handleReply(post.id, commentId, content)
+                        }
+                      />
+                    ))}
+                </Box>
+              </Box>
+            )}
+          </CardContent>
+        </Card>
+      ))}
+    </Box>
+  );
+};
+
+export default SocialPosts;
+

# 2024-12-22 17:17:55.500522
+serilize and deserilize should be done like this import { Divider, Grid, Typography } from "@mui/material";
+import React from "react";
+import IconButton from "@mui/material/IconButton";
+import AddCircleOutlineIcon from "@mui/icons-material/AddCircleOutline";
+import MoreTimeIcon from "@mui/icons-material/MoreTime";
+import { ContentNode, Post } from "../../../declarations/backend/backend.did";
+import { randomId } from "@mui/x-data-grid-generator";
+import { useSelector } from "react-redux";
+import { useSnackbar } from "notistack";
+import { LoadingButton } from "@mui/lab";
+import PostComponent from "../../components/MuiComponents/PostComponent";
+import { useBackendContext } from "../../contexts/BackendContext";
+import PostTags from "./TagsComponent";
+import serializeFileContents from "../../DataProcessing/serialize/serializeFileContents";
+
+function CreatePost(props: any) {
+  let post_id = randomId();
+  const { profile } = useSelector((state: any) => state.filesState);
+  const [post, setPost] = React.useState<Post>({
+    id: post_id,
+    creator: profile ? profile.id : "",
+    date_created: BigInt(0),
+    votes_up: [],
+    tags: [],
+    content_tree: [],
+    votes_down: [],
+  });
+
+  const { enqueueSnackbar, closeSnackbar } = useSnackbar();
+  let [isEnter, setEnter] = React.useState(false);
+  let [loading, setLoad] = React.useState(false);
+  let [changes, setChanges] = React.useState<any>(null);
+  const { backendActor } = useBackendContext();
+  const handleCreatePost = async () => {
+    let de_changes: Array<Array<[string, Array<[string, ContentNode]>]>> =
+      serializeFileContents(changes);
+    let content_tree: Array<[string, ContentNode]> = de_changes[0][0][1];
+    let new_post = {
+      ...post,
+      creator: post.creator,
+      content_tree: content_tree,
+    };
+    setLoad(true);
+    let res = await backendActor?.save_post(new_post);
+    setLoad(false);
+    if ("Ok" in res) {
+      props.setPosts((pre) => {
+        new_post.creator = { name: profile.name, id: profile.id };
+        if (pre.length > 0) {
+          return [new_post, ...pre];
+        }
+        return [new_post];
+      });
+      enqueueSnackbar("Post created", { variant: "success" });
+      setChanges(null);
+    } else {
+      enqueueSnackbar("Error creating post. " + res.Err, { variant: "error" });
+    }
+  };
+  let CreateButtons = (props: any) => (
+    <>
+      <LoadingButton
+        // disabled={loading}
+        loading={loading}
+        onClick={handleCreatePost}
+      >
+        <AddCircleOutlineIcon />
+      </LoadingButton>
+      {/*<IconButton>*/}
+      {/*  <MoreTimeIcon />*/}
+      {/*</IconButton>*/}
+      <PostTags
+        label={"Tags"}
+        post={post}
+        setTags={(updatedTags) => {
+          setPost((prevPost) => ({
+            ...prevPost,
+            tags: updatedTags.map((tag) => tag.title),
+          }));
+        }}
+      />
+    </>
+  );
+
+  function onChange(changes: any) {
+    let new_change = {};
+    new_change[""] = changes;
+    setChanges(new_change);
+  }
+
+  return (
+    <Grid
+      onMouseEnter={() => setEnter(true)}
+      onMouseLeave={() => setEnter(false)}
+      item
+      sx={{
+        my: 1,
+        mx: "auto",
+        p: 2,
+        // marginLeft: '20%',
+        // marginRight: '20%',
+        // marginBottom: '20%',
+        opacity: isEnter ? 1 : 0.2,
+        // height: '10%', // adjust the value accordingly
+      }}
+    >
+      <PostComponent
+        is_owner={true}
+        noHeaders={true}
+        key={changes} // Use the key to force a re-render
+        buttons={<CreateButtons />}
+        post={post}
+        onChange={onChange}
+      />
+      <Divider />
+    </Grid>
+  );
+}
+
+export default CreatePost;
+import React, { useState, useEffect } from "react";
+import { Principal } from "@dfinity/principal";
+import {
+  Box,
+  Button,
+  Card,
+  CardContent,
+  CardHeader,
+  IconButton,
+  Paper,
+  TextField,
+  Typography,
+} from "@mui/material";
+import {
+  Comment as MessageCircleIcon,
+  Favorite as HeartIcon,
+  Reply as ReplyIcon,
+  Send as SendIcon,
+  Share as ShareIcon,
+  ThumbDown as ThumbsDownIcon,
+} from "@mui/icons-material";
+import SearchIcon from "@mui/icons-material/Search";
+import UserAvatarMenu from "../../components/MainComponents/UserAvatarMenu";
+import { useBackendContext } from "../../contexts/BackendContext";
+import {
+  ContentNode,
+  Post,
+  PostUser,
+} from "../../../declarations/backend/backend.did";
+import { useSelector } from "react-redux";
+import { randomString } from "../../DataProcessing/dataSamples";
+import EditorComponent from "../../components/EditorComponent";
+import { logger } from "../../DevUtils/logData";
+import { deserializeContentTree } from "../../DataProcessing/deserlize/deserializeContents";
+import serializeFileContents from "../../DataProcessing/serialize/serializeFileContents";
+
+const Comment = ({ comment, onReply, level = 0 }) => {
+  const [showReplyInput, setShowReplyInput] = useState(false);
+  const [replyContent, setReplyContent] = useState("");
+
+  const handleReplySubmit = () => {
+    if (!replyContent.trim()) return;
+    onReply(comment.id, replyContent);
+    setReplyContent("");
+    setShowReplyInput(false);
+  };
+
+  return (
+    <Box sx={{ ml: level * 3, mb: 2 }}>
+      <Paper variant="outlined" sx={{ p: 2 }}>
+        <Box sx={{ display: "flex", gap: 1, mb: 1 }}>
+          {comment.user && <UserAvatarMenu user={comment.user} size="small" />}
+          <Box>
+            <Typography variant="subtitle2">{comment.user.name}</Typography>
+            <Typography variant="caption" color="text.secondary">
+              {comment.timestamp}
+            </Typography>
+          </Box>
+        </Box>
+        <Typography variant="body2" sx={{ mb: 1 }}>
+          {comment.content}
+        </Typography>
+        <Button
+          size="small"
+          startIcon={<ReplyIcon />}
+          onClick={() => setShowReplyInput(!showReplyInput)}
+        >
+          Reply
+        </Button>
+      </Paper>
+
+      {showReplyInput && (
+        <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
+          <TextField
+            size="small"
+            fullWidth
+            placeholder="Write a reply..."
+            value={replyContent}
+            onChange={(e) => setReplyContent(e.target.value)}
+          />
+          <IconButton onClick={handleReplySubmit} color="primary">
+            <SendIcon />
+          </IconButton>
+        </Box>
+      )}
+
+      {comment.replies?.map((reply) => (
+        <Comment
+          key={reply.id}
+          comment={reply}
+          onReply={onReply}
+          level={level + 1}
+        />
+      ))}
+    </Box>
+  );
+};
+
+const SearchField = ({ searchQuery, setSearchQuery }) => {
+  return (
+    <Card sx={{ mb: 3 }}>
+      <CardContent>
+        <TextField
+          fullWidth
+          placeholder="Search posts by content or user..."
+          value={searchQuery}
+          onChange={(e) => setSearchQuery(e.target.value)}
+          InputProps={{
+            startAdornment: (
+              <Box sx={{ color: "text.secondary", mr: 1 }}>
+                <SearchIcon />
+              </Box>
+            ),
+          }}
+        />
+      </CardContent>
+    </Card>
+  );
+};
+
+const SocialPosts = () => {
+  const { backendActor } = useBackendContext();
+  const [posts, setPosts] = useState<Array<PostUser>>([]);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState<string | null>(null);
+  const { profile } = useSelector((state: any) => state.filesState);
+  const currentUser = profile;
+
+  useEffect(() => {
+    const fetchPosts = async () => {
+      try {
+        if (!backendActor) return;
+        const result = await backendActor.get_posts(BigInt(0), BigInt(20));
+        setPosts(result);
+        setError(null);
+      } catch (err) {
+        console.error("Failed to fetch posts:", err);
+        setError("Failed to load posts. Please try again later.");
+      } finally {
+        setLoading(false);
+      }
+    };
+
+    fetchPosts();
+  }, [backendActor]);
+
+  const [newPostContent, setNewPostContent] =
+    useState<Array<ContentNode>>(null);
+  const [commentInputs, setCommentInputs] = useState({});
+  const [showComments, setShowComments] = useState({});
+  // logger({ newPostContent });
+
+  const handleNewPost = async () => {
+    if (!newPostContent || !backendActor) return;
+
+    try {
+      // Transform editor content into ContentNode format
+      // const contentNodes: Array<ContentNode> = newPostContent.map((node) => ({
+      //   id: node.id || randomString(),
+      //   _type: node.type || "paragraph",
+      //   value: node.children?.[0]?.text || "",
+      //   data: [],
+      //   text: node.children?.[0]?.text || "",
+      //   children: [],
+      //   language: "",
+      //   indent: BigInt(0),
+      //   listStart: BigInt(0),
+      //   parent: [],
+      //   listStyleType: "",
+      // }));
+      let de_changes: Array<Array<[string, Array<[string, ContentNode]>]>> =
+        serializeFileContents(newPostContent);
+      let content_tree: Array<[string, ContentNode]> = de_changes[0][0][1];
+      const newPost: Post = {
+        id: randomString(),
+        creator: profile.id,
+        date_created: BigInt(Date.now() * 1e6),
+        votes_up: [],
+        tags: [],
+        content_tree,
+        votes_down: [],
+      };
+      // const newPost: Post = {
+      //   id: randomString(),
+      //   creator: Principal.fromText("2vxsx-fae").toString(),
+      //   date_created: BigInt(Date.now()),
+      //   votes_up: [],
+      //   votes_down: [],
+      //   tags: [],
+      //   content_tree: newPostContent.split('\n').map(text => ({
+      //     id: crypto.randomUUID(),
+      //     _type: "paragraph",
+      //     value: text,
+      //     data: [],
+      //     text: text,
+      //     children: [],
+      //     language: "",
+      //     indent: BigInt(0),
+      //     listStart: BigInt(0),
+      //     parent: null,
+      //     listStyleType: "",
+      //   })),
+      // };
+      console.log({ newPost });
+      const result = await backendActor.save_post(newPost);
+      if ("Ok" in result) {
+        const updatedPosts = await backendActor.get_posts(
+          BigInt(0),
+          BigInt(20),
+        );
+        setPosts(updatedPosts);
+        setNewPostContent("");
+      } else {
+        console.error("Failed to create post:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error creating post:", err);
+    }
+  };
+
+  const [searchQuery, setSearchQuery] = useState("");
+
+  // Add this function after other handler functions
+  const filteredPosts = posts.filter((post) => {
+    const contentText = post.content_tree
+      .map((node) => node.text)
+      .join(" ")
+      .toLowerCase();
+    return (
+      contentText.includes(searchQuery.toLowerCase()) ||
+      post.creator?.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
+      false
+    );
+  });
+
+  const handleVoteUp = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_up(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote up:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting up:", err);
+    }
+  };
+
+  const handleVoteDown = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_down(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote down:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting down:", err);
+    }
+  };
+
+  const handleShare = (postId) => {
+    alert("Share functionality would go here!");
+  };
+
+  const toggleComments = (postId) => {
+    setShowComments((prev) => ({
+      ...prev,
+      [postId]: !prev[postId],
+    }));
+  };
+
+  const handleComment = (postId) => {
+    if (!commentInputs[postId]?.trim()) return;
+
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          return {
+            ...post,
+            comments: [
+              ...post.comments,
+              {
+                id: Date.now(),
+                content: commentInputs[postId],
+                timestamp: new Date().toLocaleString(),
+                replies: [],
+                user: currentUser,
+              },
+            ],
+          };
+        }
+        return post;
+      }),
+    );
+
+    setCommentInputs((prev) => ({
+      ...prev,
+      [postId]: "",
+    }));
+  };
+
+  const handleReply = (postId, commentId, replyContent) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          const updatedComments = addReplyToComment(post.comments, commentId, {
+            id: Date.now(),
+            content: replyContent,
+            timestamp: new Date().toLocaleString(),
+            replies: [],
+            user: currentUser,
+          });
+          return { ...post, comments: updatedComments };
+        }
+        return post;
+      }),
+    );
+  };
+
+  const addReplyToComment = (comments, commentId, reply) => {
+    return comments.map((comment) => {
+      if (comment.id === commentId) {
+        return {
+          ...comment,
+          replies: [...(comment.replies || []), reply],
+        };
+      }
+      if (comment.replies?.length) {
+        return {
+          ...comment,
+          replies: addReplyToComment(comment.replies, commentId, reply),
+        };
+      }
+      return comment;
+    });
+  };
+
+  return (
+    <Box sx={{ maxWidth: 800, mx: "auto", p: 2 }}>
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mb: 2 }}>
+            <Box>
+              <EditorComponent
+                contentEditable={true}
+                onChange={(changes) => {
+                  let new_change = {};
+                  new_change[""] = changes;
+                  setNewPostContent(new_change);
+                }}
+                content={[]}
+              />
+            </Box>
+          </Box>
+          <Button variant="contained" fullWidth onClick={handleNewPost}>
+            Post
+          </Button>
+        </CardContent>
+      </Card>
+
+      <SearchField searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
+
+      {filteredPosts.map((post: PostUser) => (
+        <Card key={post.id} sx={{ mb: 2 }}>
+          <CardHeader
+            avatar={post.creator && <UserAvatarMenu user={post.creator} />}
+            title={post.creator && post.creator.name}
+            subheader={new Date(
+              Number(post.date_created) / 1e6,
+            ).toLocaleString()}
+          />
+          <CardContent>
+            {post.content_tree && post.content_tree.length > 0 ? (
+              <EditorComponent
+                contentEditable={false}
+                content={deserializeContentTree(post.content_tree)}
+                onChange={() => {}}
+              />
+            ) : (
+              <Typography variant="body2" color="text.secondary">
+                No content
+              </Typography>
+            )}
+
+            <Box
+              sx={{ display: "flex", justifyContent: "space-between", mt: 2 }}
+            >
+              <Box sx={{ display: "flex", gap: 1 }}>
+                <Button
+                  startIcon={<HeartIcon />}
+                  onClick={() => handleVoteUp(post.id)}
+                  color={
+                    post.votes_up.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "primary"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_up.length}
+                </Button>
+                <Button
+                  startIcon={<ThumbsDownIcon />}
+                  onClick={() => handleVoteDown(post.id)}
+                  color={
+                    post.votes_down.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "error"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_down.length}
+                </Button>
+                <Button
+                  startIcon={<MessageCircleIcon />}
+                  onClick={() => toggleComments(post.id)}
+                >
+                  {post.comments && post.comments.length}
+                </Button>
+              </Box>
+              <IconButton onClick={() => handleShare(post.id)}>
+                <ShareIcon />
+              </IconButton>
+            </Box>
+
+            {showComments[post.id] && (
+              <Box sx={{ mt: 2 }}>
+                <Box sx={{ display: "flex", gap: 1, mb: 2 }}>
+                  <TextField
+                    size="small"
+                    fullWidth
+                    placeholder="Write a comment..."
+                    value={commentInputs[post.id] || ""}
+                    onChange={(e) =>
+                      setCommentInputs((prev) => ({
+                        ...prev,
+                        [post.id]: e.target.value,
+                      }))
+                    }
+                  />
+                  <IconButton
+                    onClick={() => handleComment(post.id)}
+                    color="primary"
+                  >
+                    <SendIcon />
+                  </IconButton>
+                </Box>
+
+                <Box sx={{ mt: 2 }}>
+                  {post.comments &&
+                    post.comments.map((comment) => (
+                      <Comment
+                        key={comment.id}
+                        comment={comment}
+                        onReply={(commentId, content) =>
+                          handleReply(post.id, commentId, content)
+                        }
+                      />
+                    ))}
+                </Box>
+              </Box>
+            )}
+          </CardContent>
+        </Card>
+      ))}
+    </Box>
+  );
+};
+
+export default SocialPosts;
+ fix discover.tsx discover

# 2024-12-22 17:18:59.653296
+ok apply the changs

# 2024-12-22 17:25:36.856124
+when user hit post button clear out the content tree to [] also show loadig progress while waiting for save_post, also revers the order of the posts make the laitest apear at the top, also enable delete posts and edite post if post.creator === profile.id

# 2024-12-22 17:28:32.571245
+when user hit delete ask them for conformation, then if yes show progrees loading while calling backendActor.delete

# 2024-12-22 17:30:09.007320
+do not show edite button instead when the content change <EditorComponent
+                contentEditable={false}
+                content={deserializeContentTree(post.content_tree)}
+                onChange={() => {}}
+              /> show a button named save and call save_post and show loading progress as well

# 2024-12-22 17:39:20.616796
+import React, { useState, useEffect } from "react";
+import { Principal } from "@dfinity/principal";
+import {
+  Box,
+  Button,
+  Card,
+  CardContent,
+  CardHeader,
+  IconButton,
+  Paper,
+  TextField,
+  Typography,
+} from "@mui/material";
+import {
+  Comment as MessageCircleIcon,
+  Favorite as HeartIcon,
+  Reply as ReplyIcon,
+  Send as SendIcon,
+  Share as ShareIcon,
+  ThumbDown as ThumbsDownIcon,
+} from "@mui/icons-material";
+import SearchIcon from "@mui/icons-material/Search";
+import UserAvatarMenu from "../../components/MainComponents/UserAvatarMenu";
+import { useBackendContext } from "../../contexts/BackendContext";
+import {
+  ContentNode,
+  Post,
+  PostUser,
+} from "../../../declarations/backend/backend.did";
+import { useSelector } from "react-redux";
+import { randomString } from "../../DataProcessing/dataSamples";
+import EditorComponent from "../../components/EditorComponent";
+import { logger } from "../../DevUtils/logData";
+import { deserializeContentTree } from "../../DataProcessing/deserlize/deserializeContents";
+import serializeFileContents from "../../DataProcessing/serialize/serializeFileContents";
+
+const Comment = ({ comment, onReply, level = 0 }) => {
+  const [showReplyInput, setShowReplyInput] = useState(false);
+  const [replyContent, setReplyContent] = useState("");
+
+  const handleReplySubmit = () => {
+    if (!replyContent.trim()) return;
+    onReply(comment.id, replyContent);
+    setReplyContent("");
+    setShowReplyInput(false);
+  };
+
+  return (
+    <Box sx={{ ml: level * 3, mb: 2 }}>
+      <Paper variant="outlined" sx={{ p: 2 }}>
+        <Box sx={{ display: "flex", gap: 1, mb: 1 }}>
+          {comment.user && <UserAvatarMenu user={comment.user} size="small" />}
+          <Box>
+            <Typography variant="subtitle2">{comment.user.name}</Typography>
+            <Typography variant="caption" color="text.secondary">
+              {comment.timestamp}
+            </Typography>
+          </Box>
+        </Box>
+        <Typography variant="body2" sx={{ mb: 1 }}>
+          {comment.content}
+        </Typography>
+        <Button
+          size="small"
+          startIcon={<ReplyIcon />}
+          onClick={() => setShowReplyInput(!showReplyInput)}
+        >
+          Reply
+        </Button>
+      </Paper>
+
+      {showReplyInput && (
+        <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
+          <TextField
+            size="small"
+            fullWidth
+            placeholder="Write a reply..."
+            value={replyContent}
+            onChange={(e) => setReplyContent(e.target.value)}
+          />
+          <IconButton onClick={handleReplySubmit} color="primary">
+            <SendIcon />
+          </IconButton>
+        </Box>
+      )}
+
+      {comment.replies?.map((reply) => (
+        <Comment
+          key={reply.id}
+          comment={reply}
+          onReply={onReply}
+          level={level + 1}
+        />
+      ))}
+    </Box>
+  );
+};
+
+const SearchField = ({ searchQuery, setSearchQuery }) => {
+  return (
+    <Card sx={{ mb: 3 }}>
+      <CardContent>
+        <TextField
+          fullWidth
+          placeholder="Search posts by content or user..."
+          value={searchQuery}
+          onChange={(e) => setSearchQuery(e.target.value)}
+          InputProps={{
+            startAdornment: (
+              <Box sx={{ color: "text.secondary", mr: 1 }}>
+                <SearchIcon />
+              </Box>
+            ),
+          }}
+        />
+      </CardContent>
+    </Card>
+  );
+};
+
+const SocialPosts = () => {
+  const { backendActor } = useBackendContext();
+  const [posts, setPosts] = useState<Array<PostUser>>([]);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState<string | null>(null);
+  const { profile } = useSelector((state: any) => state.filesState);
+  const currentUser = profile;
+
+  useEffect(() => {
+    const fetchPosts = async () => {
+      try {
+        if (!backendActor) return;
+        const result = await backendActor.get_posts(BigInt(0), BigInt(20));
+        setPosts(result.reverse());
+        setError(null);
+      } catch (err) {
+        console.error("Failed to fetch posts:", err);
+        setError("Failed to load posts. Please try again later.");
+      } finally {
+        setLoading(false);
+      }
+    };
+
+    fetchPosts();
+  }, [backendActor]);
+
+  const [newPostContent, setNewPostContent] = useState<any>(null);
+  const [commentInputs, setCommentInputs] = useState({});
+  const [showComments, setShowComments] = useState({});
+  const [isPosting, setIsPosting] = useState(false);
+  const [isSaving, setIsSaving] = useState(false);
+
+  const handleNewPost = async () => {
+    if (!newPostContent || !backendActor) return;
+    setIsPosting(true);
+
+    try {
+      let de_changes: Array<Array<[string, Array<[string, ContentNode]>]>> =
+        serializeFileContents(newPostContent);
+      let content_tree: Array<[string, ContentNode]> = de_changes[0][0][1];
+      console.log({ content_tree });
+      const newPost: Post = {
+        id: randomString(),
+        creator: profile.id,
+        date_created: BigInt(Date.now() * 1e6),
+        votes_up: [],
+        tags: [],
+        content_tree,
+        votes_down: [],
+      };
+      console.log({ newPost });
+      try {
+        const result = await backendActor.save_post(newPost);
+        if ("Ok" in result) {
+          const updatedPosts = await backendActor.get_posts(
+            BigInt(0),
+            BigInt(20),
+          );
+          setPosts(updatedPosts.reverse());
+          setNewPostContent(null);
+        } else {
+          console.error("Failed to create post:", result.Err);
+        }
+      } catch (err) {
+        console.error("Error save_post:", err);
+      }
+    } catch (err) {
+      console.error("Error creating post:", err);
+    } finally {
+      setIsPosting(false);
+    }
+  };
+
+  const [searchQuery, setSearchQuery] = useState("");
+
+  // Add this function after other handler functions
+  const filteredPosts = posts.filter((post) => {
+    const contentText = post.content_tree
+      .map((node) => node.text)
+      .join(" ")
+      .toLowerCase();
+    return (
+      contentText.includes(searchQuery.toLowerCase()) ||
+      post.creator?.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
+      false
+    );
+  });
+
+  const handleVoteUp = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_up(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote up:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting up:", err);
+    }
+  };
+
+  const handleVoteDown = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_down(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote down:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting down:", err);
+    }
+  };
+
+  const [isDeletingPost, setIsDeletingPost] = useState<string | null>(null);
+
+  const handleDeletePost = async (postId: string) => {
+    if (!backendActor) return;
+
+    const confirmed = window.confirm(
+      "Are you sure you want to delete this post?",
+    );
+    if (!confirmed) return;
+
+    setIsDeletingPost(postId);
+    try {
+      const result = await backendActor.delete_post(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.filter((post) => post.id !== postId);
+        setPosts(updatedPosts);
+      }
+    } catch (err) {
+      console.error("Error deleting post:", err);
+    } finally {
+      setIsDeletingPost(null);
+    }
+  };
+
+  const handleSavePost = async (post: PostUser) => {
+    if (!newPostContent || !backendActor) return;
+
+    setIsSaving(true);
+    try {
+      let de_changes: Array<Array<[string, Array<[string, ContentNode]>]>> =
+        serializeFileContents(newPostContent);
+      let content_tree: Array<[string, ContentNode]> = de_changes[0][0][1];
+
+      const updatedPost: Post = {
+        ...post,
+        creator: profile.id,
+        content_tree,
+      };
+
+      const result = await backendActor.save_post(updatedPost);
+      if ("Ok" in result) {
+        const updatedPosts = await backendActor.get_posts(
+          BigInt(0),
+          BigInt(20),
+        );
+        setPosts(updatedPosts.reverse());
+        setNewPostContent(null);
+      }
+    } catch (err) {
+      console.error("Error saving post:", err);
+    } finally {
+      setIsSaving(false);
+    }
+  };
+
+  const handleShare = (postId) => {
+    alert("Share functionality would go here!");
+  };
+
+  const toggleComments = (postId) => {
+    setShowComments((prev) => ({
+      ...prev,
+      [postId]: !prev[postId],
+    }));
+  };
+
+  const handleComment = (postId) => {
+    if (!commentInputs[postId]?.trim()) return;
+
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          return {
+            ...post,
+            comments: [
+              ...post.comments,
+              {
+                id: Date.now(),
+                content: commentInputs[postId],
+                timestamp: new Date().toLocaleString(),
+                replies: [],
+                user: currentUser,
+              },
+            ],
+          };
+        }
+        return post;
+      }),
+    );
+
+    setCommentInputs((prev) => ({
+      ...prev,
+      [postId]: "",
+    }));
+  };
+
+  const handleReply = (postId, commentId, replyContent) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          const updatedComments = addReplyToComment(post.comments, commentId, {
+            id: Date.now(),
+            content: replyContent,
+            timestamp: new Date().toLocaleString(),
+            replies: [],
+            user: currentUser,
+          });
+          return { ...post, comments: updatedComments };
+        }
+        return post;
+      }),
+    );
+  };
+
+  const addReplyToComment = (comments, commentId, reply) => {
+    return comments.map((comment) => {
+      if (comment.id === commentId) {
+        return {
+          ...comment,
+          replies: [...(comment.replies || []), reply],
+        };
+      }
+      if (comment.replies?.length) {
+        return {
+          ...comment,
+          replies: addReplyToComment(comment.replies, commentId, reply),
+        };
+      }
+      return comment;
+    });
+  };
+  console.log({ filteredPosts });
+
+  return (
+    <Box sx={{ maxWidth: 800, mx: "auto", p: 2 }}>
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mb: 2 }}>
+            <Box>
+              <EditorComponent
+                contentEditable={true}
+                onChange={(changes) => {
+                  let new_change = {};
+                  new_change[""] = changes;
+                  setNewPostContent(new_change);
+                }}
+                content={[]}
+              />
+            </Box>
+          </Box>
+          <Button
+            variant="contained"
+            fullWidth
+            onClick={handleNewPost}
+            disabled={isPosting}
+          >
+            {isPosting ? "Posting..." : "Post"}
+          </Button>
+        </CardContent>
+      </Card>
+
+      <SearchField searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
+
+      {filteredPosts.map((post: PostUser) => (
+        <Card key={post.id} sx={{ mb: 2 }}>
+          <CardHeader
+            avatar={post.creator && <UserAvatarMenu user={post.creator} />}
+            title={post.creator && post.creator.name}
+            subheader={new Date(
+              Number(post.date_created) / 1e6,
+            ).toLocaleString()}
+          />
+          <CardContent>
+            {post.content_tree && post.content_tree.length > 0 ? (
+              <EditorComponent
+                readOnly={
+                  post && post.creator?.id && post.creator.id !== profile?.id
+                }
+                content={deserializeContentTree(post.content_tree)}
+                onChange={(changes) => {
+                  let new_change = {};
+                  new_change[""] = changes;
+                  setNewPostContent(new_change);
+                }}
+              />
+            ) : (
+              <Typography variant="body2" color="text.secondary">
+                No content
+              </Typography>
+            )}
+
+            <Box
+              sx={{ display: "flex", justifyContent: "space-between", mt: 2 }}
+            >
+              <Box sx={{ display: "flex", gap: 1 }}>
+                {post.creator?.id === profile?.id && (
+                  <>
+                    <Button
+                      onClick={() => handleDeletePost(post.id)}
+                      color="error"
+                      size="small"
+                      disabled={isDeletingPost === post.id}
+                    >
+                      {isDeletingPost === post.id ? "Deleting..." : "Delete"}
+                    </Button>
+
+                    <Button
+                      onClick={() => handleSavePost(post)}
+                      color="primary"
+                      size="small"
+                      disabled={isSaving}
+                    >
+                      {isSaving ? "Saving..." : "Save"}
+                    </Button>
+
+                  </>
+                )}
+                <Button
+                  startIcon={<HeartIcon />}
+                  onClick={() => handleVoteUp(post.id)}
+                  color={
+                    post.votes_up.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "primary"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_up.length}
+                </Button>
+                <Button
+                  startIcon={<ThumbsDownIcon />}
+                  onClick={() => handleVoteDown(post.id)}
+                  color={
+                    post.votes_down.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "error"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_down.length}
+                </Button>
+                <Button
+                  startIcon={<MessageCircleIcon />}
+                  onClick={() => toggleComments(post.id)}
+                >
+                  {post.comments && post.comments.length}
+                </Button>
+              </Box>
+              <IconButton onClick={() => handleShare(post.id)}>
+                <ShareIcon />
+              </IconButton>
+            </Box>
+
+            {showComments[post.id] && (
+              <Box sx={{ mt: 2 }}>
+                <Box sx={{ display: "flex", gap: 1, mb: 2 }}>
+                  <TextField
+                    size="small"
+                    fullWidth
+                    placeholder="Write a comment..."
+                    value={commentInputs[post.id] || ""}
+                    onChange={(e) =>
+                      setCommentInputs((prev) => ({
+                        ...prev,
+                        [post.id]: e.target.value,
+                      }))
+                    }
+                  />
+                  <IconButton
+                    onClick={() => handleComment(post.id)}
+                    color="primary"
+                  >
+                    <SendIcon />
+                  </IconButton>
+                </Box>
+
+                <Box sx={{ mt: 2 }}>
+                  {post.comments &&
+                    post.comments.map((comment) => (
+                      <Comment
+                        key={comment.id}
+                        comment={comment}
+                        onReply={(commentId, content) =>
+                          handleReply(post.id, commentId, content)
+                        }
+                      />
+                    ))}
+                </Box>
+              </Box>
+            )}
+          </CardContent>
+        </Card>
+      ))}
+    </Box>
+  );
+};
+
+export default SocialPosts;
+enable users to add tags and edite tags and search by tags 

# 2024-12-22 17:41:27.289072
+1. during posting also enable adding a list of tags, 2. show the tags of a post

# 2024-12-22 17:42:18.750629
+[plugin:vite:esbuild] Transform failed with 2 errors:
+/Users/ahmed/Desktop/odoc/src/frontend/pages/Discover/discover.tsx:244:8: ERROR: The symbol "setTagInput" has already been declared
+/Users/ahmed/Desktop/odoc/src/frontend/pages/Discover/discover.tsx:244:8: ERROR: The symbol "tagInput" has already been declared
+/Users/ahmed/Desktop/odoc/src/frontend/pages/Discover/discover.tsx:244:8
+The symbol "setTagInput" has already been declared
+242|  
+243|    const [searchQuery, setSearchQuery] = useState("");
+244|    const [tagInput, setTagInput] = useState("");
+   |          ^

# 2024-12-22 17:43:53.558295
+I can't edite tags? I should be able to add new tags, and remove old tags

# 2024-12-22 17:45:49.532779
+there is a bug when I edite one a tag of one post all other posts render the same tag name, 

# 2024-12-22 17:46:27.710153
+Uncaught ReferenceError: tagInput is not defined
+    at SearchField (discover.tsx:135:20)
+    at renderWithHooks (chunk-WMDJOG6V.js?v=8d5024c3:11548:26)
+    at mountIndeterminateComponent (chunk-WMDJOG6V.js?v=8d5024c3:14926:21)
+    at beginWork (chunk-WMDJOG6V.js?v=8d5024c3:15914:22)
+    at beginWork$1 (chunk-WMDJOG6V.js?v=8d5024c3:19753:22)
+    at performUnitOfWork (chunk-WMDJOG6V.js?v=8d5024c3:19198:20)
+    at workLoopSync (chunk-WMDJOG6V.js?v=8d5024c3:19137:13)
+    at renderRootSync (chunk-WMDJOG6V.js?v=8d5024c3:19116:15)
+    at recoverFromConcurrentError (chunk-WMDJOG6V.js?v=8d5024c3:18736:28)
+    at performConcurrentWorkOnRoot (chunk-WMDJOG6V.js?v=8d5024c3:18684:30)
+SearchField @ discover.tsx:135
+renderWithHooks @ chunk-WMDJOG6V.js?v=8d5024c3:11548
+mountIndeterminateComponent @ chunk-WMDJOG6V.js?v=8d5024c3:14926
+beginWork @ chunk-WMDJOG6V.js?v=8d5024c3:15914
+beginWork$1 @ chunk-WMDJOG6V.js?v=8d5024c3:19753
+performUnitOfWork @ chunk-WMDJOG6V.js?v=8d5024c3:19198
+workLoopSync @ chunk-WMDJOG6V.js?v=8d5024c3:19137
+renderRootSync @ chunk-WMDJOG6V.js?v=8d5024c3:19116
+recoverFromConcurrentError @ chunk-WMDJOG6V.js?v=8d5024c3:18736
+performConcurrentWorkOnRoot @ chunk-WMDJOG6V.js?v=8d5024c3:18684
+workLoop @ chunk-WMDJOG6V.js?v=8d5024c3:197
+flushWork @ chunk-WMDJOG6V.js?v=8d5024c3:176
+performWorkUntilDeadline @ chunk-WMDJOG6V.js?v=8d5024c3:384

# 2024-12-22 17:47:11.361991
+chunk-WMDJOG6V.js?v=8d5024c3:9129 Uncaught ReferenceError: tagInputs is not defined
+    at discover.tsx:549:28
+    at Array.map (<anonymous>)
+    at SocialPosts (discover.tsx:500:22)
+

# 2024-12-22 17:50:00.328812
+that is a very good job. Now let's enhance the UI. 1. When click delete show online message ask for are your sure to delete 2. make the search button, adn tags all inline, 3. in the search make the tags in forum of autocomelete imput, 3. enhance the look a little bit make it look more profsional UI UX

# 2024-12-22 17:50:44.745483
+[plugin:vite:esbuild] Transform failed with 1 error:
+/Users/ahmed/Desktop/odoc/src/frontend/pages/Discover/discover.tsx:731:6: ERROR: Expected ")" but found "open"
+/Users/ahmed/Desktop/odoc/src/frontend/pages/Discover/discover.tsx:731:6
+Expected ")" but found "open"
+729|      </Box>
+730|      <Dialog
+731|        open={deleteDialogOpen}
+   |        ^
+732|        onClose={() => setDeleteDialogOpen(false)}
+733|        aria-labelledby="alert-dialog-title"
+

# 2024-12-22 17:55:55.994587
+notice I made ./src/frontend/pages/user.tsx which shows the user profile by the url from browser https://odoc.app/user?id=omwxg-jy7vb-dyi54-xw2ih-rx2a3-yan33-dwkbw-bjjb5-h6gd2-e5eq4-nae and it should be able to call the backend to fetch the user data, in meanhwile it should show progress loading

# 2024-12-22 17:55:57.981652
+yes

# 2024-12-22 17:56:26.471867
+y

# 2024-12-22 17:57:41.060553
+from window.url or window.link you should get the data /user?id=omwxg-jy7vb-dyi54-xw2ih-rx2a3-yan33-dwkbw-bjjb5-h6gd2-e5eq4-nae    however id is the user id here import ProfilePage from "./profile";
+import React from "react";
+
+function UserProfile(props) {
+  return (
+    <ProfilePage
+      friends={[]}
+      profile={profile}
+      history={profile_history}
+    />
+  );
+}
+export default UserProfile
+ you need to compelte the data from backendActor?.get_user

# 2024-12-22 17:57:58.089265
+y

# 2024-12-22 17:59:01.441914
+1 ./src/frontend/pages/user.tsx 2 const { backendActor } = useBackendContext(); ./src/frontend/contexts/BackendContext.tsx

# 2024-12-22 17:59:38.656611
+how to do that?

# 2024-12-22 18:00:09.737474
+import React, {
+  createContext,
+  ReactNode,
+  useCallback,
+  useContext,
+  useEffect,
+  useState,
+} from "react";
+import { AuthClient } from "@dfinity/auth-client";
+import {
+  Actor,
+  ActorMethod,
+  ActorSubclass,
+  HttpAgent,
+  Identity,
+} from "@dfinity/agent";
+import { canisterId, idlFactory } from "../../declarations/backend";
+import { _SERVICE } from "../../declarations/backend/backend.did";
+import { useDispatch } from "react-redux";
+import { handleRedux } from "../redux/store/handleRedux";
+import getLedgerActor from "./ckudc_ledger_actor";
+
+interface State {
+  principal: string | null;
+  identity: Identity | null;
+  backendActor: ActorSubclass<
+    Record<string, ActorMethod<unknown[], unknown>>
+  > | null;
+  agent: HttpAgent | null;
+  isAuthenticating?: boolean;
+}
+
+interface BackendContextProps {
+  authClient: AuthClient | null;
+  agent: HttpAgent | null;
+  backendActor: ActorSubclass<Record<string, ActorMethod<unknown[], unknown>>>;
+  isAuthenticating: boolean;
+  login: () => Promise<void>;
+  logout: () => void;
+}
+
+const BackendContext = createContext<BackendContextProps | undefined>(
+  undefined,
+);
+
+export const useBackendContext = (): BackendContextProps => {
+  const context = useContext(BackendContext);
+  if (!context) {
+    throw new Error("useBackendContext must be used within a BackendProvider");
+  }
+  return context;
+};
+
+interface BackendProviderProps {
+  children: ReactNode;
+}
+
+async function handleAgent(client) {
+  let host = "https://ic0.app";
+  if (import.meta.env.VITE_DFX_NETWORK === "local") {
+    host = import.meta.env.VITE_IC_HOST;
+  }
+
+  const identity = await client.getIdentity();
+  const agent = new HttpAgent({
+    identity,
+    host,
+  });
+  const principal = identity.getPrincipal().toString();
+
+  // ---------------------- root key fetch ---------------------- \\
+  if (import.meta.env.VITE_DFX_NETWORK === "local") {
+    agent
+      .fetchRootKey()
+      .then((rootKey) => {
+        console.log("successfully fetched root key: ");
+      })
+      .catch((err) => {
+        console.log("Error fetching root key: ", err);
+      });
+  }
+
+  const actor = Actor.createActor<_SERVICE>(idlFactory, {
+    agent,
+    canisterId,
+  });
+  return { actor, agent, principal, identity, client };
+}
+
+export const BackendProvider: React.FC<BackendProviderProps> = ({
+  children,
+}) => {
+  const dispatch = useDispatch();
+
+  const port = import.meta.env.VITE_DFX_PORT;
+
+  const [state, setState] = useState<State>({
+    principal: null,
+    identity: null,
+    backendActor: null,
+    agent: null,
+  });
+
+  const [authClient, setAuthClient] = useState<AuthClient | null>(null);
+
+  const login = useCallback(async () => {
+    if (!authClient) {
+      console.log("Auth client not initialized");
+      return;
+    }
+
+    const alreadyAuthenticated = await authClient.isAuthenticated();
+
+    if (alreadyAuthenticated) {
+      dispatch(handleRedux("LOGIN"));
+    } else {
+      let identityProvider = "https://identity.ic0.app/#authorize";
+      if (import.meta.env.VITE_DFX_NETWORK === "local") {
+        identityProvider = `http://${import.meta.env.VITE_INTERNET_IDENTITY}.localhost:${port}`;
+      }
+
+      await authClient.login({
+        identityProvider: identityProvider,
+        onSuccess: async () => {
+          setState((prevState: State) => {
+            return { ...prevState, isAuthenticating: false };
+          });
+          window.location.reload();
+        },
+      });
+    }
+  }, [authClient, port]);
+
+  const logout = () => {
+    dispatch(handleRedux("LOGIN"));
+    authClient?.logout({ returnTo: "/" });
+  };
+
+  useEffect(() => {
+    const initializeAuthClient = async () => {
+      const client = await AuthClient.create();
+      setAuthClient(client);
+      const { actor, agent, principal, identity } = await handleAgent(client);
+      const ckUSDCActor = await getLedgerActor(agent);
+      setState((pre) => {
+        return {
+          ckUSDCActor,
+          backendActor: actor,
+          agent,
+          principal,
+          identity,
+        };
+      });
+
+      const alreadyAuthenticated = await client.isAuthenticated();
+      if (alreadyAuthenticated) {
+        dispatch(handleRedux("LOGIN"));
+      }
+    };
+
+    initializeAuthClient().catch((error) => {
+      console.log("Failed to initialize auth client:", error);
+    });
+  }, []);
+
+  return (
+    <BackendContext.Provider
+      value={{
+        ...state,
+        login,
+        logout,
+      }}
+    >
+      {children}
+    </BackendContext.Provider>
+  );
+};
+

# 2024-12-22 18:00:15.461334
+y

# 2024-12-22 18:10:52.817343
+at ./frontend/pages/user.tsx amek me a compentn fetch data from window.location and call backendActor.get_user then render it in <ProfilePage
+      friends={[]}
+      profile={profile}
+      history={profile_history}
+    /> note url is http://localhost:5173/user?id=omwxg-jy7vb-dyi54-xw2ih-rx2a3-yan33-dwkbw-bjjb5-h6gd2-e5eq4-nae

# 2024-12-22 18:10:59.732595
+n

# 2024-12-22 18:11:16.246129
+y

# 2024-12-22 18:11:43.458049
+n

# 2024-12-23 14:59:33.655207
+for ./src/frontend/components/Chat/chatWindow.tsx show the right messages from backendActor?.get_my_chats... make sure to call redux SET_CHATS also for send message call redux SEND_MESSAGE and call backendActor?.send_message

# 2024-12-23 15:01:10.449852
+how to do that?

# 2024-12-23 15:01:18.341376
+y

# 2024-12-23 15:01:18.347520
+/run cat ./src/frontend/components/Chat/chatWindow.tsx

# 2024-12-23 15:01:18.347632
+/run cat ./src/frontend/components/Chat/chatWindow.tsx

# 2024-12-23 15:01:20.233408
+y

# 2024-12-23 15:01:22.141697
+/run cat ./src/frontend/redux/actions/chatActions.ts

# 2024-12-23 15:01:22.141812
+/run cat ./src/frontend/redux/actions/chatActions.ts

# 2024-12-23 15:01:22.317588
+/run cat ./src/frontend/redux/reducers/chatReducer.ts

# 2024-12-23 15:01:22.317698
+/run cat ./src/frontend/redux/reducers/chatReducer.ts

# 2024-12-23 15:01:23.833704
+y

# 2024-12-23 15:01:25.337596
+/run cat ./src/frontend/types/chat.ts

# 2024-12-23 15:01:25.337729
+/run cat ./src/frontend/types/chat.ts

# 2024-12-23 15:01:27.416758
+y

# 2024-12-23 15:04:26.249885
+use ./src/frontend/components/ChatNotifications/discover.tsx to impiment it in ./src/frontend/components/Chat/discover.tsx

# 2024-12-23 15:04:38.226452
+y

# 2024-12-23 15:04:38.230456
+/run cat ./src/frontend/components/ChatNotifications/discover.tsx

# 2024-12-23 15:04:38.230653
+/run cat ./src/frontend/components/ChatNotifications/discover.tsx

# 2024-12-23 15:04:41.809064
+y

# 2024-12-23 15:04:43.087139
+/run cat ./src/frontend/components/Chat/discover.tsx

# 2024-12-23 15:04:43.087296
+/run cat ./src/frontend/components/Chat/discover.tsx

# 2024-12-23 15:04:44.823494
+y

# 2024-12-23 15:29:13.209739
+I am using it <ChatsComponent chats={chats} /> so use the prop chats in the compnent note interface Chat {
+  id: string;
+  name: string;
+  messages: Array<{
+    id: string;
+    sender: string;
+    content: string;
+    timestamp: string;
+  }>;
+  members: string[];
+  admins: string[];
+}
+ 

# 2024-12-23 15:29:28.513841
+y

# 2024-12-23 15:31:02.364850
+do not add new compnent I already have ./src/frontend/components/Chat/discover.tsx juse adjust it

# 2024-12-23 15:31:45.053950
+how to do that?

# 2024-12-23 15:32:08.559502
+import React, { useState, useCallback, memo } from "react";
+import {
+  IconButton,
+  Badge,
+  Menu,
+  MenuItem,
+  Typography,
+  List,
+  ListItem,
+  ListItemText,
+  TextField,
+  Button,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  Autocomplete,
+  Box,
+  Chip,
+  FormControl,
+  InputLabel,
+  Select,
+  Paper,
+  ListItemAvatar,
+  Avatar,
+  Drawer,
+  AppBar,
+  Toolbar,
+} from "@mui/material";
+
+import {
+  Chat as ChatIcon,
+  Add as AddIcon,
+  Send as SendIcon,
+  ArrowBack as ArrowBackIcon,
+  OpenInFull as OpenInFullIcon,
+  Group as GroupIcon,
+} from "@mui/icons-material";
+import ChatWindow from "./chatWindow";
+
+// Memoized form components
+const GroupNameField = memo(({ value, onChange }) => (
+  <TextField
+    label="Group Name"
+    value={value}
+    onChange={(e) => onChange(e.target.value)}
+    fullWidth
+  />
+));
+
+export const MembersSelect = memo(({ value, onChange, users }) => (
+  <Autocomplete
+    multiple
+    options={users}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Members" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const AdminsSelect = memo(({ value, onChange, members }) => (
+  <Autocomplete
+    multiple
+    options={members}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Admins" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+const WorkspaceSelect = memo(({ value, onChange, workspaces }) => (
+  <FormControl fullWidth>
+    <InputLabel>Workspace</InputLabel>
+    <Select
+      value={value}
+      label="Workspace"
+      onChange={(e) => onChange(e.target.value)}
+    >
+      {workspaces.map((workspace) => (
+        <MenuItem key={workspace.id} value={workspace.id}>
+          {workspace.name}
+        </MenuItem>
+      ))}
+    </Select>
+  </FormControl>
+));
+
+// Memoized Create Group Dialog
+const CreateGroupDialog = memo(
+  ({ open, onClose, onSubmit, initialData, users, workspaces }) => {
+    const [formData, setFormData] = useState(initialData);
+
+    const handleNameChange = useCallback((name) => {
+      setFormData((prev) => ({ ...prev, name }));
+    }, []);
+
+    const handleMembersChange = useCallback((members) => {
+      setFormData((prev) => ({ ...prev, members }));
+    }, []);
+
+    const handleAdminsChange = useCallback((admins) => {
+      setFormData((prev) => ({ ...prev, admins }));
+    }, []);
+
+    const handleWorkspaceChange = useCallback((workspace) => {
+      setFormData((prev) => ({ ...prev, workspace }));
+    }, []);
+
+    const handleSubmit = useCallback(() => {
+      onSubmit(formData);
+    }, [formData, onSubmit]);
+
+    return (
+      <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
+        <DialogTitle>Create New Group Chat</DialogTitle>
+        <DialogContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}>
+            <GroupNameField value={formData.name} onChange={handleNameChange} />
+            <MembersSelect
+              value={formData.members}
+              onChange={handleMembersChange}
+              users={users}
+            />
+            <AdminsSelect
+              value={formData.admins}
+              onChange={handleAdminsChange}
+              members={formData.members}
+            />
+            <WorkspaceSelect
+              value={formData.workspace}
+              onChange={handleWorkspaceChange}
+              workspaces={workspaces}
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={onClose}>Cancel</Button>
+          <Button onClick={handleSubmit} variant="contained" color="primary">
+            Create Group
+          </Button>
+        </DialogActions>
+      </Dialog>
+    );
+  },
+);
+
+// Memoized Chat List
+const ChatList = memo(({ chats, onChatClick }) => (
+  <List sx={{ padding: 0, width: "100%" }}>
+    {chats.map((chat) => (
+      <ListItem
+        key={chat.id}
+        onClick={() => onChatClick(chat)}
+        button
+        sx={{
+          borderBottom: 1,
+          borderColor: "divider",
+          "&:hover": { backgroundColor: "action.hover" },
+        }}
+      >
+        <ListItemAvatar>
+          <Avatar>
+            <GroupIcon />
+          </Avatar>
+        </ListItemAvatar>
+        <ListItemText
+          primary={
+            <Box sx={{ display: "flex", justifyContent: "space-between" }}>
+              <Typography variant="subtitle2">{chat.name}</Typography>
+              {chat.unread > 0 && (
+                <Badge badgeContent={chat.unread} color="error" />
+              )}
+            </Box>
+          }
+          secondary={
+            <>
+              <Typography variant="body2" color="textSecondary">
+                {chat.messages[chat.messages.length - 1]?.content}
+              </Typography>
+              <Typography variant="caption" color="textSecondary">
+                {formatDate(chat.messages[chat.messages.length - 1]?.timestamp)}
+              </Typography>
+            </>
+          }
+        />
+      </ListItem>
+    ))}
+  </List>
+));
+
+// Memoized Chat View
+const ChatView = memo(
+  ({ chat, isFullView, onBack, onFullViewToggle, onSendMessage }) => {
+    const [newMessage, setNewMessage] = useState("");
+
+    const handleSubmit = useCallback(
+      (e) => {
+        e.preventDefault();
+        if (newMessage.trim()) {
+          onSendMessage(newMessage);
+          setNewMessage("");
+        }
+      },
+      [newMessage, onSendMessage],
+    );
+
+    return (
+      <Box sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
+        <AppBar position="static" color="default" elevation={1}>
+          <Toolbar>
+            <IconButton size="small" onClick={onBack}>
+              <ArrowBackIcon />
+            </IconButton>
+            <Typography variant="subtitle1" sx={{ ml: 1, flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton onClick={onFullViewToggle}>
+              <OpenInFullIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+          {chat.messages.map((message) => (
+            <Paper
+              key={message.id}
+              sx={{
+                p: 2,
+                mb: 2,
+                maxWidth: "80%",
+                ml: message.sender === "You" ? "auto" : 0,
+              }}
+            >
+              <Typography variant="subtitle2">{message.sender}</Typography>
+              <Typography variant="body1">{message.content}</Typography>
+              <Typography variant="caption" color="textSecondary">
+                {formatDate(message.timestamp)}
+              </Typography>
+            </Paper>
+          ))}
+        </Box>
+
+        <Paper sx={{ p: 2 }}>
+          <form onSubmit={handleSubmit} style={{ display: "flex", gap: 8 }}>
+            <TextField
+              size="small"
+              value={newMessage}
+              onChange={(e) => setNewMessage(e.target.value)}
+              placeholder="Type your message..."
+              fullWidth
+              variant="outlined"
+            />
+            <IconButton type="submit" color="primary">
+              <SendIcon />
+            </IconButton>
+          </form>
+        </Paper>
+      </Box>
+    );
+  },
+);
+
+// Helper function for date formatting
+const formatDate = (dateString) => {
+  const date = new Date(dateString);
+  return date.toLocaleString();
+};
+
+// Main component
+const ChatNotifications = () => {
+  const [openChats, setOpenChats] = useState(new Map()); // Map of chatId to window position
+
+  const handleOpenChat = useCallback((chat) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      if (!newChats.has(chat.id)) {
+        // Calculate position for new window with slight offset from previous
+        const offset = newChats.size * 30;
+        newChats.set(chat.id, {
+          x: 100 + offset,
+          y: 100 + offset,
+        });
+      }
+      return newChats;
+    });
+  }, []);
+
+  const handleCloseChat = useCallback((chatId) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      newChats.delete(chatId);
+      return newChats;
+    });
+  }, []);
+
+  const handleChatPosition = useCallback((chatId, position) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      newChats.set(chatId, position);
+      return newChats;
+    });
+  }, []);
+
+  const [anchorEl, setAnchorEl] = useState(null);
+  const [selectedChat, setSelectedChat] = useState(null);
+  const [createGroupOpen, setCreateGroupOpen] = useState(false);
+
+  // Sample data
+  const users = [
+    { id: 1, name: "John Doe" },
+    { id: 2, name: "Jane Smith" },
+    { id: 3, name: "Bob Johnson" },
+  ];
+
+  const workspaces = [
+    { id: 1, name: "Marketing" },
+    { id: 2, name: "Development" },
+    { id: 3, name: "Sales" },
+  ];
+
+  const [chats, setChats] = useState([
+    {
+      id: 1,
+      name: "Project Team",
+      messages: [
+        {
+          id: 1,
+          sender: "John",
+          content: "Can we schedule a meeting?",
+          timestamp: "2024-12-18T10:30:00",
+        },
+        {
+          id: 2,
+          sender: "Jane",
+          content: "Yes, how about tomorrow?",
+          timestamp: "2024-12-18T10:35:00",
+        },
+      ],
+      unread: 2,
+    },
+    {
+      id: 2,
+      name: "Marketing Group",
+      messages: [
+        {
+          id: 1,
+          sender: "Bob",
+          content: "The new designs look great!",
+          timestamp: "2024-12-18T09:15:00",
+        },
+      ],
+      unread: 1,
+    },
+  ]);
+
+  const initialGroupData = {
+    name: "",
+    members: [],
+    admins: [],
+    workspace: "",
+  };
+
+  const handleClick = useCallback((event) => {
+    setAnchorEl(event.currentTarget);
+  }, []);
+
+  const handleClose = useCallback(() => {
+    setAnchorEl(null);
+    setSelectedChat(null);
+  }, []);
+
+  const handleChatClick = useCallback(
+    (chat) => {
+      // Clear unread count for the clicked chat
+      const updatedChats = chats.map((c) => {
+        if (c.id === chat.id) {
+          return { ...c, unread: 0 };
+        }
+        return c;
+      });
+      // Update the chats state here - you'll need to lift this state up
+      // and pass setChats as a prop if you haven't already
+      setChats(updatedChats);
+
+      handleOpenChat(chat);
+      setSelectedChat(null);
+      setAnchorEl(null);
+    },
+    [handleOpenChat, chats, setChats],
+  );
+
+  const handleCreateGroup = useCallback((formData) => {
+    console.log("Creating new group:", formData);
+    setCreateGroupOpen(false);
+  }, []);
+
+  const handleSendMessage = useCallback((chatId, message) => {
+    const newMessage = {
+      id: Date.now(),
+      sender: "You",
+      content: message,
+      timestamp: new Date().toISOString(),
+    };
+
+    setChats((prevChats) =>
+      prevChats.map((chat) =>
+        chat.id === chatId
+          ? { ...chat, messages: [...chat.messages, newMessage] }
+          : chat,
+      ),
+    );
+  }, []);
+
+  const totalUnread = chats.reduce((sum, chat) => sum + chat.unread, 0);
+  const open = Boolean(anchorEl);
+
+  return (
+    <>
+      <IconButton
+        onClick={handleClick}
+        aria-controls={open ? "chat-menu" : undefined}
+        aria-haspopup="true"
+        aria-expanded={open ? "true" : undefined}
+      >
+        <Badge badgeContent={totalUnread} color="error">
+          <ChatIcon />
+        </Badge>
+      </IconButton>
+
+      <Menu
+        id="chat-menu"
+        anchorEl={anchorEl}
+        open={open}
+        onClose={handleClose}
+        PaperProps={{
+          sx: {
+            maxHeight: 500,
+            width: 320,
+          },
+        }}
+        transformOrigin={{ horizontal: "right", vertical: "top" }}
+        anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
+      >
+        <MenuItem sx={{ justifyContent: "center" }}>
+          <Button
+            startIcon={<AddIcon />}
+            variant="outlined"
+            fullWidth
+            onClick={() => setCreateGroupOpen(true)}
+          >
+            Create New Group
+          </Button>
+        </MenuItem>
+
+        {selectedChat ? (
+          <ChatView
+            chat={selectedChat}
+            // isFullView={isFullView}
+            onBack={() => setSelectedChat(null)}
+            // onFullViewToggle={() => setIsFullView(!isFullView)}
+            onSendMessage={handleSendMessage}
+          />
+        ) : (
+          <ChatList chats={chats} onChatClick={handleChatClick} />
+        )}
+      </Menu>
+
+      {Array.from(openChats.entries()).map(([chatId, position]) => {
+        const chat = chats.find((c) => c.id === chatId);
+        if (!chat) return null;
+
+        return (
+          <ChatWindow
+            key={chatId}
+            chat={chat}
+            position={position}
+            onClose={handleCloseChat}
+            onPositionChange={handleChatPosition}
+            onSendMessage={handleSendMessage} // Add this prop
+          />
+        );
+      })}
+
+      <CreateGroupDialog
+        open={createGroupOpen}
+        onClose={() => setCreateGroupOpen(false)}
+        onSubmit={handleCreateGroup}
+        initialData={initialGroupData}
+        users={users}
+        workspaces={workspaces}
+      />
+    </>
+  );
+};
+
+export default ChatNotifications;
+

# 2024-12-23 15:33:34.070153
+import React, { useState, useCallback } from "react";
+import {
+  List,
+  ListItem,
+  ListItemText,
+  Button,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  Typography,
+  Rating,
+  Stack,
+  Chip,
+  Paper,
+  TextField,
+  Divider,
+} from "@mui/material";
+import ChatWindow from "../../components/Chat/chatWindow";
+import UserAvatarMenu from "../../components/MainComponents/UserAvatarMenu";
+import Avatar from "@mui/material/Avatar";
+import FriendshipButton from "../../components/FriendshipButton";
+import { useSelector } from "react-redux";
+interface Review {
+  rating: number;
+  comment: string;
+  timestamp: string;
+  reviewerId: string;
+  reviewerName: string;
+}
+
+interface User {
+  id: string;
+  name: string;
+  description: string;
+  photo: string;
+  reviews?: Review[];
+  averageRating?: number;
+}
+
+interface Friend {
+  id: string;
+  sender: User;
+  receiver: User;
+  confirmed: boolean;
+}
+
+interface Chat {
+  id: string;
+  name: string;
+  messages: Array<{
+    id: string;
+    sender: string;
+    content: string;
+    timestamp: string;
+  }>;
+  members: string[];
+  admins: string[];
+}
+
+interface ChatWindowPosition {
+  x: number;
+  y: number;
+}
+
+interface FriendsListProps {
+  friends: Friend[];
+  currentUser: User;
+  onAcceptFriend: (friendId: string) => void;
+  onRejectFriend: (friendId: string) => void;
+  onCancelRequest: (friendId: string) => void;
+  onUnfriend: (friendId: string) => void;
+  onSendMessage: (userId: string, message: string) => void;
+  onRateUser: (userId: string, rating: number) => void;
+}
+
+const FriendsList: React.FC<FriendsListProps> = ({
+  friends,
+  currentUser,
+  onSendMessage,
+  onRateUser,
+}) => {
+  const [selectedUser, setSelectedUser] = useState<User | null>(null);
+  const [rating, setRating] = useState<number>(0);
+  const [review, setReview] = useState<string>("");
+  const [activeChats, setActiveChats] = useState<Map<string, Chat>>(new Map());
+  const [chatPositions, setChatPositions] = useState<
+    Map<string, ChatWindowPosition>
+  >(new Map());
+
+  const handleProfileClose = () => {
+    setSelectedUser(null);
+    setRating(0);
+  };
+
+  const handleSubmitReview = () => {
+    if (selectedUser && rating > 0) {
+      const newReview: Review = {
+        rating,
+        comment: review,
+        timestamp: new Date().toISOString(),
+        reviewerId: currentUser?.id || "",
+        reviewerName: currentUser?.name || "",
+      };
+      onRateUser(selectedUser.id, rating);
+      // Reset form
+      setRating(0);
+      setReview("");
+    }
+  };
+
+  const handleOpenChat = useCallback(
+    (user: User) => {
+      const chatId = `chat-${user.id}`;
+      if (!activeChats.has(chatId)) {
+        const newChat: Chat = {
+          id: chatId,
+          name: user.name,
+          messages: [],
+          members: [currentUser.id, user.id],
+          admins: [currentUser.id],
+        };
+
+        setActiveChats(new Map(activeChats.set(chatId, newChat)));
+
+        // Set initial position for new chat window
+        const position = {
+          x: window.innerWidth - 350 - activeChats.size * 20,
+          y: window.innerHeight - 450 - activeChats.size * 20,
+        };
+        setChatPositions(new Map(chatPositions.set(chatId, position)));
+      }
+      setSelectedUser(null);
+    },
+    [activeChats, chatPositions, currentUser && currentUser.id],
+  );
+
+  const handleCloseChat = useCallback((chatId: string) => {
+    setActiveChats((prevChats) => {
+      const newChats = new Map(prevChats);
+      newChats.delete(chatId);
+      return newChats;
+    });
+    setChatPositions((prevPositions) => {
+      const newPositions = new Map(prevPositions);
+      newPositions.delete(chatId);
+      return newPositions;
+    });
+  }, []);
+
+  const handleChatPositionChange = useCallback(
+    (chatId: string, position: ChatWindowPosition) => {
+      setChatPositions(
+        (prevPositions) => new Map(prevPositions.set(chatId, position)),
+      );
+    },
+    [],
+  );
+
+  const { Anonymous, profile } = useSelector((state: any) => state.filesState);
+
+  return (
+    <>
+      <List>
+        {friends.map((friend) => {
+          const otherUser =
+            friend.sender.id === currentUser?.id
+              ? friend.receiver
+              : friend.sender;
+          return (
+            <ListItem
+              key={friend.id}
+              secondaryAction={
+                currentUser &&
+                currentUser.id == profile.id && (
+                  <FriendshipButton
+                    profile={currentUser}
+                    user={otherUser}
+                    friends={friends}
+                  />
+                )
+              }
+            >
+              <UserAvatarMenu
+                user={otherUser}
+                onMessageClick={() => setSelectedUser(otherUser)}
+              />
+              <ListItemText
+                primary={otherUser.name}
+                secondary={
+                  <Stack direction="row" spacing={1} alignItems="center">
+                    <Chip
+                      label={otherUser.description}
+                      size="small"
+                      color={friend.confirmed ? "success" : "default"}
+                    />
+                  </Stack>
+                }
+              />
+            </ListItem>
+          );
+        })}
+      </List>
+
+      <Dialog
+        open={!!selectedUser}
+        onClose={handleProfileClose}
+        maxWidth="md"
+        fullWidth
+      >
+        {selectedUser && (
+          <>
+            <DialogTitle>
+              <Stack direction="row" spacing={2} alignItems="center">
+                <Avatar
+                  src={`data:image/jpeg;base64,${selectedUser.photo}`}
+                  sx={{ width: 56, height: 56 }}
+                />
+                <Typography variant="h6">{selectedUser.name}</Typography>
+              </Stack>
+            </DialogTitle>
+            <DialogContent>
+              <Stack spacing={3}>
+                <Typography variant="body1">
+                  {selectedUser.description}
+                </Typography>
+
+                <Stack spacing={2}>
+                  {selectedUser.reviews?.map((review, index) => (
+                    <Paper
+                      key={index}
+                      sx={{ p: 2, bgcolor: "background.default" }}
+                    >
+                      <Stack spacing={1}>
+                        <Stack
+                          direction="row"
+                          justifyContent="space-between"
+                          alignItems="center"
+                        >
+                          <Typography variant="subtitle2">
+                            {review.reviewerName}
+                          </Typography>
+                          <Rating value={review.rating} readOnly size="small" />
+                        </Stack>
+                        <Typography variant="body2">
+                          {review.comment}
+                        </Typography>
+                        <Typography variant="caption" color="text.secondary">
+                          {new Date(review.timestamp).toLocaleDateString()}
+                        </Typography>
+                      </Stack>
+                    </Paper>
+                  ))}
+
+                  <Divider sx={{ my: 2 }} />
+
+                  <Typography variant="subtitle1">Write a Review</Typography>
+                  <Rating
+                    value={rating}
+                    onChange={(_, newValue) => handleRating(newValue)}
+                  />
+                  <TextField
+                    label="Your Review"
+                    multiline
+                    rows={3}
+                    value={review}
+                    onChange={(e) => setReview(e.target.value)}
+                    fullWidth
+                  />
+                </Stack>
+              </Stack>
+            </DialogContent>
+            <DialogActions>
+              <Button onClick={handleProfileClose}>Close</Button>
+              <Button
+                onClick={handleSubmitReview}
+                variant="outlined"
+                color="primary"
+                disabled={!rating || !review.trim()}
+              >
+                Submit Review
+              </Button>
+              <Button
+                onClick={() => handleOpenChat(selectedUser)}
+                variant="contained"
+                color="primary"
+              >
+                Open Chat
+              </Button>
+            </DialogActions>
+          </>
+        )}
+      </Dialog>
+
+      {/* Render active chat windows */}
+      {Array.from(activeChats.entries()).map(([chatId, chat]) => (
+        <ChatWindow
+          key={chatId}
+          chat={chat}
+          onClose={handleCloseChat}
+          position={chatPositions.get(chatId) || { x: 0, y: 0 }}
+          onPositionChange={handleChatPositionChange}
+        />
+      ))}
+    </>
+  );
+};
+
+export default FriendsList;
+import React, {forwardRef, useImperativeHandle, useRef, useState} from "react";
+import {
+  Box,
+  Button,
+  Card,
+  CardContent,
+  Chip,
+  TextField,
+} from "@mui/material";
+import EditorComponent from "./EditorComponent";
+
+export interface CreatePostRef {
+  getContent: () => any;
+  getTags: () => string[];
+  reset: () => void;
+}
+
+interface CreatePostProps {
+  onSubmit: (content: any, tags: string[]) => Promise<void>;
+  isPosting: boolean;
+}
+
+const CreatePost = forwardRef<CreatePostRef, CreatePostProps>(
+  ({ onSubmit, isPosting }, ref) => {
+    const contentRef = useRef<any>(null);
+    const tagsRef = useRef<string[]>([]);
+    const tagInputRef = useRef<HTMLInputElement>(null);
+    const [forceUpdate, setForceUpdate] = useState(false);
+    const [tags, setTags] = useState<string[]>([]);
+
+    useImperativeHandle(ref, () => ({
+      getContent: () => contentRef.current,
+      getTags: () => tagsRef.current,
+      reset: () => {
+        contentRef.current = null;
+        tagsRef.current = [];
+        if (tagInputRef.current) {
+          tagInputRef.current.value = "";
+        }
+        // Force a re-render to clear the editor
+        setForceUpdate(prev => !prev);
+      },
+    }));
+
+    const handleAddTag = () => {
+      const tagInput = tagInputRef.current;
+      if (tagInput && tagInput.value.trim()) {
+        const newTag = tagInput.value.trim();
+        tagsRef.current = [...new Set([...tagsRef.current, newTag])];
+        setTags([...new Set([...tags, newTag])]);
+        tagInput.value = "";
+      }
+    };
+
+    const handleRemoveTag = (tagToRemove: string) => {
+      tagsRef.current = tagsRef.current.filter((tag) => tag !== tagToRemove);
+      setTags(tags.filter((tag) => tag !== tagToRemove));
+    };
+
+    const handleSubmit = async () => {
+      await onSubmit(contentRef.current, tagsRef.current);
+    };
+
+    return (
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mb: 2 }}>
+            <Box>
+              <EditorComponent
+                contentEditable={true}
+                onChange={(changes) => {
+                  let new_change = {};
+                  new_change[""] = changes;
+                  contentRef.current = new_change;
+                }}
+                content={[]}
+              />
+            </Box>
+            <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
+              <TextField
+                inputRef={tagInputRef}
+                size="small"
+                placeholder="Add tag..."
+                variant="standard"
+                onKeyPress={(e) => {
+                  if (e.key === 'Enter') {
+                    handleAddTag();
+                  }
+                }}
+              />
+              <Button
+                variant="outlined"
+                size="small"
+                onClick={handleAddTag}
+              >
+                Add Tag
+              </Button>
+            </Box>
+            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
+              {tags.map((tag) => (
+                <Chip
+                  key={tag}
+                  label={tag}
+                  onDelete={() => handleRemoveTag(tag)}
+                  size="small"
+                />
+              ))}
+            </Box>
+          </Box>
+          <Button
+            variant="contained"
+            fullWidth
+            onClick={handleSubmit}
+            disabled={isPosting}
+          >
+            {isPosting ? "Posting..." : "Post"}
+          </Button>
+        </CardContent>
+      </Card>
+    );
+  }
+);
+
+export default CreatePost;
+import React, { useState, useEffect, useRef } from "react";
+import CreatePost, { CreatePostRef } from "../../components/CreatePost";
+import { Principal } from "@dfinity/principal";
+import {
+  Autocomplete,
+  Box,
+  Button,
+  Card,
+  CardContent,
+  CardHeader,
+  Chip,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogContentText,
+  DialogTitle,
+  IconButton,
+  Paper,
+  TextField,
+  Typography,
+} from "@mui/material";
+import {
+  Comment as MessageCircleIcon,
+  Favorite as HeartIcon,
+  Reply as ReplyIcon,
+  Send as SendIcon,
+  Share as ShareIcon,
+  ThumbDown as ThumbsDownIcon,
+} from "@mui/icons-material";
+import SearchIcon from "@mui/icons-material/Search";
+import UserAvatarMenu from "../../components/MainComponents/UserAvatarMenu";
+import { useBackendContext } from "../../contexts/BackendContext";
+import {
+  ContentNode,
+  Post,
+  PostUser,
+} from "../../../declarations/backend/backend.did";
+import { useSelector } from "react-redux";
+import { randomString } from "../../DataProcessing/dataSamples";
+import EditorComponent from "../../components/EditorComponent";
+import { logger } from "../../DevUtils/logData";
+import { deserializeContentTree } from "../../DataProcessing/deserlize/deserializeContents";
+import serializeFileContents from "../../DataProcessing/serialize/serializeFileContents";
+
+const Comment = ({ comment, onReply, level = 0 }) => {
+  const [showReplyInput, setShowReplyInput] = useState(false);
+  const [replyContent, setReplyContent] = useState("");
+
+  const handleReplySubmit = () => {
+    if (!replyContent.trim()) return;
+    onReply(comment.id, replyContent);
+    setReplyContent("");
+    setShowReplyInput(false);
+  };
+
+  return (
+    <Box sx={{ ml: level * 3, mb: 2 }}>
+      <Paper variant="outlined" sx={{ p: 2 }}>
+        <Box sx={{ display: "flex", gap: 1, mb: 1 }}>
+          {comment.user && <UserAvatarMenu user={comment.user} size="small" />}
+          <Box>
+            <Typography variant="subtitle2">{comment.user.name}</Typography>
+            <Typography variant="caption" color="text.secondary">
+              {comment.timestamp}
+            </Typography>
+          </Box>
+        </Box>
+        <Typography variant="body2" sx={{ mb: 1 }}>
+          {comment.content}
+        </Typography>
+        <Button
+          size="small"
+          startIcon={<ReplyIcon />}
+          onClick={() => setShowReplyInput(!showReplyInput)}
+        >
+          Reply
+        </Button>
+      </Paper>
+
+      {showReplyInput && (
+        <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
+          <TextField
+            size="small"
+            fullWidth
+            placeholder="Write a reply..."
+            value={replyContent}
+            onChange={(e) => setReplyContent(e.target.value)}
+          />
+          <IconButton onClick={handleReplySubmit} color="primary">
+            <SendIcon />
+          </IconButton>
+        </Box>
+      )}
+
+      {comment.replies?.map((reply) => (
+        <Comment
+          key={reply.id}
+          comment={reply}
+          onReply={onReply}
+          level={level + 1}
+        />
+      ))}
+    </Box>
+  );
+};
+
+const SearchField = ({
+  searchQuery,
+  setSearchQuery,
+  selectedTags,
+  setSelectedTags,
+}) => {
+  const [tagInput, setTagInput] = useState("");
+  const [suggestedTags] = useState([
+    "technology",
+    "programming",
+    "design",
+    "business",
+    "marketing",
+    "science",
+    "art",
+    "music",
+    "travel",
+    "food",
+  ]); // You can replace these with actual tags from your backend
+
+  const handleAddTag = () => {
+    if (tagInput.trim() && !selectedTags.includes(tagInput.trim())) {
+      setSelectedTags([...selectedTags, tagInput.trim()]);
+      setTagInput("");
+    }
+  };
+
+  const handleRemoveTag = (tagToRemove: string) => {
+    setSelectedTags(selectedTags.filter((tag) => tag !== tagToRemove));
+  };
+
+  const filteredSuggestions = suggestedTags.filter(
+    (tag) =>
+      tag.toLowerCase().includes(tagInput.toLowerCase()) &&
+      !selectedTags.includes(tag),
+  );
+
+  return (
+    <Card sx={{ mb: 3, boxShadow: 3 }}>
+      <CardContent>
+        <Box sx={{ display: "flex", gap: 2, alignItems: "center", mb: 2 }}>
+          <TextField
+            fullWidth
+            placeholder="Search posts by content or user..."
+            value={searchQuery}
+            onChange={(e) => setSearchQuery(e.target.value)}
+            InputProps={{
+              startAdornment: (
+                <Box sx={{ color: "text.secondary", mr: 1 }}>
+                  <SearchIcon />
+                </Box>
+              ),
+            }}
+            size="small"
+            sx={{ flexGrow: 1 }}
+          />
+          <Autocomplete
+            freeSolo
+            size="small"
+            options={filteredSuggestions}
+            inputValue={tagInput}
+            onInputChange={(_, newValue) => setTagInput(newValue)}
+            onChange={(_, newValue) => {
+              if (newValue) {
+                setSelectedTags([...new Set([...selectedTags, newValue])]);
+                setTagInput("");
+              }
+            }}
+            renderInput={(params) => (
+              <TextField
+                {...params}
+                placeholder="Add tag..."
+                size="small"
+                sx={{ width: 200 }}
+                onKeyPress={(e) => {
+                  if (e.key === "Enter") {
+                    handleAddTag();
+                  }
+                }}
+              />
+            )}
+          />
+          <Button
+            variant="contained"
+            size="small"
+            onClick={handleAddTag}
+            sx={{ minWidth: 100 }}
+          >
+            Add Tag
+          </Button>
+        </Box>
+        <Box sx={{ display: "flex", flexWrap: "wrap", gap: 1 }}>
+          {selectedTags.map((tag) => (
+            <Chip
+              key={tag}
+              label={tag}
+              onDelete={() => handleRemoveTag(tag)}
+              size="small"
+              sx={{
+                bgcolor: "primary.light",
+                color: "white",
+                "&:hover": {
+                  bgcolor: "primary.main",
+                },
+              }}
+            />
+          ))}
+        </Box>
+      </CardContent>
+    </Card>
+  );
+};
+
+const SocialPosts = () => {
+  const { backendActor } = useBackendContext();
+  const [posts, setPosts] = useState<Array<PostUser>>([]);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState<string | null>(null);
+  const { profile } = useSelector((state: any) => state.filesState);
+  const currentUser = profile;
+
+  useEffect(() => {
+    const fetchPosts = async () => {
+      try {
+        if (!backendActor) return;
+        const result = await backendActor.get_posts(BigInt(0), BigInt(20));
+        setPosts(result.reverse());
+        setError(null);
+      } catch (err) {
+        console.error("Failed to fetch posts:", err);
+        setError("Failed to load posts. Please try again later.");
+      } finally {
+        setLoading(false);
+      }
+    };
+
+    fetchPosts();
+  }, [backendActor]);
+
+  const createPostRef = useRef<CreatePostRef>(null);
+  const [tagInputs, setTagInputs] = useState<{ [key: string]: string }>({});
+  const [commentInputs, setCommentInputs] = useState({});
+  const [showComments, setShowComments] = useState({});
+  const [isPosting, setIsPosting] = useState(false);
+  const [isSaving, setIsSaving] = useState(false);
+  const [newPostContent, setNewPostContent] = useState<any>(null);
+
+  const handleNewPost = async (content: any, tags: string[]) => {
+    if (!content || !backendActor) return;
+    setIsPosting(true);
+
+    try {
+      let de_changes: Array<Array<[string, Array<[string, ContentNode]>]>> =
+        serializeFileContents(content);
+      let content_tree: Array<[string, ContentNode]> = de_changes[0][0][1];
+      const newPost: Post = {
+        id: randomString(),
+        creator: profile.id,
+        date_created: BigInt(Date.now() * 1e6),
+        votes_up: [],
+        tags,
+        content_tree,
+        votes_down: [],
+      };
+      try {
+        const result = await backendActor.save_post(newPost);
+        if ("Ok" in result) {
+          const updatedPosts = await backendActor.get_posts(
+            BigInt(0),
+            BigInt(20),
+          );
+          setPosts(updatedPosts.reverse());
+          createPostRef.current?.reset();
+        } else {
+          console.error("Failed to create post:", result.Err);
+        }
+      } catch (err) {
+        console.error("Error save_post:", err);
+      }
+    } catch (err) {
+      console.error("Error creating post:", err);
+    } finally {
+      setIsPosting(false);
+    }
+  };
+
+  const [searchQuery, setSearchQuery] = useState("");
+  const [selectedTags, setSelectedTags] = useState<string[]>([]);
+
+  // Add this function after other handler functions
+  const filteredPosts = posts.filter((post) => {
+    const contentText = post.content_tree
+      .map((node) => node.text)
+      .join(" ")
+      .toLowerCase();
+    const matchesSearch =
+      contentText.includes(searchQuery.toLowerCase()) ||
+      post.creator?.name?.toLowerCase().includes(searchQuery.toLowerCase());
+
+    const matchesTags =
+      selectedTags.length === 0 ||
+      selectedTags.every((tag) => post.tags.includes(tag));
+
+    return matchesSearch && matchesTags;
+  });
+
+  const handleVoteUp = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_up(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote up:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting up:", err);
+    }
+  };
+
+  const handleVoteDown = async (postId: string) => {
+    try {
+      if (!backendActor) return;
+      const result = await backendActor.vote_down(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.map((post) =>
+          post.id === postId ? result.Ok : post,
+        );
+        setPosts(updatedPosts);
+      } else {
+        console.error("Failed to vote down:", result.Err);
+      }
+    } catch (err) {
+      console.error("Error voting down:", err);
+    }
+  };
+
+  const [isDeletingPost, setIsDeletingPost] = useState<string | null>(null);
+
+  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
+  const [postToDelete, setPostToDelete] = useState<string | null>(null);
+
+  const handleDeletePost = async (postId: string) => {
+    setPostToDelete(postId);
+    setDeleteDialogOpen(true);
+  };
+
+  const confirmDelete = async () => {
+    if (!backendActor || !postToDelete) return;
+    setIsDeletingPost(postToDelete);
+    try {
+      const result = await backendActor.delete_post(postId);
+      if ("Ok" in result) {
+        const updatedPosts = posts.filter((post) => post.id !== postId);
+        setPosts(updatedPosts);
+      }
+    } catch (err) {
+      console.error("Error deleting post:", err);
+    } finally {
+      setIsDeletingPost(null);
+    }
+  };
+
+  const handleSavePost = async (post: PostUser) => {
+    if (!newPostContent || !backendActor) return;
+
+    setIsSaving(true);
+    try {
+      let de_changes: Array<Array<[string, Array<[string, ContentNode]>]>> =
+        serializeFileContents(newPostContent);
+      let content_tree: Array<[string, ContentNode]> = de_changes[0][0][1];
+
+      const updatedPost: Post = {
+        ...post,
+        creator: profile.id,
+        content_tree,
+      };
+
+      const result = await backendActor.save_post(updatedPost);
+      if ("Ok" in result) {
+        const updatedPosts = await backendActor.get_posts(
+          BigInt(0),
+          BigInt(20),
+        );
+        setPosts(updatedPosts.reverse());
+        setNewPostContent(null);
+      }
+    } catch (err) {
+      console.error("Error saving post:", err);
+    } finally {
+      setIsSaving(false);
+    }
+  };
+
+  const handleShare = (postId) => {
+    alert("Share functionality would go here!");
+  };
+
+  const toggleComments = (postId) => {
+    setShowComments((prev) => ({
+      ...prev,
+      [postId]: !prev[postId],
+    }));
+  };
+
+  const handleComment = (postId) => {
+    if (!commentInputs[postId]?.trim()) return;
+
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          return {
+            ...post,
+            comments: [
+              ...post.comments,
+              {
+                id: Date.now(),
+                content: commentInputs[postId],
+                timestamp: new Date().toLocaleString(),
+                replies: [],
+                user: currentUser,
+              },
+            ],
+          };
+        }
+        return post;
+      }),
+    );
+
+    setCommentInputs((prev) => ({
+      ...prev,
+      [postId]: "",
+    }));
+  };
+
+  const handleReply = (postId, commentId, replyContent) => {
+    setPosts(
+      posts.map((post) => {
+        if (post.id === postId) {
+          const updatedComments = addReplyToComment(post.comments, commentId, {
+            id: Date.now(),
+            content: replyContent,
+            timestamp: new Date().toLocaleString(),
+            replies: [],
+            user: currentUser,
+          });
+          return { ...post, comments: updatedComments };
+        }
+        return post;
+      }),
+    );
+  };
+
+  const addReplyToComment = (comments, commentId, reply) => {
+    return comments.map((comment) => {
+      if (comment.id === commentId) {
+        return {
+          ...comment,
+          replies: [...(comment.replies || []), reply],
+        };
+      }
+      if (comment.replies?.length) {
+        return {
+          ...comment,
+          replies: addReplyToComment(comment.replies, commentId, reply),
+        };
+      }
+      return comment;
+    });
+  };
+
+  return (
+    <Box sx={{ maxWidth: 800, mx: "auto", p: 2 }}>
+      <Dialog
+        open={deleteDialogOpen}
+        onClose={() => setDeleteDialogOpen(false)}
+        aria-labelledby="alert-dialog-title"
+        aria-describedby="alert-dialog-description"
+      >
+        <DialogTitle id="alert-dialog-title">{"Delete Post?"}</DialogTitle>
+        <DialogContent>
+          <DialogContentText id="alert-dialog-description">
+            Are you sure you want to delete this post? This action cannot be
+            undone.
+          </DialogContentText>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={() => setDeleteDialogOpen(false)} color="primary">
+            Cancel
+          </Button>
+          <Button
+            onClick={async () => {
+              setDeleteDialogOpen(false);
+              if (!backendActor || !postToDelete) return;
+              try {
+                const result = await backendActor.delete_post(postToDelete);
+                if ("Ok" in result) {
+                  const updatedPosts = posts.filter(
+                    (post) => post.id !== postToDelete,
+                  );
+                  setPosts(updatedPosts);
+                }
+              } catch (err) {
+                console.error("Error deleting post:", err);
+              } finally {
+                setIsDeletingPost(null);
+                setPostToDelete(null);
+              }
+            }}
+            color="error"
+            autoFocus
+          >
+            Delete
+          </Button>
+        </DialogActions>
+      </Dialog>
+      <CreatePost
+        key={isPosting}
+        ref={createPostRef}
+        onSubmit={handleNewPost}
+        isPosting={isPosting}
+      />
+
+      <SearchField
+        searchQuery={searchQuery}
+        setSearchQuery={setSearchQuery}
+        selectedTags={selectedTags}
+        setSelectedTags={setSelectedTags}
+      />
+
+      {filteredPosts.map((post: PostUser) => (
+        <Card key={post.id} sx={{ mb: 2 }}>
+          <CardHeader
+            avatar={post.creator && <UserAvatarMenu user={post.creator} />}
+            title={post.creator && post.creator.name}
+            subheader={new Date(
+              Number(post.date_created) / 1e6,
+            ).toLocaleString()}
+          />
+          <CardContent>
+            {post.content_tree && post.content_tree.length > 0 ? (
+              <EditorComponent
+                readOnly={
+                  post && post.creator?.id && post.creator.id !== profile?.id
+                }
+                content={deserializeContentTree(post.content_tree)}
+                onChange={(changes) => {
+                  let new_change = {};
+                  new_change[""] = changes;
+                  setNewPostContent(new_change);
+                }}
+              />
+            ) : (
+              <Typography variant="body2" color="text.secondary">
+                No content
+              </Typography>
+            )}
+
+            <Box sx={{ mb: 2 }}>
+              {post.tags.map((tag) => (
+                <Chip
+                  key={tag}
+                  label={tag}
+                  size="small"
+                  sx={{ mr: 1, mb: 1 }}
+                  onDelete={
+                    post.creator?.id === profile?.id
+                      ? () => {
+                          const updatedPost = {
+                            ...post,
+                            tags: post.tags.filter((t) => t !== tag),
+                          };
+                          handleSavePost(updatedPost);
+                        }
+                      : undefined
+                  }
+                />
+              ))}
+              {post.creator?.id === profile?.id && (
+                <Box
+                  sx={{ display: "inline-flex", alignItems: "center", gap: 1 }}
+                >
+                  <TextField
+                    size="small"
+                    placeholder="Add tag..."
+                    value={tagInputs[post.id] || ""}
+                    onChange={(e) =>
+                      setTagInputs((prev) => ({
+                        ...prev,
+                        [post.id]: e.target.value,
+                      }))
+                    }
+                    onKeyPress={(e) => {
+                      if (e.key === "Enter" && tagInputs[post.id]?.trim()) {
+                        const updatedPost = {
+                          ...post,
+                          tags: [
+                            ...new Set([
+                              ...post.tags,
+                              tagInputs[post.id].trim(),
+                            ]),
+                          ],
+                        };
+                        handleSavePost(updatedPost);
+                        setTagInputs((prev) => ({ ...prev, [post.id]: "" }));
+                      }
+                    }}
+                    sx={{ width: 120 }}
+                  />
+                  <Button
+                    variant="outlined"
+                    size="small"
+                    onClick={() => {
+                      if (tagInputs[post.id]?.trim()) {
+                        const updatedPost = {
+                          ...post,
+                          tags: [
+                            ...new Set([
+                              ...post.tags,
+                              tagInputs[post.id].trim(),
+                            ]),
+                          ],
+                        };
+                        handleSavePost(updatedPost);
+                        setTagInputs((prev) => ({ ...prev, [post.id]: "" }));
+                      }
+                    }}
+                  >
+                    Add Tag
+                  </Button>
+                </Box>
+              )}
+            </Box>
+            <Box
+              sx={{ display: "flex", justifyContent: "space-between", mt: 2 }}
+            >
+              <Box sx={{ display: "flex", gap: 1 }}>
+                {post.creator?.id === profile?.id && (
+                  <>
+                    <Button
+                      onClick={() => handleDeletePost(post.id)}
+                      color="error"
+                      size="small"
+                      disabled={isDeletingPost === post.id}
+                    >
+                      {isDeletingPost === post.id ? "Deleting..." : "Delete"}
+                    </Button>
+
+                    <Button
+                      onClick={() => handleSavePost(post)}
+                      color="primary"
+                      size="small"
+                      disabled={isSaving}
+                    >
+                      {isSaving ? "Saving..." : "Save"}
+                    </Button>
+                  </>
+                )}
+                <Button
+                  startIcon={<HeartIcon />}
+                  onClick={() => handleVoteUp(post.id)}
+                  color={
+                    post.votes_up.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "primary"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_up.length}
+                </Button>
+                <Button
+                  startIcon={<ThumbsDownIcon />}
+                  onClick={() => handleVoteDown(post.id)}
+                  color={
+                    post.votes_down.some(
+                      (p) =>
+                        p.toString() ===
+                        Principal.fromText("2vxsx-fae").toString(),
+                    )
+                      ? "error"
+                      : "inherit"
+                  }
+                >
+                  {post.votes_down.length}
+                </Button>
+                <Button
+                  startIcon={<MessageCircleIcon />}
+                  onClick={() => toggleComments(post.id)}
+                >
+                  {post.comments && post.comments.length}
+                </Button>
+              </Box>
+              <IconButton onClick={() => handleShare(post.id)}>
+                <ShareIcon />
+              </IconButton>
+            </Box>
+
+            {showComments[post.id] && (
+              <Box sx={{ mt: 2 }}>
+                <Box sx={{ display: "flex", gap: 1, mb: 2 }}>
+                  <TextField
+                    size="small"
+                    fullWidth
+                    placeholder="Write a comment..."
+                    value={commentInputs[post.id] || ""}
+                    onChange={(e) =>
+                      setCommentInputs((prev) => ({
+                        ...prev,
+                        [post.id]: e.target.value,
+                      }))
+                    }
+                  />
+                  <IconButton
+                    onClick={() => handleComment(post.id)}
+                    color="primary"
+                  >
+                    <SendIcon />
+                  </IconButton>
+                </Box>
+
+                <Box sx={{ mt: 2 }}>
+                  {post.comments &&
+                    post.comments.map((comment) => (
+                      <Comment
+                        key={comment.id}
+                        comment={comment}
+                        onReply={(commentId, content) =>
+                          handleReply(post.id, commentId, content)
+                        }
+                      />
+                    ))}
+                </Box>
+              </Box>
+            )}
+          </CardContent>
+        </Card>
+      ))}
+    </Box>
+  );
+};
+
+export default SocialPosts;
+

# 2024-12-23 22:31:41.732731
+after rename workspace and click on check mark show progress loader

# 2024-12-23 22:34:20.574174
+for ChatWindow if the name of that chat ===private_chat show the name of the other user instead 

# 2024-12-23 22:34:33.356060
+import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+} from "@mui/material";
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import {Link} from "react-router-dom";
+
+const ChatWindow = memo(
+  ({ chat, onClose, position, onPositionChange, onSendMessage }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+
+    const [isSettingsOpen, setIsSettingsOpen] = useState(false);
+
+    const messagesEndRef = useRef(null);
+    const { backendActor } = useBackendContext();
+    const { all_friends, profile } = useSelector((state) => state.filesState);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            <IconButton size="small" onClick={() => setIsSettingsOpen(true)}>
+              <SettingsIcon />
+            </IconButton>
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography to={`user?id=${message.sender.toString()}`} component={Link}  variant="subtitle2">
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+

# 2024-12-23 22:34:54.005820
+no

# 2024-12-23 22:35:06.477266
+just modify the file /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx

# 2024-12-23 22:35:18.427773
+y

# 2024-12-23 22:36:42.162571
+/undo 

# 2024-12-23 22:38:09.649175
+import React, { memo, useCallback, useMemo, useState } from "react";
+import {
+  Autocomplete,
+  Avatar,
+  Badge,
+  Box,
+  Button,
+  Chip,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogTitle,
+  FormControl,
+  IconButton,
+  InputLabel,
+  List,
+  ListItem,
+  ListItemAvatar,
+  ListItemText,
+  Menu,
+  MenuItem,
+  Select,
+  TextField,
+  Typography,
+} from "@mui/material";
+
+import {
+  Add as AddIcon,
+  Chat as ChatIcon,
+  Group as GroupIcon,
+} from "@mui/icons-material";
+import ChatWindow from "./chatWindow";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import formatTimestamp from "../../utils/time";
+import { Chat, Message } from "../../../declarations/backend/backend.did";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+
+// Memoized form components
+const GroupNameField = memo(({ value, onChange }) => (
+  <TextField
+    label="Group Name"
+    value={value}
+    onChange={(e) => onChange(e.target.value)}
+    fullWidth
+  />
+));
+
+export const MembersSelect = memo(({ value, onChange, users }) => (
+  <Autocomplete
+    multiple
+    options={users}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Members" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const AdminsSelect = memo(({ value, onChange, members }) => (
+  <Autocomplete
+    multiple
+    options={members}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Admins" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+const WorkspaceSelect = memo(({ value, onChange, workspaces }) => (
+  <FormControl fullWidth>
+    <InputLabel>Workspace</InputLabel>
+    <Select
+      value={value}
+      label="Workspace"
+      onChange={(e) => onChange(e.target.value)}
+    >
+      {workspaces.map((workspace) => (
+        <MenuItem key={workspace.id} value={workspace.id}>
+          {workspace.name}
+        </MenuItem>
+      ))}
+    </Select>
+  </FormControl>
+));
+
+// Memoized Create Group Dialog
+const CreateGroupDialog = memo(
+  ({ open, onClose, onSubmit, initialData, users, workspaces }) => {
+    const [formData, setFormData] = useState(initialData);
+
+    const handleNameChange = useCallback((name) => {
+      setFormData((prev) => ({ ...prev, name }));
+    }, []);
+
+    const handleMembersChange = useCallback((members) => {
+      setFormData((prev) => ({ ...prev, members }));
+    }, []);
+
+    const handleAdminsChange = useCallback((admins) => {
+      setFormData((prev) => ({ ...prev, admins }));
+    }, []);
+
+    const handleWorkspaceChange = useCallback((workspace) => {
+      setFormData((prev) => ({ ...prev, workspace }));
+    }, []);
+
+    const handleSubmit = useCallback(() => {
+      onSubmit(formData);
+    }, [formData, onSubmit]);
+
+    return (
+      <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
+        <DialogTitle>Create New Group Chat</DialogTitle>
+        <DialogContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}>
+            <GroupNameField value={formData.name} onChange={handleNameChange} />
+            <MembersSelect
+              value={formData.members}
+              onChange={handleMembersChange}
+              users={users}
+            />
+            <AdminsSelect
+              value={formData.admins}
+              onChange={handleAdminsChange}
+              members={formData.members}
+            />
+            <WorkspaceSelect
+              value={formData.workspace}
+              onChange={handleWorkspaceChange}
+              workspaces={workspaces}
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={onClose}>Cancel</Button>
+          <Button onClick={handleSubmit} variant="contained" color="primary">
+            Create Group
+          </Button>
+        </DialogActions>
+      </Dialog>
+    );
+  },
+);
+
+const ChatList = memo(
+  ({
+    chats,
+    onChatClick,
+    currentUserId,
+  }: {
+    chats: Chat[];
+    onChatClick: (chat: Chat) => void;
+    currentUserId: string;
+  }) => {
+    // Calculate unread count for each chat if not already present
+    const chatsWithUnread = chats.map((chat) => {
+      if ("unread" in chat) return chat;
+
+      const unseenCount = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === currentUserId,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+
+      return {
+        ...chat,
+        unread: unseenCount,
+      };
+    });
+
+    return (
+      <List sx={{ padding: 0, width: "100%" }}>
+        {chatsWithUnread.map((chat) => (
+          <ListItem
+            key={chat.id}
+            onClick={() => onChatClick(chat)}
+            button
+            sx={{
+              borderBottom: 1,
+              borderColor: "divider",
+              "&:hover": { backgroundColor: "action.hover" },
+            }}
+          >
+            <ListItemAvatar>
+              <Avatar>
+                <GroupIcon />
+              </Avatar>
+            </ListItemAvatar>
+            <ListItemText
+              primary={
+                <Box sx={{ display: "flex", justifyContent: "space-between" }}>
+                  <Typography variant="subtitle2">{chat.name}</Typography>
+                  {chat.unread > 0 && (
+                    <Badge badgeContent={chat.unread} color="error" />
+                  )}
+                </Box>
+              }
+              secondary={
+                chat.messages[chat.messages.length - 1]?.message ||
+                "No messages"
+              }
+            />
+          </ListItem>
+        ))}
+      </List>
+    );
+  },
+);
+
+const ChatNotifications = ({ chats: initialChats }: { chats: Chat[] }) => {
+  const [openChats, setOpenChats] = useState(
+    new Map<string, { x: number; y: number }>(),
+  );
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [createGroupOpen, setCreateGroupOpen] = useState(false);
+  const [chats, setChats] = useState<Chat[]>(initialChats || []);
+
+  const { backendActor } = useBackendContext();
+  const { profile } = useSelector((state: any) => state.filesState);
+
+  // Calculate total unseen messages across all chats
+  const totalUnseenMessages = useMemo(() => {
+    if (!profile?.id) return 0;
+
+    return chats.reduce((total, chat) => {
+      const unseenInChat = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === profile.id,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+      return total + unseenInChat;
+    }, 0);
+  }, [chats, profile?.id]);
+
+  const handleOpenChat = useCallback((chat: Chat) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      if (!newChats.has(chat.id)) {
+        const offset = newChats.size * 30;
+        newChats.set(chat.id, {
+          x: 100 + offset,
+          y: 100 + offset,
+        });
+      }
+      return newChats;
+    });
+  }, []);
+
+  const handleCloseChat = useCallback((chatId: string) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      newChats.delete(chatId);
+      return newChats;
+    });
+  }, []);
+
+  const handleChatPosition = useCallback(
+    (chatId: string, position: { x: number; y: number }) => {
+      setOpenChats((prev) => {
+        const newChats = new Map(prev);
+        newChats.set(chatId, position);
+        return newChats;
+      });
+    },
+    [],
+  );
+
+  const handleClick = useCallback(
+    (event: React.MouseEvent<HTMLButtonElement>) => {
+      setAnchorEl(event.currentTarget);
+    },
+    [],
+  );
+
+  const handleClose = useCallback(() => {
+    setAnchorEl(null);
+  }, []);
+
+  const handleChatClick = useCallback(
+    async (chat: Chat) => {
+      try {
+        // Get latest unseen message
+        const unseenMessages = chat.messages.filter((message) => {
+          const isSeen = message.seen_by.some(
+            (user) => user.toString() === profile?.id,
+          );
+          return !isSeen;
+        });
+
+        // Update local state immediately
+        setChats((prevChats) =>
+          prevChats.map((prevChat) => {
+            if (prevChat.id !== chat.id) return prevChat;
+
+            // Update all messages' seen status for this chat
+            const updatedMessages = prevChat.messages.map((msg) => ({
+              ...msg,
+              seen_by: msg.seen_by.some(
+                (user) => user.toString() === profile?.id,
+              )
+                ? msg.seen_by
+                : [...msg.seen_by, Principal.fromText(profile?.id)],
+            }));
+
+            return {
+              ...prevChat,
+              messages: updatedMessages,
+              unread: 0, // Add unread property and set to 0
+            };
+          }),
+        );
+
+        // Call backend if there are unseen messages
+
+        handleOpenChat(chat);
+        handleClose();
+
+        if (unseenMessages.length > 0) {
+          const latestMessage = unseenMessages[unseenMessages.length - 1];
+          const messageForBackend = {
+            ...latestMessage,
+            date: BigInt(0),
+            sender: Principal.fromText(latestMessage.sender.toString()),
+            seen_by: [],
+            chat_id: chat.id,
+          };
+
+          await backendActor?.message_is_seen(messageForBackend);
+        }
+      } catch (error) {
+        console.error("Error marking messages as seen:", error);
+        handleOpenChat(chat);
+        handleClose();
+      }
+    },
+    [profile?.id, backendActor, handleOpenChat, handleClose],
+  );
+
+  const handleCreateGroup = useCallback((formData: any) => {
+    console.log("Creating new group:", formData);
+    setCreateGroupOpen(false);
+  }, []);
+
+  const handleSendMessage = useCallback(
+    async (chatId: string, messageText: string) => {
+      if (!profile?.id || !messageText.trim()) return;
+
+      const chat = chats.find((c) => c.id === chatId);
+      if (!chat) return;
+
+      const newMessage: Message = {
+        id: randomString(),
+        date: BigInt(Date.now() * 1e6),
+        sender: Principal.fromText(profile.id),
+        seen_by: [Principal.fromText(profile.id)],
+        message: messageText, // Use the actual message text
+        chat_id: chatId,
+      };
+
+      try {
+        // Send message to backend with recipients
+        const res = await backendActor?.send_message([], newMessage);
+        // console.log("Message sent:", { res });
+
+        // Update local state
+        setChats((prevChats) =>
+          prevChats.map((chat) =>
+            chat.id === chatId
+              ? { ...chat, messages: [...chat.messages, newMessage] }
+              : chat,
+          ),
+        );
+      } catch (error) {
+        console.error("Error sending message:", error);
+      }
+    },
+    [profile, backendActor, chats],
+  );
+
+  const open = anchorEl && Boolean(anchorEl);
+
+  return (
+    <>
+      <IconButton
+        onClick={handleClick}
+        aria-controls={open ? "chat-menu" : undefined}
+        aria-haspopup="true"
+        aria-expanded={open ? "true" : undefined}
+      >
+        <Badge  badgeContent={totalUnseenMessages} color="error">
+          <ChatIcon />
+        </Badge>
+      </IconButton>
+
+      <Menu
+        id="chat-menu"
+        anchorEl={anchorEl}
+        open={open}
+        onClose={handleClose}
+        PaperProps={{
+          sx: {
+            maxHeight: 500,
+            width: 320,
+          },
+        }}
+        transformOrigin={{ horizontal: "right", vertical: "top" }}
+        anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
+      >
+        <MenuItem sx={{ justifyContent: "center" }}>
+          <Button
+            startIcon={<AddIcon />}
+            variant="outlined"
+            fullWidth
+            onClick={() => setCreateGroupOpen(true)}
+          >
+            Create New Group
+          </Button>
+        </MenuItem>
+
+        <ChatList
+          chats={chats}
+          onChatClick={handleChatClick}
+          currentUserId={profile?.id}
+        />
+      </Menu>
+
+      {Array.from(openChats.entries()).map(([chatId, position]) => {
+        const chat = chats.find((c) => c.id === chatId);
+        if (!chat) return null;
+
+        return (
+          <ChatWindow
+            key={chatId}
+            chat={chat}
+            position={position}
+            onClose={handleCloseChat}
+            onPositionChange={handleChatPosition}
+            onSendMessage={(currentChatId, message) =>
+              handleSendMessage(chatId, message)
+            }
+            user={profile}
+          />
+        );
+      })}
+
+      <CreateGroupDialog
+        open={createGroupOpen}
+        onClose={() => setCreateGroupOpen(false)}
+        onSubmit={handleCreateGroup}
+        initialData={{
+          name: "",
+          members: [],
+          admins: [],
+          workspace: "",
+        }}
+        users={[]}
+        workspaces={[]}
+      />
+    </>
+  );
+};
+
+export default ChatNotifications;
+here if .name== private_chat show the name of the user and show user avatarinstead, or  otherwise show group chat

# 2024-12-23 22:39:45.891147
+no apply this to /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/index.tsx not /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx undo that 

# 2024-12-23 22:39:59.590854
+how to do that?

# 2024-12-23 22:40:06.952520
+y

# 2024-12-23 22:40:06.957388
+/run cat src/frontend/components/Chat/index.tsx

# 2024-12-23 22:40:06.957487
+/run cat src/frontend/components/Chat/index.tsx

# 2024-12-23 22:40:09.215993
+y

# 2024-12-23 22:40:22.818948
+import React, { memo, useCallback, useMemo, useState } from "react";
+import {
+  Autocomplete,
+  Avatar,
+  Badge,
+  Box,
+  Button,
+  Chip,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogTitle,
+  FormControl,
+  IconButton,
+  InputLabel,
+  List,
+  ListItem,
+  ListItemAvatar,
+  ListItemText,
+  Menu,
+  MenuItem,
+  Select,
+  TextField,
+  Typography,
+} from "@mui/material";
+
+import {
+  Add as AddIcon,
+  Chat as ChatIcon,
+  Group as GroupIcon,
+} from "@mui/icons-material";
+import ChatWindow from "./chatWindow";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import formatTimestamp from "../../utils/time";
+import { Chat, Message } from "../../../declarations/backend/backend.did";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+
+// Memoized form components
+const GroupNameField = memo(({ value, onChange }) => (
+  <TextField
+    label="Group Name"
+    value={value}
+    onChange={(e) => onChange(e.target.value)}
+    fullWidth
+  />
+));
+
+export const MembersSelect = memo(({ value, onChange, users }) => (
+  <Autocomplete
+    multiple
+    options={users}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Members" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const AdminsSelect = memo(({ value, onChange, members }) => (
+  <Autocomplete
+    multiple
+    options={members}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Admins" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+const WorkspaceSelect = memo(({ value, onChange, workspaces }) => (
+  <FormControl fullWidth>
+    <InputLabel>Workspace</InputLabel>
+    <Select
+      value={value}
+      label="Workspace"
+      onChange={(e) => onChange(e.target.value)}
+    >
+      {workspaces.map((workspace) => (
+        <MenuItem key={workspace.id} value={workspace.id}>
+          {workspace.name}
+        </MenuItem>
+      ))}
+    </Select>
+  </FormControl>
+));
+
+// Memoized Create Group Dialog
+const CreateGroupDialog = memo(
+  ({ open, onClose, onSubmit, initialData, users, workspaces }) => {
+    const [formData, setFormData] = useState(initialData);
+
+    const handleNameChange = useCallback((name) => {
+      setFormData((prev) => ({ ...prev, name }));
+    }, []);
+
+    const handleMembersChange = useCallback((members) => {
+      setFormData((prev) => ({ ...prev, members }));
+    }, []);
+
+    const handleAdminsChange = useCallback((admins) => {
+      setFormData((prev) => ({ ...prev, admins }));
+    }, []);
+
+    const handleWorkspaceChange = useCallback((workspace) => {
+      setFormData((prev) => ({ ...prev, workspace }));
+    }, []);
+
+    const handleSubmit = useCallback(() => {
+      onSubmit(formData);
+    }, [formData, onSubmit]);
+
+    return (
+      <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
+        <DialogTitle>Create New Group Chat</DialogTitle>
+        <DialogContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}>
+            <GroupNameField value={formData.name} onChange={handleNameChange} />
+            <MembersSelect
+              value={formData.members}
+              onChange={handleMembersChange}
+              users={users}
+            />
+            <AdminsSelect
+              value={formData.admins}
+              onChange={handleAdminsChange}
+              members={formData.members}
+            />
+            <WorkspaceSelect
+              value={formData.workspace}
+              onChange={handleWorkspaceChange}
+              workspaces={workspaces}
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={onClose}>Cancel</Button>
+          <Button onClick={handleSubmit} variant="contained" color="primary">
+            Create Group
+          </Button>
+        </DialogActions>
+      </Dialog>
+    );
+  },
+);
+
+const ChatList = memo(
+  ({
+    chats,
+    onChatClick,
+    currentUserId,
+  }: {
+    chats: Chat[];
+    onChatClick: (chat: Chat) => void;
+    currentUserId: string;
+  }) => {
+    // Calculate unread count for each chat if not already present
+    const chatsWithUnread = chats.map((chat) => {
+      if ("unread" in chat) return chat;
+
+      const unseenCount = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === currentUserId,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+
+      return {
+        ...chat,
+        unread: unseenCount,
+      };
+    });
+
+    return (
+      <List sx={{ padding: 0, width: "100%" }}>
+        {chatsWithUnread.map((chat) => (
+          <ListItem
+            key={chat.id}
+            onClick={() => onChatClick(chat)}
+            button
+            sx={{
+              borderBottom: 1,
+              borderColor: "divider",
+              "&:hover": { backgroundColor: "action.hover" },
+            }}
+          >
+            <ListItemAvatar>
+              <Avatar>
+                <GroupIcon />
+              </Avatar>
+            </ListItemAvatar>
+            <ListItemText
+              primary={
+                <Box sx={{ display: "flex", justifyContent: "space-between" }}>
+                  <Typography variant="subtitle2">{chat.name}</Typography>
+                  {chat.unread > 0 && (
+                    <Badge badgeContent={chat.unread} color="error" />
+                  )}
+                </Box>
+              }
+              secondary={
+                chat.messages[chat.messages.length - 1]?.message ||
+                "No messages"
+              }
+            />
+          </ListItem>
+        ))}
+      </List>
+    );
+  },
+);
+
+const ChatNotifications = ({ chats: initialChats }: { chats: Chat[] }) => {
+  const [openChats, setOpenChats] = useState(
+    new Map<string, { x: number; y: number }>(),
+  );
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [createGroupOpen, setCreateGroupOpen] = useState(false);
+  const [chats, setChats] = useState<Chat[]>(initialChats || []);
+
+  const { backendActor } = useBackendContext();
+  const { profile } = useSelector((state: any) => state.filesState);
+
+  // Calculate total unseen messages across all chats
+  const totalUnseenMessages = useMemo(() => {
+    if (!profile?.id) return 0;
+
+    return chats.reduce((total, chat) => {
+      const unseenInChat = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === profile.id,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+      return total + unseenInChat;
+    }, 0);
+  }, [chats, profile?.id]);
+
+  const handleOpenChat = useCallback((chat: Chat) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      if (!newChats.has(chat.id)) {
+        const offset = newChats.size * 30;
+        newChats.set(chat.id, {
+          x: 100 + offset,
+          y: 100 + offset,
+        });
+      }
+      return newChats;
+    });
+  }, []);
+
+  const handleCloseChat = useCallback((chatId: string) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      newChats.delete(chatId);
+      return newChats;
+    });
+  }, []);
+
+  const handleChatPosition = useCallback(
+    (chatId: string, position: { x: number; y: number }) => {
+      setOpenChats((prev) => {
+        const newChats = new Map(prev);
+        newChats.set(chatId, position);
+        return newChats;
+      });
+    },
+    [],
+  );
+
+  const handleClick = useCallback(
+    (event: React.MouseEvent<HTMLButtonElement>) => {
+      setAnchorEl(event.currentTarget);
+    },
+    [],
+  );
+
+  const handleClose = useCallback(() => {
+    setAnchorEl(null);
+  }, []);
+
+  const handleChatClick = useCallback(
+    async (chat: Chat) => {
+      try {
+        // Get latest unseen message
+        const unseenMessages = chat.messages.filter((message) => {
+          const isSeen = message.seen_by.some(
+            (user) => user.toString() === profile?.id,
+          );
+          return !isSeen;
+        });
+
+        // Update local state immediately
+        setChats((prevChats) =>
+          prevChats.map((prevChat) => {
+            if (prevChat.id !== chat.id) return prevChat;
+
+            // Update all messages' seen status for this chat
+            const updatedMessages = prevChat.messages.map((msg) => ({
+              ...msg,
+              seen_by: msg.seen_by.some(
+                (user) => user.toString() === profile?.id,
+              )
+                ? msg.seen_by
+                : [...msg.seen_by, Principal.fromText(profile?.id)],
+            }));
+
+            return {
+              ...prevChat,
+              messages: updatedMessages,
+              unread: 0, // Add unread property and set to 0
+            };
+          }),
+        );
+
+        // Call backend if there are unseen messages
+
+        handleOpenChat(chat);
+        handleClose();
+
+        if (unseenMessages.length > 0) {
+          const latestMessage = unseenMessages[unseenMessages.length - 1];
+          const messageForBackend = {
+            ...latestMessage,
+            date: BigInt(0),
+            sender: Principal.fromText(latestMessage.sender.toString()),
+            seen_by: [],
+            chat_id: chat.id,
+          };
+
+          await backendActor?.message_is_seen(messageForBackend);
+        }
+      } catch (error) {
+        console.error("Error marking messages as seen:", error);
+        handleOpenChat(chat);
+        handleClose();
+      }
+    },
+    [profile?.id, backendActor, handleOpenChat, handleClose],
+  );
+
+  const handleCreateGroup = useCallback((formData: any) => {
+    console.log("Creating new group:", formData);
+    setCreateGroupOpen(false);
+  }, []);
+
+  const handleSendMessage = useCallback(
+    async (chatId: string, messageText: string) => {
+      if (!profile?.id || !messageText.trim()) return;
+
+      const chat = chats.find((c) => c.id === chatId);
+      if (!chat) return;
+
+      const newMessage: Message = {
+        id: randomString(),
+        date: BigInt(Date.now() * 1e6),
+        sender: Principal.fromText(profile.id),
+        seen_by: [Principal.fromText(profile.id)],
+        message: messageText, // Use the actual message text
+        chat_id: chatId,
+      };
+
+      try {
+        // Send message to backend with recipients
+        const res = await backendActor?.send_message([], newMessage);
+        // console.log("Message sent:", { res });
+
+        // Update local state
+        setChats((prevChats) =>
+          prevChats.map((chat) =>
+            chat.id === chatId
+              ? { ...chat, messages: [...chat.messages, newMessage] }
+              : chat,
+          ),
+        );
+      } catch (error) {
+        console.error("Error sending message:", error);
+      }
+    },
+    [profile, backendActor, chats],
+  );
+
+  const open = anchorEl && Boolean(anchorEl);
+
+  return (
+    <>
+      <IconButton
+        onClick={handleClick}
+        aria-controls={open ? "chat-menu" : undefined}
+        aria-haspopup="true"
+        aria-expanded={open ? "true" : undefined}
+      >
+        <Badge  badgeContent={totalUnseenMessages} color="error">
+          <ChatIcon />
+        </Badge>
+      </IconButton>
+
+      <Menu
+        id="chat-menu"
+        anchorEl={anchorEl}
+        open={open}
+        onClose={handleClose}
+        PaperProps={{
+          sx: {
+            maxHeight: 500,
+            width: 320,
+          },
+        }}
+        transformOrigin={{ horizontal: "right", vertical: "top" }}
+        anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
+      >
+        <MenuItem sx={{ justifyContent: "center" }}>
+          <Button
+            startIcon={<AddIcon />}
+            variant="outlined"
+            fullWidth
+            onClick={() => setCreateGroupOpen(true)}
+          >
+            Create New Group
+          </Button>
+        </MenuItem>
+
+        <ChatList
+          chats={chats}
+          onChatClick={handleChatClick}
+          currentUserId={profile?.id}
+        />
+      </Menu>
+
+      {Array.from(openChats.entries()).map(([chatId, position]) => {
+        const chat = chats.find((c) => c.id === chatId);
+        if (!chat) return null;
+
+        return (
+          <ChatWindow
+            key={chatId}
+            chat={chat}
+            position={position}
+            onClose={handleCloseChat}
+            onPositionChange={handleChatPosition}
+            onSendMessage={(currentChatId, message) =>
+              handleSendMessage(chatId, message)
+            }
+            user={profile}
+          />
+        );
+      })}
+
+      <CreateGroupDialog
+        open={createGroupOpen}
+        onClose={() => setCreateGroupOpen(false)}
+        onSubmit={handleCreateGroup}
+        initialData={{
+          name: "",
+          members: [],
+          admins: [],
+          workspace: "",
+        }}
+        users={[]}
+        workspaces={[]}
+      />
+    </>
+  );
+};
+
+export default ChatNotifications;
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/index.tsx

# 2024-12-23 22:41:06.966589
+y

# 2024-12-23 22:41:38.031764
+[plugin:vite:esbuild] Transform failed with 1 error:
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/index.tsx:240:9: ERROR: Expected ";" but found ")"
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/index.tsx:240:9
+Expected ";" but found ")"
+238|              />
+239|            </ListItem>
+240|          ))}
+   |           ^
+241|        </List>
+242|      );

# 2024-12-23 22:49:02.928222
+When user click settings i should be able to see the window for chaning members, name, workspace etc ..

# 2024-12-23 22:51:46.995622
+when Create New Group Chat
+ call backend make_new_chat_room(mut chat: Chat)

# 2024-12-23 22:56:40.851473
+now enable user to update workspaces and chat name if it is not chatn.name==private_chat at ChatWindow

# 2024-12-23 22:59:58.999355
+import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+} from "@mui/material";
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import {Link} from "react-router-dom";
+
+const ChatWindow = memo(
+  ({ chat, onClose, position, onPositionChange, onSendMessage }) => {
+    const [isDragging, setIsDragging] = useState(false);
+  
+    useEffect(() => {
+      setEditedChat(chat);
+    }, [chat]);
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+
+    const [isSettingsOpen, setIsSettingsOpen] = useState(false);
+    const [editedChat, setEditedChat] = useState(null);
+    const { backendActor } = useBackendContext();
+
+    const messagesEndRef = useRef(null);
+    const { all_friends, profile } = useSelector((state) => state.filesState);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            <IconButton size="small" onClick={() => setIsSettingsOpen(true)}>
+              <SettingsIcon />
+            </IconButton>
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography to={`user?id=${message.sender.toString()}`} component={Link}  variant="subtitle2">
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+ as user click on <IconButton size="small" onClick={() => setIsSettingsOpen(true)}>
+              <SettingsIcon />
+            </IconButton> should be able to see the settings like workspaces and members and should be able to update them and hit save and call backentactor update_chat(mut chat: Chat)

# 2024-12-23 23:00:31.653536
+[plugin:vite:esbuild] Transform failed with 1 error:
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:260:14: ERROR: Expected ")" but found "open"
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:260:14
+Expected ")" but found "open"
+258|        </Paper>
+259|  
+260|        <Dialog open={isSettingsOpen} onClose={() => setIsSettingsOpen(false)}>
+   |                ^
+261|          <DialogTitle>Chat Settings</DialogTitle>
+262|          <DialogContent>

# 2024-12-23 23:01:21.688402
+[plugin:vite:esbuild] Transform failed with 1 error:
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:260:8: ERROR: Expected ")" but found "open"
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:260:8
+Expected ")" but found "open"
+258|        </Paper>
+259|        <Dialog 
+260|          open={isSettingsOpen} 
+   |          ^
+261|          onClose={() => setIsSettingsOpen(false)}
+262|        >

# 2024-12-23 23:02:42.180032
+[plugin:vite:esbuild] Transform failed with 1 error:
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:261:8: ERROR: Expected ")" but found "open"
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:261:8
+Expected ")" but found "open"
+259|  
+260|        <Dialog 
+261|          open={isSettingsOpen} 
+   |          ^
+262|          onClose={() => setIsSettingsOpen(false)}
+263|        >
+

# 2024-12-23 23:02:57.388396
+[plugin:vite:esbuild] Transform failed with 1 error:
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:259:12: ERROR: Unterminated regular expression
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:259:12
+Unterminated regular expression
+257|          )}
+258|        </Paper>
+259|      </Paper>
+   |              ^
+260|  
+261|      <Dialog

# 2024-12-24 15:23:54.644822
+in that chatWindow as users click on the button `<IconButton size="small" onClick={() => setIsSettingsOpen(true)}>
+              <SettingsIcon />
+            </IconButton>` it should change the window view from messaging window to settings window where users can change workspaes, and members of that chat and hit save, then user can click on the back icon to go back to that chat. here is the file /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx

# 2024-12-24 15:26:05.379171
+why there is a reptition in this part const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [selectedWorkspace, setSelectedWorkspace] = useState(chat.workspaces[0] || "");
+    const [editedMembers, setEditedMembers] = useState(chat.members);
+    const { workspaces, all_friends } = useSelector((state: any) => state.filesState);
+    const { backendActor } = useBackendContext();
+
+    useEffect(() => {
+      setEditedChat(chat);
+      setSelectedWorkspace(chat.workspaces[0] || "");
+      setEditedMembers(chat.members);
+    }, [chat]);
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+
+    const [isSettingsOpen, setIsSettingsOpen] = useState(false);
+    const [editedChat, setEditedChat] = useState(null);
+
+    const messagesEndRef = useRef(null);
+    const { backendActor } = useBackendContext();
+    const { all_friends, profile } = useSelector((state) => state.filesState);
+``` here is my full code import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+} from "@mui/material";
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+  ArrowBack as ArrowBackIcon,
+  Delete as DeleteIcon,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import {Link} from "react-router-dom";
+
+const ChatWindow = memo(
+  ({ chat, onClose, position, onPositionChange, onSendMessage, onUpdateChat }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [selectedWorkspace, setSelectedWorkspace] = useState(chat.workspaces[0] || "");
+    const [editedMembers, setEditedMembers] = useState(chat.members);
+    const { workspaces, all_friends } = useSelector((state: any) => state.filesState);
+    const { backendActor } = useBackendContext();
+
+    useEffect(() => {
+      setEditedChat(chat);
+      setSelectedWorkspace(chat.workspaces[0] || "");
+      setEditedMembers(chat.members);
+    }, [chat]);
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+
+    const [isSettingsOpen, setIsSettingsOpen] = useState(false);
+    const [editedChat, setEditedChat] = useState(null);
+
+    const messagesEndRef = useRef(null);
+    const { backendActor } = useBackendContext();
+    const { all_friends, profile } = useSelector((state) => state.filesState);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            {isSettingsView ? (
+              <IconButton size="small" onClick={() => setIsSettingsView(false)}>
+                <ArrowBackIcon />
+              </IconButton>
+            ) : (
+              <IconButton size="small" onClick={() => setIsSettingsView(true)}>
+                <SettingsIcon />
+              </IconButton>
+            )}
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && !isSettingsView && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography to={`user?id=${message.sender.toString()}`} component={Link}  variant="subtitle2">
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+
+        {!isMinimized && isSettingsView && (
+          <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Chat Settings
+            </Typography>
+            
+            {chat.name !== "private_chat" && (
+              <>
+                <FormControl fullWidth sx={{ mb: 2 }}>
+                  <InputLabel>Workspace</InputLabel>
+                  <Select
+                    value={selectedWorkspace}
+                    label="Workspace"
+                    onChange={(e) => setSelectedWorkspace(e.target.value)}
+                  >
+                    {workspaces.map((workspace) => (
+                      <MenuItem key={workspace.id} value={workspace.id}>
+                        {workspace.name}
+                      </MenuItem>
+                    ))}
+                  </Select>
+                </FormControl>
+
+                <Typography variant="subtitle1" gutterBottom>
+                  Members
+                </Typography>
+                <List>
+                  {editedMembers.map((member) => {
+                    const user = all_friends.find(
+                      (f) => f.id === member.toString()
+                    );
+                    return (
+                      <ListItem key={member.toString()}>
+                        <ListItemText 
+                          primary={user?.name || member.toString().slice(0, 8)}
+                        />
+                        <ListItemSecondaryAction>
+                          <IconButton 
+                            edge="end" 
+                            onClick={() => {
+                              setEditedMembers(editedMembers.filter(
+                                m => m.toString() !== member.toString()
+                              ));
+                            }}
+                          >
+                            <DeleteIcon />
+                          </IconButton>
+                        </ListItemSecondaryAction>
+                      </ListItem>
+                    );
+                  })}
+                </List>
+
+                <Button
+                  variant="contained"
+                  color="primary"
+                  fullWidth
+                  sx={{ mt: 2 }}
+                  onClick={async () => {
+                    const updatedChat = {
+                      ...chat,
+                      workspaces: [selectedWorkspace],
+                      members: editedMembers
+                    };
+                    
+                    try {
+                      const result = await backendActor.update_chat(updatedChat);
+                      if ("Ok" in result) {
+                        if (onUpdateChat) {
+                          onUpdateChat(updatedChat);
+                        }
+                        setIsSettingsView(false);
+                      }
+                    } catch (error) {
+                      console.error("Failed to update chat:", error);
+                    }
+                  }}
+                >
+                  Save Changes
+                </Button>
+              </>
+            )}
+          </Box>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+```

# 2024-12-24 15:34:01.866366
+i modifed the code a little bit import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+  Button,
+} from "@mui/material";
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+  ArrowBack as ArrowBackIcon,
+  Delete as DeleteIcon,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import { Link } from "react-router-dom";
+import { Chat } from "../../../declarations/backend/backend.did";
+
+const ChatWindow = memo(
+  ({
+    chat,
+    onClose,
+    position,
+    onPositionChange,
+    onSendMessage,
+    onUpdateChat,
+  }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [selectedWorkspace, setSelectedWorkspace] = useState(
+      chat.workspaces[0] || "",
+    );
+    const [editedMembers, setEditedMembers] = useState(chat.members);
+    const { workspaces, all_friends, profile } = useSelector(
+      (state: any) => state.filesState,
+    );
+    const { backendActor } = useBackendContext();
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSaving] = useState(false);
+    const messagesEndRef = useRef(null);
+
+    useEffect(() => {
+      setSelectedWorkspace(chat.workspaces[0] || "");
+      setEditedMembers(chat.members);
+    }, [chat]);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            {isSettingsView ? (
+              <IconButton size="small" onClick={() => setIsSettingsView(false)}>
+                <ArrowBackIcon />
+              </IconButton>
+            ) : (
+              <IconButton size="small" onClick={() => setIsSettingsView(true)}>
+                <SettingsIcon />
+              </IconButton>
+            )}
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && !isSettingsView && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography
+                      to={`user?id=${message.sender.toString()}`}
+                      component={Link}
+                      variant="subtitle2"
+                    >
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+
+        {!isMinimized && isSettingsView && (
+          <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Chat Settings
+            </Typography>
+
+            {chat.name !== "private_chat" && (
+              <>
+                <FormControl fullWidth sx={{ mb: 2 }}>
+                  <InputLabel>Workspace</InputLabel>
+                  <Select
+                    value={selectedWorkspace}
+                    label="Workspace"
+                    onChange={(e) => setSelectedWorkspace(e.target.value)}
+                  >
+                    {workspaces.map((workspace) => (
+                      <MenuItem key={workspace.id} value={workspace.id}>
+                        {workspace.name}
+                      </MenuItem>
+                    ))}
+                  </Select>
+                </FormControl>
+
+                <Typography variant="subtitle1" gutterBottom>
+                  Members
+                </Typography>
+                <List>
+                  {editedMembers.map((member) => {
+                    const user = all_friends.find(
+                      (f) => f.id === member.toString(),
+                    );
+                    return (
+                      <ListItem key={member.toString()}>
+                        <ListItemText
+                          primary={user?.name || member.toString().slice(0, 8)}
+                        />
+                        <ListItemSecondaryAction>
+                          <IconButton
+                            edge="end"
+                            onClick={() => {
+                              setEditedMembers(
+                                editedMembers.filter(
+                                  (m) => m.toString() !== member.toString(),
+                                ),
+                              );
+                            }}
+                          >
+                            <DeleteIcon />
+                          </IconButton>
+                        </ListItemSecondaryAction>
+                      </ListItem>
+                    );
+                  })}
+                </List>
+
+                <Button
+                  variant="contained"
+                  color="primary"
+                  fullWidth
+                  sx={{ mt: 2 }}
+                  onClick={async () => {
+                    const updatedChat: Chat = {
+                      ...chat,
+                      admins: chat.admins.map((a) => Principal.fromText(a.id)),
+                      creator: Principal.fromText(chat.creator.id),
+                      workspaces: [selectedWorkspace],
+                      members: editedMembers,
+                    };
+
+                    try {
+                      console.log({ updatedChat });
+                      const result =
+                        await backendActor.update_chat(updatedChat);
+                      if ("Ok" in result) {
+                        if (onUpdateChat) {
+                          onUpdateChat(updatedChat);
+                        }
+                        setIsSettingsView(false);
+                      }
+                    } catch (error) {
+                      console.error("Failed to update chat:", error);
+                    }
+                  }}
+                >
+                  Save Changes
+                </Button>
+              </>
+            )}
+          </Box>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+pleease learn that for future refrences

# 2024-12-24 15:35:16.925184
+if chat.name!=private_chat then allow users to change name, workspaces, members, admins and delete the entire chat. if chat.name==private_chat then allow users to update the workspaces only

# 2024-12-24 15:38:15.669975
+there are two issues 1. when I try to type in the name input it does not change the text 2. I should be able to change the admins as well 3. do not allow users to click on the settings if creator.id !== profile.id 4. when user click on delete chat show them a conformation asking are you sure you want to delete that chat.

# 2024-12-24 15:47:28.744886
+after delete chat call the redux case DELETE_CHAT: {
+      const { chat_id } = action;
+      let current_chat_id = state.current_chat_id;
+      if (state.current_chat_id === chat_id) {
+        current_chat_id = "none";
+      }
+      return {
+        ...state,
+        chats: state.chats.filter((chat: FEChat) => chat.id !== chat_id),
+        current_chat_id,
+      };
+    }

# 2024-12-24 15:53:30.982928
+for members, admins, and workspaces make it multi autocompelte input, 

# 2024-12-24 15:54:45.657857
+[plugin:vite:esbuild] Transform failed with 3 errors:
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:380:53: ERROR: The character "}" is not valid inside a JSX element
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:381:24: ERROR: Unexpected closing "MenuItem" tag does not match opening fragment tag
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:382:21: ERROR: Expected "}" but found ")"
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:380:53
+The character "}" is not valid inside a JSX element
+378|                    )}
+379|                  />
+380|                            ?.name || member.toString()}
+   |                                                       ^
+381|                        </MenuItem>
+382|                      ))}
+
+Unexpected closing "MenuItem" tag does not match opening fragment tag
+379|                  />
+380|                            ?.name || member.toString()}
+381|                        </MenuItem>
+   |                          ^
+382|                      ))}
+383|                    </Select>
+
+Expected "}" but found ")"
+380|                            ?.name || member.toString()}
+381|                        </MenuItem>
+382|                      ))}
+   |                       ^
+383|                    </Select>
+384|                  </FormControl>

# 2024-12-24 15:55:39.374873
+ld] Transform failed with 2 errors:
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:380:16: ERROR: Unexpected closing "FormControl" tag does not match opening fragment tag
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:383:18: ERROR: Expected ")" but found "multiple"
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:380:16
+Unexpected closing "FormControl" tag does not match opening fragment tag
+378|                    )}
+379|                  />
+380|                </FormControl>
+   |                  ^
+381|  
+382|                  <Autocomplete
+
+Expected ")" but found "multiple"
+381|  
+382|                  <Autocomplete
+383|                    multiple
+   |                    ^
+384|                    options={all_friends}
+385|                    getOptionLabel={(option) => option.name || option.id} here is my full code ```tsx import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+  Button, Autocomplete,
+} from "@mui/material";
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+  ArrowBack as ArrowBackIcon,
+  Delete as DeleteIcon,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useDispatch, useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import { Link } from "react-router-dom";
+import { Chat } from "../../../declarations/backend/backend.did";
+import { handleRedux } from "../../redux/store/handleRedux";
+
+const ChatWindow = memo(
+  ({
+    chat,
+    onClose,
+    position,
+    onPositionChange,
+    onSendMessage,
+    onUpdateChat,
+  }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [selectedWorkspace, setSelectedWorkspace] = useState(
+      chat.workspaces[0] || "",
+    );
+    const [editedMembers, setEditedMembers] = useState(chat.members);
+    const { workspaces, all_friends, profile } = useSelector(
+      (state: any) => state.filesState,
+    );
+    const { backendActor } = useBackendContext();
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSaving] = useState(false);
+    const messagesEndRef = useRef(null);
+
+    useEffect(() => {
+      setSelectedWorkspace(chat.workspaces[0] || "");
+      setEditedMembers(chat.members);
+    }, [chat]);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+    const dispatch = useDispatch();
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            {isSettingsView ? (
+              <IconButton size="small" onClick={() => setIsSettingsView(false)}>
+                <ArrowBackIcon />
+              </IconButton>
+            ) : (
+              <IconButton size="small" onClick={() => setIsSettingsView(true)}>
+                <SettingsIcon />
+              </IconButton>
+            )}
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && !isSettingsView && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography
+                      to={`user?id=${message.sender.toString()}`}
+                      component={Link}
+                      variant="subtitle2"
+                    >
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+
+        {!isMinimized && isSettingsView && (
+          <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Chat Settings
+            </Typography>
+
+            {chat.creator?.id !== profile?.id ? (
+              <Typography color="error">
+                Only the chat creator can modify settings
+              </Typography>
+            ) : chat.name === "private_chat" ? (
+              <FormControl fullWidth sx={{ mb: 2 }}>
+                <InputLabel>Workspace</InputLabel>
+                <Select
+                  value={selectedWorkspace}
+                  label="Workspace"
+                  onChange={(e) => setSelectedWorkspace(e.target.value)}
+                >
+                  {workspaces.map((workspace) => (
+                    <MenuItem key={workspace.id} value={workspace.id}>
+                      {workspace.name}
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            ) : (
+              <>
+                <TextField
+                  fullWidth
+                  label="Chat Name"
+                  value={chat.name}
+                  onChange={(e) => {
+                    const newName = e.target.value;
+                    if (onUpdateChat) {
+                      const updatedChat = {
+                        ...chat,
+                        name: newName,
+                        admins: chat.admins.map((a) =>
+                          Principal.fromText(a.toString()),
+                        ),
+                        creator: Principal.fromText(chat.creator.toString()),
+                        members: chat.members.map((m) =>
+                          Principal.fromText(m.toString()),
+                        ),
+                      };
+                      onUpdateChat(updatedChat);
+                    }
+                  }}
+                  sx={{ mb: 2 }}
+                />
+                <Autocomplete
+                  multiple
+                  options={workspaces}
+                  getOptionLabel={(option) => option.name}
+                  value={workspaces.filter(w => chat.workspaces.includes(w.id))}
+                  onChange={(_, newValue) => {
+                    if (onUpdateChat) {
+                      const updatedChat = {
+                        ...chat,
+                        workspaces: newValue.map(w => w.id),
+                        admins: chat.admins.map(a => Principal.fromText(a.toString())),
+                        creator: Principal.fromText(chat.creator.toString()),
+                        members: chat.members.map(m => Principal.fromText(m.toString()))
+                      };
+                      onUpdateChat(updatedChat);
+                    }
+                  }}
+                  renderInput={(params) => (
+                    <TextField {...params} label="Workspaces" fullWidth sx={{ mb: 2 }} />
+                  )}
+                />
+
+                <Autocomplete
+                  multiple
+                  options={all_friends}
+                  getOptionLabel={(option) => option.name || option.id}
+                  value={all_friends.filter(f => chat.admins.some(a => a.toString() === f.id))}
+                  onChange={(_, newValue) => {
+                    if (onUpdateChat) {
+                      const updatedChat = {
+                        ...chat,
+                        admins: newValue.map(admin => Principal.fromText(admin.id)),
+                        creator: Principal.fromText(chat.creator.toString()),
+                        members: chat.members.map(m => Principal.fromText(m.toString()))
+                      };
+                      onUpdateChat(updatedChat);
+                    }
+                  }}
+                  renderInput={(params) => (
+                    <TextField {...params} label="Admins" fullWidth sx={{ mb: 2 }} />
+                  )}
+                />
+              </FormControl>
+
+                <Autocomplete
+                  multiple
+                  options={all_friends}
+                  getOptionLabel={(option) => option.name || option.id}
+                  value={all_friends.filter(f => chat.members.some(m => m.toString() === f.id))}
+                  onChange={(_, newValue) => {
+                    if (onUpdateChat) {
+                      const updatedChat = {
+                        ...chat,
+                        members: newValue.map(member => Principal.fromText(member.id)),
+                        admins: chat.admins.map(a => Principal.fromText(a.toString())),
+                        creator: Principal.fromText(chat.creator.toString())
+                      };
+                      onUpdateChat(updatedChat);
+                    }
+                  }}
+                  renderInput={(params) => (
+                    <TextField {...params} label="Members" fullWidth sx={{ mb: 2 }} />
+                  )}
+                />
+
+                <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
+                  <Button
+                    variant="contained"
+                    color="primary"
+                    fullWidth
+                    onClick={async () => {
+                      const updatedChat: Chat = {
+                        ...chat,
+                        admins: chat.admins.map((a) =>
+                          Principal.fromText(a.id),
+                        ),
+                        creator: Principal.fromText(chat.creator.id),
+                        workspaces: [selectedWorkspace],
+                        members: editedMembers,
+                      };
+
+                      try {
+                        const result =
+                          await backendActor.update_chat(updatedChat);
+                        if ("Ok" in result) {
+                          if (onUpdateChat) {
+                            onUpdateChat(updatedChat);
+                          }
+                          setIsSettingsView(false);
+                        }
+                      } catch (error) {
+                        console.error("Failed to update chat:", error);
+                      }
+                    }}
+                  >
+                    Save Changes
+                  </Button>
+
+                  {chat.name !== "private_chat" && (
+                    <Button
+                      variant="contained"
+                      color="error"
+                      onClick={() => {
+                        if (
+                          window.confirm(
+                            "Are you sure you want to delete this chat? This action cannot be undone.",
+                          )
+                        ) {
+                          backendActor
+                            .delete_chat(chat.id)
+                            .then((result) => {
+                              if ("Ok" in result && onClose) {
+                                dispatch(
+                                  handleRedux("DELETE_CHAT", {
+                                    chat_id: chat.id,
+                                  }),
+                                );
+                                onClose(chat.id);
+                              }
+                            })
+                            .catch((error) => {
+                              console.error("Failed to delete chat:", error);
+                            });
+                        }
+                      }}
+                    >
+                      Delete Chat
+                    </Button>
+                  )}
+                </Box>
+              </>
+            )}
+          </Box>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+```

# 2024-12-24 15:57:18.643026
+when I click save changes it should show loading, also when I typie in the name input field it should allow me to change the name but as I hit the keyborad nothing happen

# 2024-12-24 15:58:36.871431
+Uncaught ReferenceError: isSaving is not defined
+    at chatWindow.tsx:392:31

# 2024-12-24 15:59:38.142345
+for the autocompelte I can't remove or add anything ?

# 2024-12-24 16:01:56.641851
+Uncaught Error: Invalid character: "["
+    at decodeChar (chunk-XK4JVWQX.js?v=06f71419:39:13)
+    at decode (chunk-XK4JVWQX.js?v=06f71419:55:5)
+    at _Principal.fromText (chunk-XK4JVWQX.js?v=06f71419:794:19)
+    at chatWindow.tsx:352:68

# 2024-12-24 16:07:12.627288
+at /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/index.tsx and my code import React, { memo, useCallback, useMemo, useState } from "react";
+import {
+  Autocomplete,
+  Avatar,
+  Badge,
+  Box,
+  Button,
+  Chip,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogTitle,
+  FormControl,
+  IconButton,
+  InputLabel,
+  List,
+  ListItem,
+  ListItemAvatar,
+  ListItemText,
+  Menu,
+  MenuItem,
+  Select,
+  TextField,
+  Typography,
+} from "@mui/material";
+
+import {
+  Add as AddIcon,
+  Chat as ChatIcon,
+  Group as GroupIcon,
+} from "@mui/icons-material";
+import ChatWindow from "./chatWindow";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import formatTimestamp from "../../utils/time";
+import { Chat, Message } from "../../../declarations/backend/backend.did";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+
+// Memoized form components
+const GroupNameField = memo(({ value, onChange }) => (
+  <TextField
+    label="Group Name"
+    value={value}
+    onChange={(e) => onChange(e.target.value)}
+    fullWidth
+  />
+));
+
+export const MembersSelect = memo(({ value, onChange, users }) => (
+  <Autocomplete
+    multiple
+    options={users}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Members" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const AdminsSelect = memo(({ value, onChange, members }) => (
+  <Autocomplete
+    multiple
+    options={members}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Admins" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+const WorkspaceSelect = memo(({ value, onChange, workspaces }) => (
+  <FormControl fullWidth>
+    <InputLabel>Workspace</InputLabel>
+    <Select
+      value={value}
+      label="Workspace"
+      onChange={(e) => onChange(e.target.value)}
+    >
+      {workspaces.map((workspace) => (
+        <MenuItem key={workspace.id} value={workspace.id}>
+          {workspace.name}
+        </MenuItem>
+      ))}
+    </Select>
+  </FormControl>
+));
+
+// Memoized Create Group Dialog
+const CreateGroupDialog = memo(
+  ({ open, onClose, onSubmit, initialData, users, workspaces }) => {
+    const [formData, setFormData] = useState(initialData);
+
+    const handleNameChange = useCallback((name) => {
+      setFormData((prev) => ({ ...prev, name }));
+    }, []);
+
+    const handleMembersChange = useCallback((members) => {
+      setFormData((prev) => ({ ...prev, members }));
+    }, []);
+
+    const handleAdminsChange = useCallback((admins) => {
+      setFormData((prev) => ({ ...prev, admins }));
+    }, []);
+
+    const handleWorkspaceChange = useCallback((workspace) => {
+      setFormData((prev) => ({ ...prev, workspace }));
+    }, []);
+
+    const handleSubmit = useCallback(() => {
+      onSubmit(formData);
+    }, [formData, onSubmit]);
+
+    return (
+      <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
+        <DialogTitle>Create New Group Chat</DialogTitle>
+        <DialogContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}>
+            <GroupNameField value={formData.name} onChange={handleNameChange} />
+            <MembersSelect
+              value={formData.members}
+              onChange={handleMembersChange}
+              users={users}
+            />
+            <AdminsSelect
+              value={formData.admins}
+              onChange={handleAdminsChange}
+              members={formData.members}
+            />
+            <WorkspaceSelect
+              value={formData.workspace}
+              onChange={handleWorkspaceChange}
+              workspaces={workspaces}
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={onClose}>Cancel</Button>
+          <Button onClick={handleSubmit} variant="contained" color="primary">
+            Create Group
+          </Button>
+        </DialogActions>
+      </Dialog>
+    );
+  },
+);
+
+const ChatList = memo(
+  ({
+    chats,
+    onChatClick,
+    currentUserId,
+  }: {
+    chats: Chat[];
+    onChatClick: (chat: Chat) => void;
+    currentUserId: string;
+  }) => {
+    // Calculate unread count for each chat if not already present
+    const chatsWithUnread = chats.map((chat) => {
+      if ("unread" in chat) return chat;
+
+      const unseenCount = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === currentUserId,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+
+      return {
+        ...chat,
+        unread: unseenCount,
+      };
+    });
+
+    const { all_friends } = useSelector((state: any) => state.filesState);
+
+    const getOtherUser = (chat) => {
+      if (chat.name !== "private_chat") return null;
+      console.log({ chat, all_friends, currentUserId });
+      return all_friends.find(
+        (f) =>
+          chat.admins.map((a) => a.id)?.includes(f.id) &&
+          f.id !== currentUserId,
+      );
+    };
+
+    return (
+      <List sx={{ padding: 0, width: "100%" }}>
+        {chatsWithUnread.map((chat) => {
+          const otherUser = getOtherUser(chat);
+
+          return (
+            <ListItem
+              key={chat.id}
+              onClick={() => onChatClick(chat)}
+              button
+              sx={{
+                borderBottom: 1,
+                borderColor: "divider",
+                "&:hover": { backgroundColor: "action.hover" },
+              }}
+            >
+              <ListItemAvatar>
+                {chat.name === "private_chat" ? (
+                  <Avatar src={otherUser?.avatar}>
+                    {otherUser?.name?.charAt(0)}
+                  </Avatar>
+                ) : (
+                  <Avatar>
+                    <GroupIcon />
+                  </Avatar>
+                )}
+              </ListItemAvatar>
+              <ListItemText
+                primary={
+                  <Box
+                    sx={{ display: "flex", justifyContent: "space-between" }}
+                  >
+                    <Typography variant="subtitle2">
+                      {chat.name === "private_chat"
+                        ? otherUser?.name || "Unknown User"
+                        : chat.name}
+                    </Typography>
+                    {chat.unread > 0 && (
+                      <Badge badgeContent={chat.unread} color="error" />
+                    )}
+                  </Box>
+                }
+                secondary={
+                  chat.messages[chat.messages.length - 1]?.message ||
+                  "No messages"
+                }
+              />
+            </ListItem>
+          );
+        })}
+      </List>
+    );
+  },
+);
+
+const ChatNotifications = ({ chats: initialChats }: { chats: Chat[] }) => {
+  const [openChats, setOpenChats] = useState(
+    new Map<string, { x: number; y: number }>(),
+  );
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [createGroupOpen, setCreateGroupOpen] = useState(false);
+  const [chats, setChats] = useState<Chat[]>(initialChats || []);
+
+  const { backendActor } = useBackendContext();
+  const { profile } = useSelector((state: any) => state.filesState);
+
+  // Calculate total unseen messages across all chats
+  const totalUnseenMessages = useMemo(() => {
+    if (!profile?.id) return 0;
+
+    return chats.reduce((total, chat) => {
+      const unseenInChat = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === profile.id,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+      return total + unseenInChat;
+    }, 0);
+  }, [chats, profile?.id]);
+
+  const handleOpenChat = useCallback((chat: Chat) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      if (!newChats.has(chat.id)) {
+        const offset = newChats.size * 30;
+        newChats.set(chat.id, {
+          x: 100 + offset,
+          y: 100 + offset,
+        });
+      }
+      return newChats;
+    });
+  }, []);
+
+  const handleCloseChat = useCallback((chatId: string) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      newChats.delete(chatId);
+      return newChats;
+    });
+  }, []);
+
+  const handleChatPosition = useCallback(
+    (chatId: string, position: { x: number; y: number }) => {
+      setOpenChats((prev) => {
+        const newChats = new Map(prev);
+        newChats.set(chatId, position);
+        return newChats;
+      });
+    },
+    [],
+  );
+
+  const handleClick = useCallback(
+    (event: React.MouseEvent<HTMLButtonElement>) => {
+      setAnchorEl(event.currentTarget);
+    },
+    [],
+  );
+
+  const handleClose = useCallback(() => {
+    setAnchorEl(null);
+  }, []);
+
+  const handleChatClick = useCallback(
+    async (chat: Chat) => {
+      try {
+        // Get latest unseen message
+        const unseenMessages = chat.messages.filter((message) => {
+          const isSeen = message.seen_by.some(
+            (user) => user.toString() === profile?.id,
+          );
+          return !isSeen;
+        });
+
+        // Update local state immediately
+        setChats((prevChats) =>
+          prevChats.map((prevChat) => {
+            if (prevChat.id !== chat.id) return prevChat;
+
+            // Update all messages' seen status for this chat
+            const updatedMessages = prevChat.messages.map((msg) => ({
+              ...msg,
+              seen_by: msg.seen_by.some(
+                (user) => user.toString() === profile?.id,
+              )
+                ? msg.seen_by
+                : [...msg.seen_by, Principal.fromText(profile?.id)],
+            }));
+
+            return {
+              ...prevChat,
+              messages: updatedMessages,
+              unread: 0, // Add unread property and set to 0
+            };
+          }),
+        );
+
+        // Call backend if there are unseen messages
+
+        handleOpenChat(chat);
+        handleClose();
+
+        if (unseenMessages.length > 0) {
+          const latestMessage = unseenMessages[unseenMessages.length - 1];
+          const messageForBackend = {
+            ...latestMessage,
+            date: BigInt(0),
+            sender: Principal.fromText(latestMessage.sender.toString()),
+            seen_by: [],
+            chat_id: chat.id,
+          };
+
+          await backendActor?.message_is_seen(messageForBackend);
+        }
+      } catch (error) {
+        console.error("Error marking messages as seen:", error);
+        handleOpenChat(chat);
+        handleClose();
+      }
+    },
+    [profile?.id, backendActor, handleOpenChat, handleClose],
+  );
+
+  const handleCreateGroup = useCallback(
+    async (formData: any) => {
+      if (!backendActor || !profile?.id) return;
+
+      try {
+        const newChat: Chat = {
+          id: randomString(),
+          name: formData.name,
+          messages: [],
+          members: formData.members
+            ? formData.members.map((m) => Principal.fromText(m.id))
+            : [],
+          admins: formData.admins
+            ? formData.admins.map((a) => Principal.fromText(a.id))
+            : [],
+          workspaces: formData.workspace ? [formData.workspace] : [],
+          creator: Principal.fromText(profile.id),
+        };
+
+        const result = await backendActor.make_new_chat_room(newChat);
+        if ("Ok" in result) {
+          // Add new chat to local state
+          setChats((prevChats) => [...prevChats, newChat]);
+          // Open the new chat window
+          handleOpenChat(newChat);
+        } else {
+          console.log("Failed to create chat:", result.Err);
+        }
+      } catch (error) {
+        console.log("Error creating chat:", error);
+      }
+
+      setCreateGroupOpen(false);
+    },
+    [backendActor, profile?.id, handleOpenChat],
+  );
+
+  const handleSendMessage = useCallback(
+    async (chatId: string, messageText: string) => {
+      if (!profile?.id || !messageText.trim()) return;
+
+      const chat = chats.find((c) => c.id === chatId);
+      if (!chat) return;
+
+      const newMessage: Message = {
+        id: randomString(),
+        date: BigInt(Date.now() * 1e6),
+        sender: Principal.fromText(profile.id),
+        seen_by: [Principal.fromText(profile.id)],
+        message: messageText, // Use the actual message text
+        chat_id: chatId,
+      };
+
+      try {
+        // Send message to backend with recipients
+        const res = await backendActor?.send_message([], newMessage);
+        // console.log("Message sent:", { res });
+
+        // Update local state
+        setChats((prevChats) =>
+          prevChats.map((chat) =>
+            chat.id === chatId
+              ? { ...chat, messages: [...chat.messages, newMessage] }
+              : chat,
+          ),
+        );
+      } catch (error) {
+        console.error("Error sending message:", error);
+      }
+    },
+    [profile, backendActor, chats],
+  );
+
+  const open = anchorEl && Boolean(anchorEl);
+  const { all_friends, workspaces } = useSelector(
+    (state: any) => state.filesState,
+  );
+
+  return (
+    <>
+      <IconButton
+        onClick={handleClick}
+        aria-controls={open ? "chat-menu" : undefined}
+        aria-haspopup="true"
+        aria-expanded={open ? "true" : undefined}
+      >
+        <Badge badgeContent={totalUnseenMessages} color="error">
+          <ChatIcon />
+        </Badge>
+      </IconButton>
+
+      <Menu
+        id="chat-menu"
+        anchorEl={anchorEl}
+        open={open}
+        onClose={handleClose}
+        PaperProps={{
+          sx: {
+            maxHeight: 500,
+            width: 320,
+          },
+        }}
+        transformOrigin={{ horizontal: "right", vertical: "top" }}
+        anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
+      >
+        <MenuItem sx={{ justifyContent: "center" }}>
+          <Button
+            startIcon={<AddIcon />}
+            variant="outlined"
+            fullWidth
+            onClick={() => setCreateGroupOpen(true)}
+          >
+            Create New Group
+          </Button>
+        </MenuItem>
+
+        <ChatList
+          chats={chats}
+          onChatClick={handleChatClick}
+          currentUserId={profile?.id}
+        />
+      </Menu>
+
+      {Array.from(openChats.entries()).map(([chatId, position]) => {
+        const chat = chats.find((c) => c.id === chatId);
+        if (!chat) return null;
+
+        return (
+          <ChatWindow
+            key={chatId}
+            chat={chat}
+            position={position}
+            onClose={handleCloseChat}
+            onPositionChange={handleChatPosition}
+            onSendMessage={(currentChatId, message) =>
+              handleSendMessage(chatId, message)
+            }
+            user={profile}
+          />
+        );
+      })}
+
+      <CreateGroupDialog
+        open={createGroupOpen}
+        onClose={() => setCreateGroupOpen(false)}
+        onSubmit={handleCreateGroup}
+        initialData={{
+          name: "",
+          members: [],
+          admins: [],
+          workspace: "",
+        }}
+        users={all_friends}
+        workspaces={workspaces}
+      />
+    </>
+  );
+};
+
+export default ChatNotifications;
+when create new chat group make sure to have consider the case where users does not enter any data and set values to [] and name to "Untitled" also check from redux const {  currentWorkspace } = useSelector(     (state: any) => state.filesState,   ); to set workspaces = [currentWorkspace] also make the workspaces a multi autocompelete as well

# 2024-12-24 16:12:01.962105
+if currentWorkspace.name is defualt do not add it keep it empty list

# 2024-12-24 16:15:45.994517
+at /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+  Button, Autocomplete, Chip,
+} from "@mui/material";
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+  ArrowBack as ArrowBackIcon,
+  Delete as DeleteIcon,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useDispatch, useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import { Link } from "react-router-dom";
+import { Chat } from "../../../declarations/backend/backend.did";
+import { handleRedux } from "../../redux/store/handleRedux";
+
+const ChatWindow = memo(
+  ({
+    chat,
+    onClose,
+    position,
+    onPositionChange,
+    onSendMessage,
+    onUpdateChat,
+  }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [selectedWorkspace, setSelectedWorkspace] = useState(
+      chat.workspaces[0] || "",
+    );
+    const [editedMembers, setEditedMembers] = useState(chat.members);
+    const { workspaces, all_friends, profile } = useSelector(
+      (state: any) => state.filesState,
+    );
+    const { backendActor } = useBackendContext();
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+    const [editedName, setEditedName] = useState(chat.name);
+    const [isSaving, setIsSaving] = useState(false);
+    const messagesEndRef = useRef(null);
+
+    useEffect(() => {
+      setSelectedWorkspace(chat.workspaces[0] || "");
+      setEditedMembers(chat.members);
+    }, [chat]);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+    const dispatch = useDispatch();
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            {isSettingsView ? (
+              <IconButton size="small" onClick={() => setIsSettingsView(false)}>
+                <ArrowBackIcon />
+              </IconButton>
+            ) : (
+              <IconButton size="small" onClick={() => setIsSettingsView(true)}>
+                <SettingsIcon />
+              </IconButton>
+            )}
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && !isSettingsView && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography
+                      to={`user?id=${message.sender.toString()}`}
+                      component={Link}
+                      variant="subtitle2"
+                    >
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+
+        {!isMinimized && isSettingsView && (
+          <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Chat Settings
+            </Typography>
+
+            {chat.creator?.id !== profile?.id ? (
+              <Typography color="error">
+                Only the chat creator can modify settings
+              </Typography>
+            ) : chat.name === "private_chat" ? (
+              <FormControl fullWidth sx={{ mb: 2 }}>
+                <InputLabel>Workspace</InputLabel>
+                <Select
+                  value={selectedWorkspace}
+                  label="Workspace"
+                  onChange={(e) => setSelectedWorkspace(e.target.value)}
+                >
+                  {workspaces.map((workspace) => (
+                    <MenuItem key={workspace.id} value={workspace.id}>
+                      {workspace.name}
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            ) : (
+              <>
+                <TextField
+                  fullWidth
+                  label="Chat Name"
+                  value={editedName}
+                  onChange={(e) => setEditedName(e.target.value)}
+                  sx={{ mb: 2 }}
+                />
+                <Autocomplete
+                  multiple
+                  options={workspaces}
+                  getOptionLabel={(option) => option.name}
+                  value={workspaces.filter(w => chat.workspaces.includes(w.id))}
+                  onChange={(_, newValue) => {
+                    const updatedChat = {
+                      ...chat,
+                      workspaces: newValue.map(w => w.id),
+                      admins: chat.admins.map(a => Principal.fromText(a.toString())),
+                      creator: Principal.fromText(chat.creator.toString()),
+                      members: chat.members.map(m => Principal.fromText(m.toString()))
+                    };
+                    handleSavePost(updatedChat);
+                  }}
+                  renderInput={(params) => (
+                    <TextField {...params} label="Workspaces" fullWidth sx={{ mb: 2 }} />
+                  )}
+                  renderTags={(value, getTagProps) =>
+                    value.map((option, index) => (
+                      <Chip
+                        label={option.name}
+                        {...getTagProps({ index })}
+                        onDelete={() => {
+                          const newValue = value.filter((_, i) => i !== index);
+                          const updatedChat = {
+                            ...chat,
+                            workspaces: newValue.map(w => w.id),
+                            admins: chat.admins.map(a => Principal.fromText(a.toString())),
+                            creator: Principal.fromText(chat.creator.toString()),
+                            members: chat.members.map(m => Principal.fromText(m.toString()))
+                          };
+                          handleSavePost(updatedChat);
+                        }}
+                      />
+                    ))
+                  }
+                />
+
+                <Autocomplete
+                  multiple
+                  options={all_friends}
+                  getOptionLabel={(option) => option.name || option.id}
+                  value={all_friends.filter(f => chat.admins.some(a => a.toString() === f.id))}
+                  onChange={(_, newValue) => {
+                    const updatedChat = {
+                      ...chat,
+                      admins: newValue.map(admin => Principal.fromText(admin.id)),
+                      creator: Principal.fromText(chat.creator.toString()),
+                      members: chat.members.map(m => Principal.fromText(m.toString()))
+                    };
+                    handleSavePost(updatedChat);
+                  }}
+                  renderInput={(params) => (
+                    <TextField {...params} label="Admins" fullWidth sx={{ mb: 2 }} />
+                  )}
+                  renderTags={(value, getTagProps) =>
+                    value.map((option, index) => (
+                      <Chip
+                        label={option.name || option.id}
+                        {...getTagProps({ index })}
+                        onDelete={() => {
+                          const newValue = value.filter((_, i) => i !== index);
+                          const updatedChat = {
+                            ...chat,
+                            admins: newValue.map(admin => Principal.fromText(admin.id)),
+                            creator: Principal.fromText(chat.creator.toString()),
+                            members: chat.members.map(m => Principal.fromText(m.toString()))
+                          };
+                          handleSavePost(updatedChat);
+                        }}
+                      />
+                    ))
+                  }
+                />
+
+                <Autocomplete
+                  multiple
+                  options={all_friends}
+                  getOptionLabel={(option) => option.name || option.id}
+                  value={all_friends.filter(f => chat.members.some(m => m.toString() === f.id))}
+                  onChange={(_, newValue) => {
+                    const updatedChat = {
+                      ...chat,
+                      members: newValue.map(member => Principal.fromText(member.id)),
+                      admins: chat.admins.map(a => Principal.fromText(a.toString())),
+                      creator: Principal.fromText(chat.creator.toString())
+                    };
+                    handleSavePost(updatedChat);
+                  }}
+                  renderInput={(params) => (
+                    <TextField {...params} label="Members" fullWidth sx={{ mb: 2 }} />
+                  )}
+                  renderTags={(value, getTagProps) =>
+                    value.map((option, index) => (
+                      <Chip
+                        label={option.name || option.id}
+                        {...getTagProps({ index })}
+                        onDelete={() => {
+                          const newValue = value.filter((_, i) => i !== index);
+                          const updatedChat = {
+                            ...chat,
+                            members: newValue.map(member => Principal.fromText(member.id)),
+                            admins: chat.admins.map(a => Principal.fromText(a.toString())),
+                            creator: Principal.fromText(chat.creator.toString())
+                          };
+                          handleSavePost(updatedChat);
+                        }}
+                      />
+                    ))
+                  }
+                />
+
+                <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
+                  <Button
+                    variant="contained"
+                    color="primary"
+                    fullWidth
+                    disabled={isSaving}
+                    onClick={async () => {
+                      setIsSaving(true);
+                      const updatedChat: Chat = {
+                        ...chat,
+                        name: editedName,
+                        admins: chat.admins.map((a) =>
+                          Principal.fromText(a.id),
+                        ),
+                        creator: Principal.fromText(chat.creator.id),
+                        workspaces: [selectedWorkspace],
+                        members: editedMembers,
+                      };
+
+                      try {
+                        const result =
+                          await backendActor.update_chat(updatedChat);
+                        if ("Ok" in result) {
+                          if (onUpdateChat) {
+                            onUpdateChat(updatedChat);
+                          }
+                          setIsSettingsView(false);
+                        }
+                      } catch (error) {
+                        console.error("Failed to update chat:", error);
+                      } finally {
+                        setIsSaving(false);
+                      }
+                    }}
+                  >
+                    Save Changes
+                  </Button>
+
+                  {chat.name !== "private_chat" && (
+                    <Button
+                      variant="contained"
+                      color="error"
+                      onClick={() => {
+                        if (
+                          window.confirm(
+                            "Are you sure you want to delete this chat? This action cannot be undone.",
+                          )
+                        ) {
+                          backendActor
+                            .delete_chat(chat.id)
+                            .then((result) => {
+                              if ("Ok" in result && onClose) {
+                                dispatch(
+                                  handleRedux("DELETE_CHAT", {
+                                    chat_id: chat.id,
+                                  }),
+                                );
+                                onClose(chat.id);
+                              }
+                            })
+                            .catch((error) => {
+                              console.error("Failed to delete chat:", error);
+                            });
+                        }
+                      }}
+                    >
+                      Delete Chat
+                    </Button>
+                  )}
+                </Box>
+              </>
+            )}
+          </Box>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+from the UI I am not able to modfity any of the autcomplete note:  it should function the same in the create group example

# 2024-12-24 16:16:54.093171
+still same issue I can't change the settings like workspaces when I try to remove one nothing happen and when I select another one nothing happen.

# 2024-12-24 16:18:22.246670
+No, not in handleSavePost it is in rendering as the user change from UI also it should not be named handleSavePost but it must be handleSaveChat

# 2024-12-24 16:20:19.160950
+still not rendering the changes in the chatWindow, learn how to do it from import React, { memo, useCallback, useMemo, useState } from "react";
+import {
+  Autocomplete,
+  Avatar,
+  Badge,
+  Box,
+  Button,
+  Chip,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogTitle,
+  FormControl,
+  IconButton,
+  InputLabel,
+  List,
+  ListItem,
+  ListItemAvatar,
+  ListItemText,
+  Menu,
+  MenuItem,
+  Select,
+  TextField,
+  Typography,
+} from "@mui/material";
+
+import {
+  Add as AddIcon,
+  Chat as ChatIcon,
+  Group as GroupIcon,
+} from "@mui/icons-material";
+import ChatWindow from "./chatWindow";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import formatTimestamp from "../../utils/time";
+import { Chat, Message } from "../../../declarations/backend/backend.did";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+
+// Memoized form components
+const GroupNameField = memo(({ value, onChange }) => (
+  <TextField
+    label="Group Name"
+    value={value}
+    onChange={(e) => onChange(e.target.value)}
+    fullWidth
+  />
+));
+
+export const MembersSelect = memo(({ value, onChange, users }) => (
+  <Autocomplete
+    multiple
+    options={users}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Members" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const AdminsSelect = memo(({ value, onChange, members }) => (
+  <Autocomplete
+    multiple
+    options={members}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Admins" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+const WorkspaceSelect = memo(({ value, onChange, workspaces }) => (
+  <Autocomplete
+    multiple
+    options={workspaces}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Workspaces" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+// Memoized Create Group Dialog
+const CreateGroupDialog = memo(
+  ({ open, onClose, onSubmit, initialData, users, workspaces }) => {
+    const [formData, setFormData] = useState(initialData);
+
+    const handleNameChange = useCallback((name) => {
+      setFormData((prev) => ({ ...prev, name }));
+    }, []);
+
+    const handleMembersChange = useCallback((members) => {
+      setFormData((prev) => ({ ...prev, members }));
+    }, []);
+
+    const handleAdminsChange = useCallback((admins) => {
+      setFormData((prev) => ({ ...prev, admins }));
+    }, []);
+
+    const handleWorkspaceChange = useCallback((workspace) => {
+      setFormData((prev) => ({ ...prev, workspace }));
+    }, []);
+
+    const handleSubmit = useCallback(() => {
+      onSubmit(formData);
+    }, [formData, onSubmit]);
+
+    return (
+      <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
+        <DialogTitle>Create New Group Chat</DialogTitle>
+        <DialogContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}>
+            <GroupNameField value={formData.name} onChange={handleNameChange} />
+            <MembersSelect
+              value={formData.members}
+              onChange={handleMembersChange}
+              users={users}
+            />
+            <AdminsSelect
+              value={formData.admins}
+              onChange={handleAdminsChange}
+              members={formData.members}
+            />
+            <WorkspaceSelect
+              value={formData.workspace}
+              onChange={handleWorkspaceChange}
+              workspaces={workspaces}
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={onClose}>Cancel</Button>
+          <Button onClick={handleSubmit} variant="contained" color="primary">
+            Create Group
+          </Button>
+        </DialogActions>
+      </Dialog>
+    );
+  },
+);
+
+const ChatList = memo(
+  ({
+    chats,
+    onChatClick,
+    currentUserId,
+  }: {
+    chats: Chat[];
+    onChatClick: (chat: Chat) => void;
+    currentUserId: string;
+  }) => {
+    // Calculate unread count for each chat if not already present
+    const chatsWithUnread = chats.map((chat) => {
+      if ("unread" in chat) return chat;
+
+      const unseenCount = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === currentUserId,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+
+      return {
+        ...chat,
+        unread: unseenCount,
+      };
+    });
+
+    const { all_friends } = useSelector((state: any) => state.filesState);
+
+    const getOtherUser = (chat) => {
+      if (chat.name !== "private_chat") return null;
+      console.log({ chat, all_friends, currentUserId });
+      return all_friends.find(
+        (f) =>
+          chat.admins.map((a) => a.id)?.includes(f.id) &&
+          f.id !== currentUserId,
+      );
+    };
+
+    return (
+      <List sx={{ padding: 0, width: "100%" }}>
+        {chatsWithUnread.map((chat) => {
+          const otherUser = getOtherUser(chat);
+
+          return (
+            <ListItem
+              key={chat.id}
+              onClick={() => onChatClick(chat)}
+              button
+              sx={{
+                borderBottom: 1,
+                borderColor: "divider",
+                "&:hover": { backgroundColor: "action.hover" },
+              }}
+            >
+              <ListItemAvatar>
+                {chat.name === "private_chat" ? (
+                  <Avatar src={otherUser?.avatar}>
+                    {otherUser?.name?.charAt(0)}
+                  </Avatar>
+                ) : (
+                  <Avatar>
+                    <GroupIcon />
+                  </Avatar>
+                )}
+              </ListItemAvatar>
+              <ListItemText
+                primary={
+                  <Box
+                    sx={{ display: "flex", justifyContent: "space-between" }}
+                  >
+                    <Typography variant="subtitle2">
+                      {chat.name === "private_chat"
+                        ? otherUser?.name || "Unknown User"
+                        : chat.name}
+                    </Typography>
+                    {chat.unread > 0 && (
+                      <Badge badgeContent={chat.unread} color="error" />
+                    )}
+                  </Box>
+                }
+                secondary={
+                  chat.messages[chat.messages.length - 1]?.message ||
+                  "No messages"
+                }
+              />
+            </ListItem>
+          );
+        })}
+      </List>
+    );
+  },
+);
+
+const ChatNotifications = ({ chats: initialChats }: { chats: Chat[] }) => {
+  const [openChats, setOpenChats] = useState(
+    new Map<string, { x: number; y: number }>(),
+  );
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [createGroupOpen, setCreateGroupOpen] = useState(false);
+  const [chats, setChats] = useState<Chat[]>(initialChats || []);
+
+  const { backendActor } = useBackendContext();
+  const { profile, currentWorkspace } = useSelector(
+    (state: any) => state.filesState,
+  );
+
+  // Calculate total unseen messages across all chats
+  const totalUnseenMessages = useMemo(() => {
+    if (!profile?.id) return 0;
+
+    return chats.reduce((total, chat) => {
+      const unseenInChat = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === profile.id,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+      return total + unseenInChat;
+    }, 0);
+  }, [chats, profile?.id]);
+
+  const handleOpenChat = useCallback((chat: Chat) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      if (!newChats.has(chat.id)) {
+        const offset = newChats.size * 30;
+        newChats.set(chat.id, {
+          x: 100 + offset,
+          y: 100 + offset,
+        });
+      }
+      return newChats;
+    });
+  }, []);
+
+  const handleCloseChat = useCallback((chatId: string) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      newChats.delete(chatId);
+      return newChats;
+    });
+  }, []);
+
+  const handleChatPosition = useCallback(
+    (chatId: string, position: { x: number; y: number }) => {
+      setOpenChats((prev) => {
+        const newChats = new Map(prev);
+        newChats.set(chatId, position);
+        return newChats;
+      });
+    },
+    [],
+  );
+
+  const handleClick = useCallback(
+    (event: React.MouseEvent<HTMLButtonElement>) => {
+      setAnchorEl(event.currentTarget);
+    },
+    [],
+  );
+
+  const handleClose = useCallback(() => {
+    setAnchorEl(null);
+  }, []);
+
+  const handleChatClick = useCallback(
+    async (chat: Chat) => {
+      try {
+        // Get latest unseen message
+        const unseenMessages = chat.messages.filter((message) => {
+          const isSeen = message.seen_by.some(
+            (user) => user.toString() === profile?.id,
+          );
+          return !isSeen;
+        });
+
+        // Update local state immediately
+        setChats((prevChats) =>
+          prevChats.map((prevChat) => {
+            if (prevChat.id !== chat.id) return prevChat;
+
+            // Update all messages' seen status for this chat
+            const updatedMessages = prevChat.messages.map((msg) => ({
+              ...msg,
+              seen_by: msg.seen_by.some(
+                (user) => user.toString() === profile?.id,
+              )
+                ? msg.seen_by
+                : [...msg.seen_by, Principal.fromText(profile?.id)],
+            }));
+
+            return {
+              ...prevChat,
+              messages: updatedMessages,
+              unread: 0, // Add unread property and set to 0
+            };
+          }),
+        );
+
+        // Call backend if there are unseen messages
+
+        handleOpenChat(chat);
+        handleClose();
+
+        if (unseenMessages.length > 0) {
+          const latestMessage = unseenMessages[unseenMessages.length - 1];
+          const messageForBackend = {
+            ...latestMessage,
+            date: BigInt(0),
+            sender: Principal.fromText(latestMessage.sender.toString()),
+            seen_by: [],
+            chat_id: chat.id,
+          };
+
+          await backendActor?.message_is_seen(messageForBackend);
+        }
+      } catch (error) {
+        console.error("Error marking messages as seen:", error);
+        handleOpenChat(chat);
+        handleClose();
+      }
+    },
+    [profile?.id, backendActor, handleOpenChat, handleClose],
+  );
+
+  const handleCreateGroup = useCallback(
+    async (formData: any) => {
+      if (!backendActor || !profile?.id) return;
+
+      try {
+        const newChat: Chat = {
+          id: randomString(),
+          name: formData.name || "Untitled",
+          messages: [],
+          members:
+            formData.members?.length > 0
+              ? formData.members.map((m) => Principal.fromText(m.id))
+              : [Principal.fromText(profile.id)],
+          admins:
+            formData.admins?.length > 0
+              ? formData.admins.map((a) => Principal.fromText(a.id))
+              : [Principal.fromText(profile.id)],
+          workspaces:
+            formData.workspace?.length > 0
+              ? formData.workspace.map((w) => w.id)
+              : currentWorkspace && currentWorkspace.name !== "default"
+                ? [currentWorkspace.id]
+                : [],
+          creator: Principal.fromText(profile.id),
+        };
+
+        const result = await backendActor.make_new_chat_room(newChat);
+        if ("Ok" in result) {
+          // Add new chat to local state
+          setChats((prevChats) => [...prevChats, newChat]);
+          // Open the new chat window
+          handleOpenChat(newChat);
+        } else {
+          console.log("Failed to create chat:", result.Err);
+        }
+      } catch (error) {
+        console.log("Error creating chat:", error);
+      }
+
+      setCreateGroupOpen(false);
+    },
+    [backendActor, profile?.id, handleOpenChat],
+  );
+
+  const handleSendMessage = useCallback(
+    async (chatId: string, messageText: string) => {
+      if (!profile?.id || !messageText.trim()) return;
+
+      const chat = chats.find((c) => c.id === chatId);
+      if (!chat) return;
+
+      const newMessage: Message = {
+        id: randomString(),
+        date: BigInt(Date.now() * 1e6),
+        sender: Principal.fromText(profile.id),
+        seen_by: [Principal.fromText(profile.id)],
+        message: messageText, // Use the actual message text
+        chat_id: chatId,
+      };
+
+      try {
+        // Send message to backend with recipients
+        const res = await backendActor?.send_message([], newMessage);
+        // console.log("Message sent:", { res });
+
+        // Update local state
+        setChats((prevChats) =>
+          prevChats.map((chat) =>
+            chat.id === chatId
+              ? { ...chat, messages: [...chat.messages, newMessage] }
+              : chat,
+          ),
+        );
+      } catch (error) {
+        console.error("Error sending message:", error);
+      }
+    },
+    [profile, backendActor, chats],
+  );
+
+  const open = anchorEl && Boolean(anchorEl);
+  const { all_friends, workspaces } = useSelector(
+    (state: any) => state.filesState,
+  );
+
+  return (
+    <>
+      <IconButton
+        onClick={handleClick}
+        aria-controls={open ? "chat-menu" : undefined}
+        aria-haspopup="true"
+        aria-expanded={open ? "true" : undefined}
+      >
+        <Badge badgeContent={totalUnseenMessages} color="error">
+          <ChatIcon />
+        </Badge>
+      </IconButton>
+
+      <Menu
+        id="chat-menu"
+        anchorEl={anchorEl}
+        open={open}
+        onClose={handleClose}
+        PaperProps={{
+          sx: {
+            maxHeight: 500,
+            width: 320,
+          },
+        }}
+        transformOrigin={{ horizontal: "right", vertical: "top" }}
+        anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
+      >
+        <MenuItem sx={{ justifyContent: "center" }}>
+          <Button
+            startIcon={<AddIcon />}
+            variant="outlined"
+            fullWidth
+            onClick={() => setCreateGroupOpen(true)}
+          >
+            Create New Group
+          </Button>
+        </MenuItem>
+
+        <ChatList
+          chats={chats}
+          onChatClick={handleChatClick}
+          currentUserId={profile?.id}
+        />
+      </Menu>
+
+      {Array.from(openChats.entries()).map(([chatId, position]) => {
+        const chat = chats.find((c) => c.id === chatId);
+        if (!chat) return null;
+
+        return (
+          <ChatWindow
+            key={chatId}
+            chat={chat}
+            position={position}
+            onClose={handleCloseChat}
+            onPositionChange={handleChatPosition}
+            onSendMessage={(currentChatId, message) =>
+              handleSendMessage(chatId, message)
+            }
+            user={profile}
+          />
+        );
+      })}
+
+      <CreateGroupDialog
+        open={createGroupOpen}
+        onClose={() => setCreateGroupOpen(false)}
+        onSubmit={handleCreateGroup}
+        initialData={{
+          name: "",
+          members: [],
+          admins: [],
+          // workspace: currentWorkspace ? [currentWorkspace] : [],
+          workspace: currentWorkspace.name !== "default"? [currentWorkspace.id] : []
+        }}
+        users={all_friends}
+        workspaces={workspaces}
+      />
+    </>
+  );
+};
+
+export default ChatNotifications;
+notice WorkspaceSelect AdminsSelect MembersSelect replicate them in chatWindow 

# 2024-12-24 16:24:02.320159
+notice my code import React, { memo, useCallback, useMemo, useState } from "react";
+import {
+  Autocomplete,
+  Avatar,
+  Badge,
+  Box,
+  Button,
+  Chip,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogTitle,
+  FormControl,
+  IconButton,
+  InputLabel,
+  List,
+  ListItem,
+  ListItemAvatar,
+  ListItemText,
+  Menu,
+  MenuItem,
+  Select,
+  TextField,
+  Typography,
+} from "@mui/material";
+
+import {
+  Add as AddIcon,
+  Chat as ChatIcon,
+  Group as GroupIcon,
+} from "@mui/icons-material";
+import ChatWindow from "./chatWindow";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import formatTimestamp from "../../utils/time";
+import { Chat, Message } from "../../../declarations/backend/backend.did";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+
+// Memoized form components
+const GroupNameField = memo(({ value, onChange }) => (
+  <TextField
+    label="Group Name"
+    value={value}
+    onChange={(e) => onChange(e.target.value)}
+    fullWidth
+  />
+));
+
+export const MembersSelect = memo(({ value, onChange, users }) => (
+  <Autocomplete
+    multiple
+    options={users}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Members" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const AdminsSelect = memo(({ value, onChange, members }) => (
+  <Autocomplete
+    multiple
+    options={members}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Admins" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const WorkspaceSelect = memo(({ value, onChange, workspaces }) => (
+  <Autocomplete
+    multiple
+    options={workspaces}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Workspaces" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+// Memoized Create Group Dialog
+const CreateGroupDialog = memo(
+  ({ open, onClose, onSubmit, initialData, users, workspaces }) => {
+    const [formData, setFormData] = useState(initialData);
+
+    const handleNameChange = useCallback((name) => {
+      setFormData((prev) => ({ ...prev, name }));
+    }, []);
+
+    const handleMembersChange = useCallback((members) => {
+      setFormData((prev) => ({ ...prev, members }));
+    }, []);
+
+    const handleAdminsChange = useCallback((admins) => {
+      setFormData((prev) => ({ ...prev, admins }));
+    }, []);
+
+    const handleWorkspaceChange = useCallback((workspace) => {
+      setFormData((prev) => ({ ...prev, workspace }));
+    }, []);
+
+    const handleSubmit = useCallback(() => {
+      onSubmit(formData);
+    }, [formData, onSubmit]);
+
+    return (
+      <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
+        <DialogTitle>Create New Group Chat</DialogTitle>
+        <DialogContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}>
+            <GroupNameField value={formData.name} onChange={handleNameChange} />
+            <MembersSelect
+              value={formData.members}
+              onChange={handleMembersChange}
+              users={users}
+            />
+            <AdminsSelect
+              value={formData.admins}
+              onChange={handleAdminsChange}
+              members={formData.members}
+            />
+            <WorkspaceSelect
+              value={formData.workspace}
+              onChange={handleWorkspaceChange}
+              workspaces={workspaces}
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={onClose}>Cancel</Button>
+          <Button onClick={handleSubmit} variant="contained" color="primary">
+            Create Group
+          </Button>
+        </DialogActions>
+      </Dialog>
+    );
+  },
+);
+
+const ChatList = memo(
+  ({
+    chats,
+    onChatClick,
+    currentUserId,
+  }: {
+    chats: Chat[];
+    onChatClick: (chat: Chat) => void;
+    currentUserId: string;
+  }) => {
+    // Calculate unread count for each chat if not already present
+    const chatsWithUnread = chats.map((chat) => {
+      if ("unread" in chat) return chat;
+
+      const unseenCount = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === currentUserId,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+
+      return {
+        ...chat,
+        unread: unseenCount,
+      };
+    });
+
+    const { all_friends } = useSelector((state: any) => state.filesState);
+
+    const getOtherUser = (chat) => {
+      if (chat.name !== "private_chat") return null;
+      console.log({ chat, all_friends, currentUserId });
+      return all_friends.find(
+        (f) =>
+          chat.admins.map((a) => a.id)?.includes(f.id) &&
+          f.id !== currentUserId,
+      );
+    };
+
+    return (
+      <List sx={{ padding: 0, width: "100%" }}>
+        {chatsWithUnread.map((chat) => {
+          const otherUser = getOtherUser(chat);
+
+          return (
+            <ListItem
+              key={chat.id}
+              onClick={() => onChatClick(chat)}
+              button
+              sx={{
+                borderBottom: 1,
+                borderColor: "divider",
+                "&:hover": { backgroundColor: "action.hover" },
+              }}
+            >
+              <ListItemAvatar>
+                {chat.name === "private_chat" ? (
+                  <Avatar src={otherUser?.avatar}>
+                    {otherUser?.name?.charAt(0)}
+                  </Avatar>
+                ) : (
+                  <Avatar>
+                    <GroupIcon />
+                  </Avatar>
+                )}
+              </ListItemAvatar>
+              <ListItemText
+                primary={
+                  <Box
+                    sx={{ display: "flex", justifyContent: "space-between" }}
+                  >
+                    <Typography variant="subtitle2">
+                      {chat.name === "private_chat"
+                        ? otherUser?.name || "Unknown User"
+                        : chat.name}
+                    </Typography>
+                    {chat.unread > 0 && (
+                      <Badge badgeContent={chat.unread} color="error" />
+                    )}
+                  </Box>
+                }
+                secondary={
+                  chat.messages[chat.messages.length - 1]?.message ||
+                  "No messages"
+                }
+              />
+            </ListItem>
+          );
+        })}
+      </List>
+    );
+  },
+);
+
+const ChatNotifications = ({ chats: initialChats }: { chats: Chat[] }) => {
+  const [openChats, setOpenChats] = useState(
+    new Map<string, { x: number; y: number }>(),
+  );
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [createGroupOpen, setCreateGroupOpen] = useState(false);
+  const [chats, setChats] = useState<Chat[]>(initialChats || []);
+
+  const { backendActor } = useBackendContext();
+  const { profile, currentWorkspace } = useSelector(
+    (state: any) => state.filesState,
+  );
+
+  // Calculate total unseen messages across all chats
+  const totalUnseenMessages = useMemo(() => {
+    if (!profile?.id) return 0;
+
+    return chats.reduce((total, chat) => {
+      const unseenInChat = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === profile.id,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+      return total + unseenInChat;
+    }, 0);
+  }, [chats, profile?.id]);
+
+  const handleOpenChat = useCallback((chat: Chat) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      if (!newChats.has(chat.id)) {
+        const offset = newChats.size * 30;
+        newChats.set(chat.id, {
+          x: 100 + offset,
+          y: 100 + offset,
+        });
+      }
+      return newChats;
+    });
+  }, []);
+
+  const handleCloseChat = useCallback((chatId: string) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      newChats.delete(chatId);
+      return newChats;
+    });
+  }, []);
+
+  const handleChatPosition = useCallback(
+    (chatId: string, position: { x: number; y: number }) => {
+      setOpenChats((prev) => {
+        const newChats = new Map(prev);
+        newChats.set(chatId, position);
+        return newChats;
+      });
+    },
+    [],
+  );
+
+  const handleClick = useCallback(
+    (event: React.MouseEvent<HTMLButtonElement>) => {
+      setAnchorEl(event.currentTarget);
+    },
+    [],
+  );
+
+  const handleClose = useCallback(() => {
+    setAnchorEl(null);
+  }, []);
+
+  const handleChatClick = useCallback(
+    async (chat: Chat) => {
+      try {
+        // Get latest unseen message
+        const unseenMessages = chat.messages.filter((message) => {
+          const isSeen = message.seen_by.some(
+            (user) => user.toString() === profile?.id,
+          );
+          return !isSeen;
+        });
+
+        // Update local state immediately
+        setChats((prevChats) =>
+          prevChats.map((prevChat) => {
+            if (prevChat.id !== chat.id) return prevChat;
+
+            // Update all messages' seen status for this chat
+            const updatedMessages = prevChat.messages.map((msg) => ({
+              ...msg,
+              seen_by: msg.seen_by.some(
+                (user) => user.toString() === profile?.id,
+              )
+                ? msg.seen_by
+                : [...msg.seen_by, Principal.fromText(profile?.id)],
+            }));
+
+            return {
+              ...prevChat,
+              messages: updatedMessages,
+              unread: 0, // Add unread property and set to 0
+            };
+          }),
+        );
+
+        // Call backend if there are unseen messages
+
+        handleOpenChat(chat);
+        handleClose();
+
+        if (unseenMessages.length > 0) {
+          const latestMessage = unseenMessages[unseenMessages.length - 1];
+          const messageForBackend = {
+            ...latestMessage,
+            date: BigInt(0),
+            sender: Principal.fromText(latestMessage.sender.toString()),
+            seen_by: [],
+            chat_id: chat.id,
+          };
+
+          await backendActor?.message_is_seen(messageForBackend);
+        }
+      } catch (error) {
+        console.error("Error marking messages as seen:", error);
+        handleOpenChat(chat);
+        handleClose();
+      }
+    },
+    [profile?.id, backendActor, handleOpenChat, handleClose],
+  );
+
+  const handleCreateGroup = useCallback(
+    async (formData: any) => {
+      if (!backendActor || !profile?.id) return;
+
+      try {
+        const newChat: Chat = {
+          id: randomString(),
+          name: formData.name || "Untitled",
+          messages: [],
+          members:
+            formData.members?.length > 0
+              ? formData.members.map((m) => Principal.fromText(m.id))
+              : [Principal.fromText(profile.id)],
+          admins:
+            formData.admins?.length > 0
+              ? formData.admins.map((a) => Principal.fromText(a.id))
+              : [Principal.fromText(profile.id)],
+          workspaces:
+            formData.workspace?.length > 0
+              ? formData.workspace.map((w) => w.id)
+              : currentWorkspace && currentWorkspace.name !== "default"
+                ? [currentWorkspace.id]
+                : [],
+          creator: Principal.fromText(profile.id),
+        };
+
+        const result = await backendActor.make_new_chat_room(newChat);
+        if ("Ok" in result) {
+          // Add new chat to local state
+          setChats((prevChats) => [...prevChats, newChat]);
+          // Open the new chat window
+          handleOpenChat(newChat);
+        } else {
+          console.log("Failed to create chat:", result.Err);
+        }
+      } catch (error) {
+        console.log("Error creating chat:", error);
+      }
+
+      setCreateGroupOpen(false);
+    },
+    [backendActor, profile?.id, handleOpenChat],
+  );
+
+  const handleSendMessage = useCallback(
+    async (chatId: string, messageText: string) => {
+      if (!profile?.id || !messageText.trim()) return;
+
+      const chat = chats.find((c) => c.id === chatId);
+      if (!chat) return;
+
+      const newMessage: Message = {
+        id: randomString(),
+        date: BigInt(Date.now() * 1e6),
+        sender: Principal.fromText(profile.id),
+        seen_by: [Principal.fromText(profile.id)],
+        message: messageText, // Use the actual message text
+        chat_id: chatId,
+      };
+
+      try {
+        // Send message to backend with recipients
+        const res = await backendActor?.send_message([], newMessage);
+        // console.log("Message sent:", { res });
+
+        // Update local state
+        setChats((prevChats) =>
+          prevChats.map((chat) =>
+            chat.id === chatId
+              ? { ...chat, messages: [...chat.messages, newMessage] }
+              : chat,
+          ),
+        );
+      } catch (error) {
+        console.error("Error sending message:", error);
+      }
+    },
+    [profile, backendActor, chats],
+  );
+
+  const open = anchorEl && Boolean(anchorEl);
+  const { all_friends, workspaces } = useSelector(
+    (state: any) => state.filesState,
+  );
+
+  return (
+    <>
+      <IconButton
+        onClick={handleClick}
+        aria-controls={open ? "chat-menu" : undefined}
+        aria-haspopup="true"
+        aria-expanded={open ? "true" : undefined}
+      >
+        <Badge badgeContent={totalUnseenMessages} color="error">
+          <ChatIcon />
+        </Badge>
+      </IconButton>
+
+      <Menu
+        id="chat-menu"
+        anchorEl={anchorEl}
+        open={open}
+        onClose={handleClose}
+        PaperProps={{
+          sx: {
+            maxHeight: 500,
+            width: 320,
+          },
+        }}
+        transformOrigin={{ horizontal: "right", vertical: "top" }}
+        anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
+      >
+        <MenuItem sx={{ justifyContent: "center" }}>
+          <Button
+            startIcon={<AddIcon />}
+            variant="outlined"
+            fullWidth
+            onClick={() => setCreateGroupOpen(true)}
+          >
+            Create New Group
+          </Button>
+        </MenuItem>
+
+        <ChatList
+          chats={chats}
+          onChatClick={handleChatClick}
+          currentUserId={profile?.id}
+        />
+      </Menu>
+
+      {Array.from(openChats.entries()).map(([chatId, position]) => {
+        const chat = chats.find((c) => c.id === chatId);
+        if (!chat) return null;
+
+        return (
+          <ChatWindow
+            key={chatId}
+            chat={chat}
+            position={position}
+            onClose={handleCloseChat}
+            onPositionChange={handleChatPosition}
+            onSendMessage={(currentChatId, message) =>
+              handleSendMessage(chatId, message)
+            }
+            user={profile}
+          />
+        );
+      })}
+
+      <CreateGroupDialog
+        open={createGroupOpen}
+        onClose={() => setCreateGroupOpen(false)}
+        onSubmit={handleCreateGroup}
+        initialData={{
+          name: "",
+          members: [],
+          admins: [],
+          // workspace: currentWorkspace ? [currentWorkspace] : [],
+          workspace: currentWorkspace.name !== "default"? [currentWorkspace.id] : []
+        }}
+        users={all_friends}
+        workspaces={workspaces}
+      />
+    </>
+  );
+};
+
+export default ChatNotifications;
+ at /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/index.tsx as the currentWorkspace change filter out the chats that !chat.workspaces.includes(currentChat.id)

# 2024-12-24 16:26:11.185173
+my code import React, { useState } from "react";
+import Button from "@mui/material/Button";
+import Menu from "@mui/material/Menu";
+import MenuItem from "@mui/material/MenuItem";
+import TextField from "@mui/material/TextField";
+import Dialog from "@mui/material/Dialog";
+import DialogActions from "@mui/material/DialogActions";
+import DialogContent from "@mui/material/DialogContent";
+import DialogContentText from "@mui/material/DialogContentText";
+import DialogTitle from "@mui/material/DialogTitle";
+import IconButton from "@mui/material/IconButton";
+import Divider from "@mui/material/Divider";
+import ListItemIcon from "@mui/material/ListItemIcon";
+import ListItemText from "@mui/material/ListItemText";
+import { Check, ChevronDown, Edit2, PlusCircle, Trash2, X } from "lucide-react";
+import CircularProgress from "@mui/material/CircularProgress";
+import { useDispatch, useSelector } from "react-redux";
+import { useBackendContext } from "../../../contexts/BackendContext";
+import { Principal } from "@dfinity/principal";
+import DeleteIcon from '@mui/icons-material/Delete';
+import { IconButton as MuiIconButton } from "@mui/material";
+const WorkspaceManager = () => {
+  const { workspaces, currentWorkspace } = useSelector(
+    (state: any) => state.filesState,
+  );
+  const { backendActor } = useBackendContext();
+  const { profile } = useSelector((state: any) => state.filesState);
+
+  const [anchorEl, setAnchorEl] = useState(null);
+  const [editingId, setEditingId] = useState(null);
+  const [editedName, setEditedName] = useState("");
+  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
+  const [isSaving, setIsSaving] = useState(false);
+  const [showCreateInput, setShowCreateInput] = useState(false);
+  const [isCreating, setIsCreating] = useState(false);
+
+  const handleClick = (event) => {
+    setAnchorEl(event.currentTarget);
+  };
+
+  const handleClose = () => {
+    setAnchorEl(null);
+    setShowCreateInput(false);
+    setEditingId(null);
+  };
+
+  const handleRename = (workspace, e) => {
+    e.stopPropagation();
+    setEditingId(workspace.id);
+    setEditedName(workspace.name);
+  };
+
+  const handleSaveRename = async (e) => {
+    e.stopPropagation();
+    if (editedName.trim() && backendActor) {
+      setIsSaving(true);
+      try {
+        const workspaceToUpdate = workspaces.find((w) => w.id === editingId);
+        if (workspaceToUpdate) {
+          const updatedWorkspace = {
+            ...workspaceToUpdate,
+            creator: Principal.fromText(profile.id),
+            name: editedName,
+          };
+
+          const result = await backendActor.save_work_space(updatedWorkspace);
+          if ("Ok" in result) {
+            dispatch({ type: "UPDATE_WORKSPACE", workspace: updatedWorkspace });
+            setEditingId(null);
+            setEditedName("");
+          }
+        }
+      } catch (error) {
+        console.error("Failed to rename workspace:", error);
+      } finally {
+        setIsSaving(false);
+      }
+    }
+  };
+
+  const [workspaceToDelete, setWorkspaceToDelete] = useState(null);
+
+  const handleDelete = (workspace, e) => {
+    e.stopPropagation();
+    setWorkspaceToDelete(workspace);
+    setShowDeleteDialog(true);
+    setAnchorEl(null);
+  };
+
+  const confirmDelete = async () => {
+    if (!workspaceToDelete) return;
+    if (backendActor) {
+      try {
+        console.log("Deleting workspace:", workspaceToDelete);
+        let res = await backendActor.delete_work_space(workspaceToDelete);
+        console.log("Deleting res:", res);
+        // Update Redux store
+        dispatch({ type: "DELETE_WORKSPACE", workspace: workspaceToDelete });
+
+        if (currentWorkspace.id === workspaceToDelete.id && workspaces.length > 0) {
+          const newSelectedWorkspace = workspaces[0];
+          dispatch({
+            type: "CHANGE_CURRENT_WORKSPACE",
+            currentWorkspace: newSelectedWorkspace,
+          });
+        }
+        setShowDeleteDialog(false);
+      } catch (error) {
+        console.error("Failed to delete workspace:", error);
+      }
+    }
+  };
+
+  const handleCreateWorkspace = async (
+    e: React.SyntheticEvent,
+    newWorkspaceName: string,
+  ) => {
+    setIsCreating(true);
+    e.stopPropagation();
+    if (newWorkspaceName.trim() && backendActor && profile) {
+      const creator = Principal.fromText(profile.id);
+      const newWorkspace = {
+        id: crypto.randomUUID(),
+        name: newWorkspaceName,
+        files: [],
+        creator,
+        members: [creator],
+        chats: [],
+        admins: [creator],
+      };
+
+      try {
+        const result = await backendActor.save_work_space(newWorkspace);
+        if ("Ok" in result) {
+          // Update Redux store
+          dispatch({ type: "ADD_WORKSPACE", workspace: newWorkspace });
+
+          // Set the newly created workspace as selected
+          dispatch({
+            type: "CHANGE_CURRENT_WORKSPACE",
+            currentWorkspace: newWorkspace,
+          });
+
+          // Reset input state
+          setShowCreateInput(false);
+          handleClose(); // Close the menu after successful creation
+        } else {
+          console.error("Failed to create workspace:", result.Err);
+        }
+      } catch (error) {
+        console.error("Failed to create workspace:", error);
+      } finally {
+        setIsCreating(false);
+      }
+    }
+  };
+
+  const dispatch = useDispatch();
+
+  const handleWorkspaceSelect = (workspace) => {
+    dispatch({ type: "CHANGE_CURRENT_WORKSPACE", currentWorkspace: workspace });
+    handleClose();
+  };
+
+  return (
+    <>
+      <Button
+        onClick={handleClick}
+        endIcon={<ChevronDown />}
+        sx={{
+          textTransform: "none",
+          minHeight: 40,
+          backgroundColor: "transparent",
+          border: "1px solid rgba(0, 0, 0, 0.23)",
+          color: "inherit",
+          "&:hover": {
+            backgroundColor: "rgba(0, 0, 0, 0.04)",
+            border: "1px solid rgba(0, 0, 0, 0.23)",
+          },
+        }}
+      >
+        {currentWorkspace && currentWorkspace.name}
+      </Button>
+
+      <Menu
+        anchorEl={anchorEl}
+        open={Boolean(anchorEl)}
+        onClose={handleClose}
+        PaperProps={{
+          sx: { width: 320 },
+        }}
+      >
+        {showCreateInput ? (
+          <MenuItem>
+            <TextField
+              size="small"
+              placeholder="New workspace name"
+              variant="outlined"
+              sx={{ mr: 1, flex: 1 }}
+              onClick={(e) => e.stopPropagation()}
+              onKeyDown={(e) => {
+                e.stopPropagation();
+                if (e.key === "Enter") {
+                  handleCreateWorkspace(e, e.target.value);
+                }
+              }}
+            />
+            <IconButton
+              size="small"
+              onClick={(e) => {
+                const input =
+                  e.currentTarget.parentElement?.querySelector("input");
+                if (input) {
+                  handleCreateWorkspace(e, input.value);
+                }
+              }}
+              disabled={isCreating}
+            >
+              {isCreating ? (
+                <CircularProgress size={20} />
+              ) : (
+                <Check fontSize="small" />
+              )}
+            </IconButton>
+            <IconButton
+              size="small"
+              onClick={(e) => {
+                e.stopPropagation();
+                setShowCreateInput(false);
+              }}
+            >
+              <X fontSize="small" />
+            </IconButton>
+          </MenuItem>
+        ) : (
+          <MenuItem
+            onClick={(e) => {
+              e.preventDefault();
+              setShowCreateInput(true);
+            }}
+          >
+            <ListItemIcon>
+              <PlusCircle size={20} />
+            </ListItemIcon>
+            <ListItemText>New Workspace</ListItemText>
+          </MenuItem>
+        )}
+
+        <Divider />
+
+        {workspaces.map((workspace) => (
+          <MenuItem
+            key={workspace.id}
+            selected={workspace && workspace.id === currentWorkspace.id}
+            onClick={() => handleWorkspaceSelect(workspace)}
+            sx={{
+              display: "flex",
+              justifyContent: "space-between",
+              "&:hover .workspace-actions": {
+                opacity: 1,
+              },
+            }}
+          >
+            {editingId === workspace.id ? (
+              <div
+                style={{ display: "flex", alignItems: "center", width: "100%" }}
+              >
+                <TextField
+                  size="small"
+                  value={editedName}
+                  onChange={(e) => setEditedName(e.target.value)}
+                  variant="outlined"
+                  sx={{ mr: 1, flex: 1 }}
+                  onClick={(e) => e.stopPropagation()}
+                />
+                <IconButton 
+                  size="small" 
+                  onClick={handleSaveRename}
+                  disabled={isSaving}
+                >
+                  {isSaving ? (
+                    <CircularProgress size={20} />
+                  ) : (
+                    <Check fontSize="small" />
+                  )}
+                </IconButton>
+                <IconButton
+                  size="small"
+                  onClick={(e) => {
+                    e.stopPropagation();
+                    setEditingId(null);
+                  }}
+                >
+                  <X fontSize="small" />
+                </IconButton>
+              </div>
+            ) : (
+              <>
+                <ListItemText>{workspace.name}</ListItemText>
+                <div
+                  className="workspace-actions"
+                >
+                  <IconButton
+                    size="small"
+                    onClick={(e) => handleRename(workspace, e)}
+                  >
+                    <Edit2 size={16} />
+                  </IconButton>
+                  <MuiIconButton
+                    size="small"
+                    onClick={(e) => handleDelete(workspace, e)}
+                    sx={{ p: 0.5 }}
+                  >
+                    <DeleteIcon sx={{ fontSize: 16 }} />
+                  </MuiIconButton>
+                </div>
+              </>
+            )}
+          </MenuItem>
+        ))}
+      </Menu>
+
+      <Dialog
+        open={showDeleteDialog}
+        onClose={() => {
+          setShowDeleteDialog(false);
+          setWorkspaceToDelete(null);
+        }}
+      >
+        <DialogTitle>Delete Workspace</DialogTitle>
+        <DialogContent>
+          <DialogContentText>
+            Are you sure you want to delete workspace "{workspaceToDelete?.name}
+            "? This action cannot be undone.
+          </DialogContentText>
+        </DialogContent>
+        <DialogActions>
+          <Button
+            onClick={() => {
+              setShowDeleteDialog(false);
+              setWorkspaceToDelete(null);
+            }}
+          >
+            Cancel
+          </Button>
+          <Button
+            onClick={() => {
+              confirmDelete();
+              setShowDeleteDialog(false);
+              setWorkspaceToDelete(null);
+            }}
+            color="error"
+          >
+            Delete
+          </Button>
+        </DialogActions>
+      </Dialog>
+    </>
+  );
+};
+
+export default WorkspaceManager;
+ at /Users/ahmed/Desktop/odoc/src/frontend/components/MainComponents/Workspaces/index.tsx in the select workspaces list there is no option defualt

# 2024-12-24 16:26:40.249856
+the dfeualt one should not have edite or delete options

# 2024-12-24 16:29:49.048399
+my codeimport React, { memo, useCallback, useMemo, useState } from "react";
+import {
+  Autocomplete,
+  Avatar,
+  Badge,
+  Box,
+  Button,
+  Chip,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogTitle,
+  FormControl,
+  IconButton,
+  InputLabel,
+  List,
+  ListItem,
+  ListItemAvatar,
+  ListItemText,
+  Menu,
+  MenuItem,
+  Select,
+  TextField,
+  Typography,
+} from "@mui/material";
+
+import {
+  Add as AddIcon,
+  Chat as ChatIcon,
+  Group as GroupIcon,
+} from "@mui/icons-material";
+import ChatWindow from "./chatWindow";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import formatTimestamp from "../../utils/time";
+import { Chat, Message } from "../../../declarations/backend/backend.did";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+
+// Memoized form components
+const GroupNameField = memo(({ value, onChange }) => (
+  <TextField
+    label="Group Name"
+    value={value}
+    onChange={(e) => onChange(e.target.value)}
+    fullWidth
+  />
+));
+
+export const MembersSelect = memo(({ value, onChange, users }) => (
+  <Autocomplete
+    multiple
+    options={users}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Members" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const AdminsSelect = memo(({ value, onChange, members }) => (
+  <Autocomplete
+    multiple
+    options={members}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Admins" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const WorkspaceSelect = memo(({ value, onChange, workspaces }) => (
+  <Autocomplete
+    multiple
+    options={workspaces}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Workspaces" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+// Memoized Create Group Dialog
+const CreateGroupDialog = memo(
+  ({ open, onClose, onSubmit, initialData, users, workspaces }) => {
+    const [formData, setFormData] = useState(initialData);
+
+    const handleNameChange = useCallback((name) => {
+      setFormData((prev) => ({ ...prev, name }));
+    }, []);
+
+    const handleMembersChange = useCallback((members) => {
+      setFormData((prev) => ({ ...prev, members }));
+    }, []);
+
+    const handleAdminsChange = useCallback((admins) => {
+      setFormData((prev) => ({ ...prev, admins }));
+    }, []);
+
+    const handleWorkspaceChange = useCallback((workspace) => {
+      setFormData((prev) => ({ ...prev, workspace }));
+    }, []);
+
+    const handleSubmit = useCallback(() => {
+      onSubmit(formData);
+    }, [formData, onSubmit]);
+
+    return (
+      <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
+        <DialogTitle>Create New Group Chat</DialogTitle>
+        <DialogContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}>
+            <GroupNameField value={formData.name} onChange={handleNameChange} />
+            <MembersSelect
+              value={formData.members}
+              onChange={handleMembersChange}
+              users={users}
+            />
+            <AdminsSelect
+              value={formData.admins}
+              onChange={handleAdminsChange}
+              members={formData.members}
+            />
+            <WorkspaceSelect
+              value={formData.workspace}
+              onChange={handleWorkspaceChange}
+              workspaces={workspaces}
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={onClose}>Cancel</Button>
+          <Button onClick={handleSubmit} variant="contained" color="primary">
+            Create Group
+          </Button>
+        </DialogActions>
+      </Dialog>
+    );
+  },
+);
+
+const ChatList = memo(
+  ({
+    chats,
+    onChatClick,
+    currentUserId,
+  }: {
+    chats: Chat[];
+    onChatClick: (chat: Chat) => void;
+    currentUserId: string;
+  }) => {
+    const { currentWorkspace } = useSelector((state: any) => state.filesState);
+    // Calculate unread count for each chat if not already present
+    const chatsWithUnread = chats
+      .filter(chat => 
+        // Include chat if it's in current workspace or if current workspace is default
+        currentWorkspace.name === "default" || 
+        chat.workspaces.includes(currentWorkspace.id)
+      )
+      .map((chat) => {
+        if ("unread" in chat) return chat;
+
+        const unseenCount = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === currentUserId,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+
+      return {
+        ...chat,
+        unread: unseenCount,
+      };
+    });
+
+    const { all_friends } = useSelector((state: any) => state.filesState);
+
+    const getOtherUser = (chat) => {
+      if (chat.name !== "private_chat") return null;
+      console.log({ chat, all_friends, currentUserId });
+      return all_friends.find(
+        (f) =>
+          chat.admins.map((a) => a.id)?.includes(f.id) &&
+          f.id !== currentUserId,
+      );
+    };
+
+    return (
+      <List sx={{ padding: 0, width: "100%" }}>
+        {chatsWithUnread.map((chat) => {
+          const otherUser = getOtherUser(chat);
+
+          return (
+            <ListItem
+              key={chat.id}
+              onClick={() => onChatClick(chat)}
+              button
+              sx={{
+                borderBottom: 1,
+                borderColor: "divider",
+                "&:hover": { backgroundColor: "action.hover" },
+              }}
+            >
+              <ListItemAvatar>
+                {chat.name === "private_chat" ? (
+                  <Avatar src={otherUser?.avatar}>
+                    {otherUser?.name?.charAt(0)}
+                  </Avatar>
+                ) : (
+                  <Avatar>
+                    <GroupIcon />
+                  </Avatar>
+                )}
+              </ListItemAvatar>
+              <ListItemText
+                primary={
+                  <Box
+                    sx={{ display: "flex", justifyContent: "space-between" }}
+                  >
+                    <Typography variant="subtitle2">
+                      {chat.name === "private_chat"
+                        ? otherUser?.name || "Unknown User"
+                        : chat.name}
+                    </Typography>
+                    {chat.unread > 0 && (
+                      <Badge badgeContent={chat.unread} color="error" />
+                    )}
+                  </Box>
+                }
+                secondary={
+                  chat.messages[chat.messages.length - 1]?.message ||
+                  "No messages"
+                }
+              />
+            </ListItem>
+          );
+        })}
+      </List>
+    );
+  },
+);
+
+const ChatNotifications = ({ chats: initialChats }: { chats: Chat[] }) => {
+  const [openChats, setOpenChats] = useState(
+    new Map<string, { x: number; y: number }>(),
+  );
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [createGroupOpen, setCreateGroupOpen] = useState(false);
+  const [chats, setChats] = useState<Chat[]>(initialChats || []);
+
+  const { backendActor } = useBackendContext();
+  const { profile, currentWorkspace } = useSelector(
+    (state: any) => state.filesState,
+  );
+
+  // Calculate total unseen messages across all chats
+  const totalUnseenMessages = useMemo(() => {
+    if (!profile?.id) return 0;
+
+    return chats.reduce((total, chat) => {
+      const unseenInChat = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === profile.id,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+      return total + unseenInChat;
+    }, 0);
+  }, [chats, profile?.id]);
+
+  const handleOpenChat = useCallback((chat: Chat) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      if (!newChats.has(chat.id)) {
+        const offset = newChats.size * 30;
+        newChats.set(chat.id, {
+          x: 100 + offset,
+          y: 100 + offset,
+        });
+      }
+      return newChats;
+    });
+  }, []);
+
+  const handleCloseChat = useCallback((chatId: string) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      newChats.delete(chatId);
+      return newChats;
+    });
+  }, []);
+
+  const handleChatPosition = useCallback(
+    (chatId: string, position: { x: number; y: number }) => {
+      setOpenChats((prev) => {
+        const newChats = new Map(prev);
+        newChats.set(chatId, position);
+        return newChats;
+      });
+    },
+    [],
+  );
+
+  const handleClick = useCallback(
+    (event: React.MouseEvent<HTMLButtonElement>) => {
+      setAnchorEl(event.currentTarget);
+    },
+    [],
+  );
+
+  const handleClose = useCallback(() => {
+    setAnchorEl(null);
+  }, []);
+
+  const handleChatClick = useCallback(
+    async (chat: Chat) => {
+      try {
+        // Get latest unseen message
+        const unseenMessages = chat.messages.filter((message) => {
+          const isSeen = message.seen_by.some(
+            (user) => user.toString() === profile?.id,
+          );
+          return !isSeen;
+        });
+
+        // Update local state immediately
+        setChats((prevChats) =>
+          prevChats.map((prevChat) => {
+            if (prevChat.id !== chat.id) return prevChat;
+
+            // Update all messages' seen status for this chat
+            const updatedMessages = prevChat.messages.map((msg) => ({
+              ...msg,
+              seen_by: msg.seen_by.some(
+                (user) => user.toString() === profile?.id,
+              )
+                ? msg.seen_by
+                : [...msg.seen_by, Principal.fromText(profile?.id)],
+            }));
+
+            return {
+              ...prevChat,
+              messages: updatedMessages,
+              unread: 0, // Add unread property and set to 0
+            };
+          }),
+        );
+
+        // Call backend if there are unseen messages
+
+        handleOpenChat(chat);
+        handleClose();
+
+        if (unseenMessages.length > 0) {
+          const latestMessage = unseenMessages[unseenMessages.length - 1];
+          const messageForBackend = {
+            ...latestMessage,
+            date: BigInt(0),
+            sender: Principal.fromText(latestMessage.sender.toString()),
+            seen_by: [],
+            chat_id: chat.id,
+          };
+
+          await backendActor?.message_is_seen(messageForBackend);
+        }
+      } catch (error) {
+        console.error("Error marking messages as seen:", error);
+        handleOpenChat(chat);
+        handleClose();
+      }
+    },
+    [profile?.id, backendActor, handleOpenChat, handleClose],
+  );
+
+  const handleCreateGroup = useCallback(
+    async (formData: any) => {
+      if (!backendActor || !profile?.id) return;
+
+      try {
+        const newChat: Chat = {
+          id: randomString(),
+          name: formData.name || "Untitled",
+          messages: [],
+          members:
+            formData.members?.length > 0
+              ? formData.members.map((m) => Principal.fromText(m.id))
+              : [Principal.fromText(profile.id)],
+          admins:
+            formData.admins?.length > 0
+              ? formData.admins.map((a) => Principal.fromText(a.id))
+              : [Principal.fromText(profile.id)],
+          workspaces:
+            formData.workspace?.length > 0
+              ? formData.workspace.map((w) => w.id)
+              : currentWorkspace && currentWorkspace.name !== "default"
+                ? [currentWorkspace.id]
+                : [],
+          creator: Principal.fromText(profile.id),
+        };
+
+        const result = await backendActor.make_new_chat_room(newChat);
+        if ("Ok" in result) {
+          // Add new chat to local state
+          setChats((prevChats) => [...prevChats, newChat]);
+          // Open the new chat window
+          handleOpenChat(newChat);
+        } else {
+          console.log("Failed to create chat:", result.Err);
+        }
+      } catch (error) {
+        console.log("Error creating chat:", error);
+      }
+
+      setCreateGroupOpen(false);
+    },
+    [backendActor, profile?.id, handleOpenChat],
+  );
+
+  const handleSendMessage = useCallback(
+    async (chatId: string, messageText: string) => {
+      if (!profile?.id || !messageText.trim()) return;
+
+      const chat = chats.find((c) => c.id === chatId);
+      if (!chat) return;
+
+      const newMessage: Message = {
+        id: randomString(),
+        date: BigInt(Date.now() * 1e6),
+        sender: Principal.fromText(profile.id),
+        seen_by: [Principal.fromText(profile.id)],
+        message: messageText, // Use the actual message text
+        chat_id: chatId,
+      };
+
+      try {
+        // Send message to backend with recipients
+        const res = await backendActor?.send_message([], newMessage);
+        // console.log("Message sent:", { res });
+
+        // Update local state
+        setChats((prevChats) =>
+          prevChats.map((chat) =>
+            chat.id === chatId
+              ? { ...chat, messages: [...chat.messages, newMessage] }
+              : chat,
+          ),
+        );
+      } catch (error) {
+        console.error("Error sending message:", error);
+      }
+    },
+    [profile, backendActor, chats],
+  );
+
+  const open = anchorEl && Boolean(anchorEl);
+  const { all_friends, workspaces } = useSelector(
+    (state: any) => state.filesState,
+  );
+
+  return (
+    <>
+      <IconButton
+        onClick={handleClick}
+        aria-controls={open ? "chat-menu" : undefined}
+        aria-haspopup="true"
+        aria-expanded={open ? "true" : undefined}
+      >
+        <Badge badgeContent={totalUnseenMessages} color="error">
+          <ChatIcon />
+        </Badge>
+      </IconButton>
+
+      <Menu
+        id="chat-menu"
+        anchorEl={anchorEl}
+        open={open}
+        onClose={handleClose}
+        PaperProps={{
+          sx: {
+            maxHeight: 500,
+            width: 320,
+          },
+        }}
+        transformOrigin={{ horizontal: "right", vertical: "top" }}
+        anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
+      >
+        <MenuItem sx={{ justifyContent: "center" }}>
+          <Button
+            startIcon={<AddIcon />}
+            variant="outlined"
+            fullWidth
+            onClick={() => setCreateGroupOpen(true)}
+          >
+            Create New Group
+          </Button>
+        </MenuItem>
+
+        <ChatList
+          chats={chats}
+          onChatClick={handleChatClick}
+          currentUserId={profile?.id}
+        />
+      </Menu>
+
+      {Array.from(openChats.entries()).map(([chatId, position]) => {
+        const chat = chats.find((c) => c.id === chatId);
+        if (!chat) return null;
+
+        return (
+          <ChatWindow
+            key={chatId}
+            chat={chat}
+            position={position}
+            onClose={handleCloseChat}
+            onPositionChange={handleChatPosition}
+            onSendMessage={(currentChatId, message) =>
+              handleSendMessage(chatId, message)
+            }
+            user={profile}
+          />
+        );
+      })}
+
+      <CreateGroupDialog
+        open={createGroupOpen}
+        onClose={() => setCreateGroupOpen(false)}
+        onSubmit={handleCreateGroup}
+        initialData={{
+          name: "",
+          members: [],
+          admins: [],
+          // workspace: currentWorkspace ? [currentWorkspace] : [],
+          workspace: currentWorkspace.name !== "default"? [currentWorkspace.id] : []
+        }}
+        users={all_friends}
+        workspaces={workspaces}
+      />
+    </>
+  );
+};
+
+export default ChatNotifications;
+  at /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/index.tsx if the current workspaces is defualt show the workspaces names in the list next to secondary={
+                  chat.messages[chat.messages.length - 1]?.message ||
+                  "No messages"
+                }

# 2024-12-24 16:30:35.665155
+ncaught ReferenceError: workspaces is not defined
+    at index.tsx:250:27
+    at Array.map (<anonymous>)

# 2024-12-24 16:33:50.027395
+import React, { memo, useCallback, useMemo, useState } from "react";
+import {
+  Autocomplete,
+  Avatar,
+  Badge,
+  Box,
+  Button,
+  Chip,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogTitle,
+  FormControl,
+  IconButton,
+  InputLabel,
+  List,
+  ListItem,
+  ListItemAvatar,
+  ListItemText,
+  Menu,
+  MenuItem,
+  Select,
+  TextField,
+  Typography,
+} from "@mui/material";
+
+import {
+  Add as AddIcon,
+  Chat as ChatIcon,
+  Group as GroupIcon,
+} from "@mui/icons-material";
+import ChatWindow from "./chatWindow";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSelector } from "react-redux";
+import formatTimestamp from "../../utils/time";
+import { Chat, Message } from "../../../declarations/backend/backend.did";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+
+// Memoized form components
+const GroupNameField = memo(({ value, onChange }) => (
+  <TextField
+    label="Group Name"
+    value={value}
+    onChange={(e) => onChange(e.target.value)}
+    fullWidth
+  />
+));
+
+export const MembersSelect = memo(({ value, onChange, users }) => (
+  <Autocomplete
+    multiple
+    options={users}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Members" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const AdminsSelect = memo(({ value, onChange, members }) => (
+  <Autocomplete
+    multiple
+    options={members}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Select Admins" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+export const WorkspaceSelect = memo(({ value, onChange, workspaces }) => (
+  <Autocomplete
+    multiple
+    options={workspaces}
+    getOptionLabel={(option) => option.name}
+    value={value}
+    onChange={(_, newValue) => onChange(newValue)}
+    renderInput={(params) => <TextField {...params} label="Workspaces" />}
+    renderTags={(value, getTagProps) =>
+      value.map((option, index) => (
+        <Chip label={option.name} {...getTagProps({ index })} />
+      ))
+    }
+  />
+));
+
+// Memoized Create Group Dialog
+const CreateGroupDialog = memo(
+  ({ open, onClose, onSubmit, initialData, users, workspaces }) => {
+    const [formData, setFormData] = useState(initialData);
+
+    const handleNameChange = useCallback((name) => {
+      setFormData((prev) => ({ ...prev, name }));
+    }, []);
+
+    const handleMembersChange = useCallback((members) => {
+      setFormData((prev) => ({ ...prev, members }));
+    }, []);
+
+    const handleAdminsChange = useCallback((admins) => {
+      setFormData((prev) => ({ ...prev, admins }));
+    }, []);
+
+    const handleWorkspaceChange = useCallback((workspace) => {
+      setFormData((prev) => ({ ...prev, workspace }));
+    }, []);
+
+    const handleSubmit = useCallback(async () => {
+      await onSubmit(formData);
+    }, [formData, onSubmit]);
+
+    return (
+      <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
+        <DialogTitle>Create New Group Chat</DialogTitle>
+        <DialogContent>
+          <Box sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}>
+            <GroupNameField value={formData.name} onChange={handleNameChange} />
+            <MembersSelect
+              value={formData.members}
+              onChange={handleMembersChange}
+              users={users}
+            />
+            <AdminsSelect
+              value={formData.admins}
+              onChange={handleAdminsChange}
+              members={formData.members}
+            />
+            <WorkspaceSelect
+              value={formData.workspace}
+              onChange={handleWorkspaceChange}
+              workspaces={workspaces}
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={onClose}>Cancel</Button>
+          <Button onClick={handleSubmit} variant="contained" color="primary">
+            Create Group
+          </Button>
+        </DialogActions>
+      </Dialog>
+    );
+  },
+);
+
+const ChatList = memo(
+  ({
+    chats,
+    onChatClick,
+    currentUserId,
+  }: {
+    chats: Chat[];
+    onChatClick: (chat: Chat) => void;
+    currentUserId: string;
+  }) => {
+    const { currentWorkspace } = useSelector((state: any) => state.filesState);
+    // Calculate unread count for each chat if not already present
+    const chatsWithUnread = chats
+      .filter(chat => 
+        // Include chat if it's in current workspace or if current workspace is default
+        currentWorkspace.name === "default" || 
+        chat.workspaces.includes(currentWorkspace.id)
+      )
+      .map((chat) => {
+        if ("unread" in chat) return chat;
+
+        const unseenCount = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === currentUserId,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+
+      return {
+        ...chat,
+        unread: unseenCount,
+      };
+    });
+
+    const { all_friends, workspaces } = useSelector((state: any) => state.filesState);
+
+    const getOtherUser = (chat) => {
+      if (chat.name !== "private_chat") return null;
+      console.log({ chat, all_friends, currentUserId });
+      return all_friends.find(
+        (f) =>
+          chat.admins.map((a) => a.id)?.includes(f.id) &&
+          f.id !== currentUserId,
+      );
+    };
+
+    return (
+      <List sx={{ padding: 0, width: "100%" }}>
+        {chatsWithUnread.map((chat) => {
+          const otherUser = getOtherUser(chat);
+
+          return (
+            <ListItem
+              key={chat.id}
+              onClick={() => onChatClick(chat)}
+              button
+              sx={{
+                borderBottom: 1,
+                borderColor: "divider",
+                "&:hover": { backgroundColor: "action.hover" },
+              }}
+            >
+              <ListItemAvatar>
+                {chat.name === "private_chat" ? (
+                  <Avatar src={otherUser?.avatar}>
+                    {otherUser?.name?.charAt(0)}
+                  </Avatar>
+                ) : (
+                  <Avatar>
+                    <GroupIcon />
+                  </Avatar>
+                )}
+              </ListItemAvatar>
+              <ListItemText
+                primary={
+                  <Box
+                    sx={{ display: "flex", justifyContent: "space-between" }}
+                  >
+                    <Typography variant="subtitle2">
+                      {chat.name === "private_chat"
+                        ? otherUser?.name || "Unknown User"
+                        : chat.name}
+                    </Typography>
+                    {chat.unread > 0 && (
+                      <Badge badgeContent={chat.unread} color="error" />
+                    )}
+                  </Box>
+                }
+                secondary={
+                  <>
+                    {chat.messages[chat.messages.length - 1]?.message || "No messages"}
+                    {currentWorkspace.name === "default" && chat.workspaces.length > 0 && (
+                      <Typography component="span" sx={{ ml: 1, color: 'text.secondary' }}>
+                        [{workspaces.filter(w => chat.workspaces.includes(w.id)).map(w => w.name).join(', ')}]
+                      </Typography>
+                    )}
+                  </>
+                }
+              />
+            </ListItem>
+          );
+        })}
+      </List>
+    );
+  },
+);
+
+const ChatNotifications = ({ chats: initialChats }: { chats: Chat[] }) => {
+  const [openChats, setOpenChats] = useState(
+    new Map<string, { x: number; y: number }>(),
+  );
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [createGroupOpen, setCreateGroupOpen] = useState(false);
+  const [chats, setChats] = useState<Chat[]>(initialChats || []);
+
+  const { backendActor } = useBackendContext();
+  const { profile, currentWorkspace } = useSelector(
+    (state: any) => state.filesState,
+  );
+
+  // Calculate total unseen messages across all chats
+  const totalUnseenMessages = useMemo(() => {
+    if (!profile?.id) return 0;
+
+    return chats.reduce((total, chat) => {
+      const unseenInChat = chat.messages.reduce((count, message) => {
+        const isSeen = message.seen_by.some(
+          (user) => user.toString() === profile.id,
+        );
+        return count + (isSeen ? 0 : 1);
+      }, 0);
+      return total + unseenInChat;
+    }, 0);
+  }, [chats, profile?.id]);
+
+  const handleOpenChat = useCallback((chat: Chat) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      if (!newChats.has(chat.id)) {
+        const offset = newChats.size * 30;
+        newChats.set(chat.id, {
+          x: 100 + offset,
+          y: 100 + offset,
+        });
+      }
+      return newChats;
+    });
+  }, []);
+
+  const handleCloseChat = useCallback((chatId: string) => {
+    setOpenChats((prev) => {
+      const newChats = new Map(prev);
+      newChats.delete(chatId);
+      return newChats;
+    });
+  }, []);
+
+  const handleChatPosition = useCallback(
+    (chatId: string, position: { x: number; y: number }) => {
+      setOpenChats((prev) => {
+        const newChats = new Map(prev);
+        newChats.set(chatId, position);
+        return newChats;
+      });
+    },
+    [],
+  );
+
+  const handleClick = useCallback(
+    (event: React.MouseEvent<HTMLButtonElement>) => {
+      setAnchorEl(event.currentTarget);
+    },
+    [],
+  );
+
+  const handleClose = useCallback(() => {
+    setAnchorEl(null);
+  }, []);
+
+  const handleChatClick = useCallback(
+    async (chat: Chat) => {
+      try {
+        // Get latest unseen message
+        const unseenMessages = chat.messages.filter((message) => {
+          const isSeen = message.seen_by.some(
+            (user) => user.toString() === profile?.id,
+          );
+          return !isSeen;
+        });
+
+        // Update local state immediately
+        setChats((prevChats) =>
+          prevChats.map((prevChat) => {
+            if (prevChat.id !== chat.id) return prevChat;
+
+            // Update all messages' seen status for this chat
+            const updatedMessages = prevChat.messages.map((msg) => ({
+              ...msg,
+              seen_by: msg.seen_by.some(
+                (user) => user.toString() === profile?.id,
+              )
+                ? msg.seen_by
+                : [...msg.seen_by, Principal.fromText(profile?.id)],
+            }));
+
+            return {
+              ...prevChat,
+              messages: updatedMessages,
+              unread: 0, // Add unread property and set to 0
+            };
+          }),
+        );
+
+        // Call backend if there are unseen messages
+
+        handleOpenChat(chat);
+        handleClose();
+
+        if (unseenMessages.length > 0) {
+          const latestMessage = unseenMessages[unseenMessages.length - 1];
+          const messageForBackend = {
+            ...latestMessage,
+            date: BigInt(0),
+            sender: Principal.fromText(latestMessage.sender.toString()),
+            seen_by: [],
+            chat_id: chat.id,
+          };
+
+          await backendActor?.message_is_seen(messageForBackend);
+        }
+      } catch (error) {
+        console.error("Error marking messages as seen:", error);
+        handleOpenChat(chat);
+        handleClose();
+      }
+    },
+    [profile?.id, backendActor, handleOpenChat, handleClose],
+  );
+
+  const handleCreateGroup = useCallback(
+    async (formData: any) => {
+      if (!backendActor || !profile?.id) return;
+
+      try {
+        const newChat: Chat = {
+          id: randomString(),
+          name: formData.name || "Untitled",
+          messages: [],
+          members:
+            formData.members?.length > 0
+              ? formData.members.map((m) => Principal.fromText(m.id))
+              : [Principal.fromText(profile.id)],
+          admins:
+            formData.admins?.length > 0
+              ? formData.admins.map((a) => Principal.fromText(a.id))
+              : [Principal.fromText(profile.id)],
+          workspaces:
+            formData.workspace?.length > 0
+              ? formData.workspace.map((w) => w.id)
+              : currentWorkspace && currentWorkspace.name !== "default"
+                ? [currentWorkspace.id]
+                : [],
+          creator: Principal.fromText(profile.id),
+        };
+
+        const result = await backendActor.make_new_chat_room(newChat);
+        if ("Ok" in result) {
+          // Add new chat to local state
+          setChats((prevChats) => [...prevChats, newChat]);
+          // Open the new chat window
+          handleOpenChat(newChat);
+        } else {
+          console.log("Failed to create chat:", result.Err);
+        }
+      } catch (error) {
+        console.log("Error creating chat:", error);
+      }
+
+      setCreateGroupOpen(false);
+    },
+    [backendActor, profile?.id, handleOpenChat],
+  );
+
+  const handleSendMessage = useCallback(
+    async (chatId: string, messageText: string) => {
+      if (!profile?.id || !messageText.trim()) return;
+
+      const chat = chats.find((c) => c.id === chatId);
+      if (!chat) return;
+
+      const newMessage: Message = {
+        id: randomString(),
+        date: BigInt(Date.now() * 1e6),
+        sender: Principal.fromText(profile.id),
+        seen_by: [Principal.fromText(profile.id)],
+        message: messageText, // Use the actual message text
+        chat_id: chatId,
+      };
+
+      try {
+        // Send message to backend with recipients
+        const res = await backendActor?.send_message([], newMessage);
+        // console.log("Message sent:", { res });
+
+        // Update local state
+        setChats((prevChats) =>
+          prevChats.map((chat) =>
+            chat.id === chatId
+              ? { ...chat, messages: [...chat.messages, newMessage] }
+              : chat,
+          ),
+        );
+      } catch (error) {
+        console.error("Error sending message:", error);
+      }
+    },
+    [profile, backendActor, chats],
+  );
+
+  const open = anchorEl && Boolean(anchorEl);
+  const { all_friends, workspaces } = useSelector(
+    (state: any) => state.filesState,
+  );
+
+  return (
+    <>
+      <IconButton
+        onClick={handleClick}
+        aria-controls={open ? "chat-menu" : undefined}
+        aria-haspopup="true"
+        aria-expanded={open ? "true" : undefined}
+      >
+        <Badge badgeContent={totalUnseenMessages} color="error">
+          <ChatIcon />
+        </Badge>
+      </IconButton>
+
+      <Menu
+        id="chat-menu"
+        anchorEl={anchorEl}
+        open={open}
+        onClose={handleClose}
+        PaperProps={{
+          sx: {
+            maxHeight: 500,
+            width: 320,
+          },
+        }}
+        transformOrigin={{ horizontal: "right", vertical: "top" }}
+        anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
+      >
+        <MenuItem sx={{ justifyContent: "center" }}>
+          <Button
+            startIcon={<AddIcon />}
+            variant="outlined"
+            fullWidth
+            onClick={() => setCreateGroupOpen(true)}
+          >
+            Create New Group
+          </Button>
+        </MenuItem>
+
+        <ChatList
+          chats={chats}
+          onChatClick={handleChatClick}
+          currentUserId={profile?.id}
+        />
+      </Menu>
+
+      {Array.from(openChats.entries()).map(([chatId, position]) => {
+        const chat = chats.find((c) => c.id === chatId);
+        if (!chat) return null;
+
+        return (
+          <ChatWindow
+            key={chatId}
+            chat={chat}
+            position={position}
+            onClose={handleCloseChat}
+            onPositionChange={handleChatPosition}
+            onSendMessage={(currentChatId, message) =>
+              handleSendMessage(chatId, message)
+            }
+            user={profile}
+          />
+        );
+      })}
+
+      <CreateGroupDialog
+        open={createGroupOpen}
+        onClose={() => setCreateGroupOpen(false)}
+        onSubmit={handleCreateGroup}
+        initialData={{
+          name: "",
+          members: [],
+          admins: [],
+          // workspace: currentWorkspace ? [currentWorkspace] : [],
+          workspace: currentWorkspace.name !== "default"? [currentWorkspace.id] : []
+        }}
+        users={all_friends}
+        workspaces={workspaces}
+      />
+    </>
+  );
+};
+
+export default ChatNotifications;
+at /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/index.tsx when users click <Button onClick={handleSubmit} variant="contained" color="primary">
+            Create Group
+          </Button> show loading whihle wating for await onSubmit(formData);

# 2024-12-24 16:38:11.934538
+import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+  Button, 
+  Autocomplete, 
+  Chip,
+} from "@mui/material";
+import {MembersSelect, AdminsSelect, WorkspaceSelect} from './index';
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+  ArrowBack as ArrowBackIcon,
+  Delete as DeleteIcon,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useDispatch, useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import { Link } from "react-router-dom";
+import { Chat } from "../../../declarations/backend/backend.did";
+import { handleRedux } from "../../redux/store/handleRedux";
+
+const ChatWindow = memo(
+  ({
+    chat,
+    onClose,
+    position,
+    onPositionChange,
+    onSendMessage,
+    onUpdateChat,
+  }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [selectedWorkspace, setSelectedWorkspace] = useState(
+      chat.workspaces[0] || "",
+    );
+    const [editedMembers, setEditedMembers] = useState(chat.members);
+    const { workspaces, all_friends, profile } = useSelector(
+      (state: any) => state.filesState,
+    );
+    const { backendActor } = useBackendContext();
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+    const [editedName, setEditedName] = useState(chat.name);
+    const [isSaving, setIsSaving] = useState(false);
+    const messagesEndRef = useRef(null);
+
+    useEffect(() => {
+      setSelectedWorkspace(chat.workspaces[0] || "");
+      setEditedMembers(chat.members);
+    }, [chat]);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+    const dispatch = useDispatch();
+
+    const handleSaveChat = async (updatedChat: Chat) => {
+      setIsSaving(true);
+      try {
+        // Convert all Principals to the correct format before sending
+        const formattedChat = {
+          ...updatedChat,
+          admins: updatedChat.admins.map(a => 
+            typeof a === 'string' ? Principal.fromText(a) : Principal.fromText(a.toString())
+          ),
+          creator: typeof updatedChat.creator === 'string' 
+            ? Principal.fromText(updatedChat.creator) 
+            : Principal.fromText(updatedChat.creator.toString()),
+          members: updatedChat.members.map(m => 
+            typeof m === 'string' ? Principal.fromText(m) : Principal.fromText(m.toString())
+          ),
+          messages: updatedChat.messages.map(msg => ({
+            ...msg,
+            sender: typeof msg.sender === 'string' 
+              ? Principal.fromText(msg.sender) 
+              : Principal.fromText(msg.sender.toString()),
+            seen_by: msg.seen_by.map(s => 
+              typeof s === 'string' ? Principal.fromText(s) : Principal.fromText(s.toString())
+            ),
+            date: BigInt(msg.date.toString())
+          }))
+        };
+
+        const result = await backendActor.update_chat(formattedChat);
+        if ("Ok" in result) {
+          if (onUpdateChat) {
+            onUpdateChat(result.Ok);
+          }
+          // Update local state
+          setSelectedWorkspace(result.Ok.workspaces[0] || "");
+          setEditedMembers(result.Ok.members);
+          setEditedName(result.Ok.name);
+        }
+      } catch (error) {
+        console.error("Failed to update chat:", error);
+      } finally {
+        setIsSaving(false);
+      }
+    };
+
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            {isSettingsView ? (
+              <IconButton size="small" onClick={() => setIsSettingsView(false)}>
+                <ArrowBackIcon />
+              </IconButton>
+            ) : (
+              <IconButton size="small" onClick={() => setIsSettingsView(true)}>
+                <SettingsIcon />
+              </IconButton>
+            )}
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && !isSettingsView && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography
+                      to={`user?id=${message.sender.toString()}`}
+                      component={Link}
+                      variant="subtitle2"
+                    >
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+
+        {!isMinimized && isSettingsView && (
+          <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Chat Settings
+            </Typography>
+
+            {chat.creator?.id !== profile?.id ? (
+              <Typography color="error">
+                Only the chat creator can modify settings
+              </Typography>
+            ) : chat.name === "private_chat" ? (
+              <FormControl fullWidth sx={{ mb: 2 }}>
+                <InputLabel>Workspace</InputLabel>
+                <Select
+                  value={selectedWorkspace}
+                  label="Workspace"
+                  onChange={(e) => setSelectedWorkspace(e.target.value)}
+                >
+                  {workspaces.map((workspace) => (
+                    <MenuItem key={workspace.id} value={workspace.id}>
+                      {workspace.name}
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            ) : (
+              <>
+                <TextField
+                  fullWidth
+                  label="Chat Name"
+                  value={editedName}
+                  onChange={(e) => setEditedName(e.target.value)}
+                  sx={{ mb: 2 }}
+                />
+                <WorkspaceSelect
+                  value={workspaces.filter(w => chat.workspaces.includes(w.id))}
+                  onChange={(newValue) => {
+                    const updatedChat = {
+                      ...chat,
+                      workspaces: newValue.map(w => w.id)
+                    };
+                    handleSaveChat(updatedChat);
+                  }}
+                  workspaces={workspaces}
+                />
+
+                <AdminsSelect
+                  value={all_friends.filter(f => chat.admins.some(a => a.toString() === f.id))}
+                  onChange={(newValue) => {
+                    const updatedChat = {
+                      ...chat,
+                      admins: newValue.map(admin => admin.id)
+                    };
+                    handleSaveChat(updatedChat);
+                  }}
+                  members={all_friends}
+                />
+
+                <MembersSelect
+                  value={all_friends.filter(f => chat.members.some(m => m.toString() === f.id))}
+                  onChange={(newValue) => {
+                    const updatedChat = {
+                      ...chat,
+                      members: newValue.map(member => member.id)
+                    };
+                    handleSaveChat(updatedChat);
+                  }}
+                  users={all_friends}
+                />
+
+                <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
+                  <Button
+                    variant="contained"
+                    color="primary"
+                    fullWidth
+                    disabled={isSaving}
+                    onClick={() => {
+                      const updatedChat: Chat = {
+                        ...chat,
+                        name: editedName,
+                        admins: chat.admins.map((a) =>
+                          Principal.fromText(a.id),
+                        ),
+                        creator: Principal.fromText(chat.creator.id),
+                        workspaces: [selectedWorkspace],
+                        members: editedMembers,
+                      };
+                      handleSaveChat(updatedChat);
+                      setIsSettingsView(false);
+                    }}
+                  >
+                    Save Changes
+                  </Button>
+
+                  {chat.name !== "private_chat" && (
+                    <Button
+                      variant="contained"
+                      color="error"
+                      onClick={() => {
+                        if (
+                          window.confirm(
+                            "Are you sure you want to delete this chat? This action cannot be undone.",
+                          )
+                        ) {
+                          backendActor
+                            .delete_chat(chat.id)
+                            .then((result) => {
+                              if ("Ok" in result && onClose) {
+                                dispatch(
+                                  handleRedux("DELETE_CHAT", {
+                                    chat_id: chat.id,
+                                  }),
+                                );
+                                onClose(chat.id);
+                              }
+                            })
+                            .catch((error) => {
+                              console.error("Failed to delete chat:", error);
+                            });
+                        }
+                      }}
+                    >
+                      Delete Chat
+                    </Button>
+                  )}
+                </Box>
+              </>
+            )}
+          </Box>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+at /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx do not call handleSaveChat(updatedChat); at <WorkspaceSelect
+                  value={workspaces.filter(w => chat.workspaces.includes(w.id))}
+                  onChange={(newValue) => {
+                    const updatedChat = {
+                      ...chat,
+                      workspaces: newValue.map(w => w.id)
+                    };
+                    handleSaveChat(updatedChat);
+                  }}
+                  workspaces={workspaces}
+                /> or at AdminsSelect or at MembersSelect instead call setFormData const [formData, setFormData] = useState({}); and render fromatData in the selects value

# 2024-12-24 16:42:12.560680
+Failed to update chat: Error: Invalid character: "["
+    at decodeChar (chunk-XK4JVWQX.js?v=06f71419:39:13)
+    at decode (chunk-XK4JVWQX.js?v=06f71419:55:5)
+    at _Principal.fromText (chunk-XK4JVWQX.js?v=06f71419:794:19)
+    at chatWindow.tsx:171:71
+    at Array.map (<anonymous>)
+    at handleSaveChat (chatWindow.tsx:170:38)
+    at onClick (chatWindow.tsx:422:23)
+    at HTMLUnknownElement.callCallback2 (chunk-WMDJOG6V.js?v=06f71419:3674:22)
+    at Object.invokeGuardedCallbackDev (chunk-WMDJOG6V.js?v=06f71419:3699:24)
+    at invokeGuardedCallback (chunk-WMDJOG6V.js?v=06f71419:3733:39) at my code import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+  Button, 
+  Autocomplete, 
+  Chip,
+} from "@mui/material";
+import {MembersSelect, AdminsSelect, WorkspaceSelect} from './index';
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+  ArrowBack as ArrowBackIcon,
+  Delete as DeleteIcon,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useDispatch, useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import { Link } from "react-router-dom";
+import { Chat } from "../../../declarations/backend/backend.did";
+import { handleRedux } from "../../redux/store/handleRedux";
+
+const ChatWindow = memo(
+  ({
+    chat,
+    onClose,
+    position,
+    onPositionChange,
+    onSendMessage,
+    onUpdateChat,
+  }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [formData, setFormData] = useState({
+      name: chat.name,
+      workspaces: chat.workspaces,
+      admins: chat.admins,
+      members: chat.members
+    });
+    const { workspaces, all_friends, profile } = useSelector(
+      (state: any) => state.filesState,
+    );
+    const { backendActor } = useBackendContext();
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+    const [editedName, setEditedName] = useState(chat.name);
+    const [isSaving, setIsSaving] = useState(false);
+    const messagesEndRef = useRef(null);
+
+    useEffect(() => {
+      // setSelectedWorkspace(chat.workspaces[0] || "");
+      // setEditedMembers(chat.members);
+    }, [chat]);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+    const dispatch = useDispatch();
+
+    const handleSaveChat = async (updatedChat: Chat) => {
+      setIsSaving(true);
+      try {
+        // Convert all Principals to the correct format before sending
+        const formattedChat = {
+          ...updatedChat,
+          admins: updatedChat.admins.map(a => 
+            typeof a === 'string' ? Principal.fromText(a) : Principal.fromText(a.toString())
+          ),
+          creator: typeof updatedChat.creator === 'string' 
+            ? Principal.fromText(updatedChat.creator) 
+            : Principal.fromText(updatedChat.creator.toString()),
+          members: updatedChat.members.map(m => 
+            typeof m === 'string' ? Principal.fromText(m) : Principal.fromText(m.toString())
+          ),
+          messages: updatedChat.messages.map(msg => ({
+            ...msg,
+            sender: typeof msg.sender === 'string' 
+              ? Principal.fromText(msg.sender) 
+              : Principal.fromText(msg.sender.toString()),
+            seen_by: msg.seen_by.map(s => 
+              typeof s === 'string' ? Principal.fromText(s) : Principal.fromText(s.toString())
+            ),
+            date: BigInt(msg.date.toString())
+          }))
+        };
+
+        const result = await backendActor.update_chat(formattedChat);
+        if ("Ok" in result) {
+          if (onUpdateChat) {
+            onUpdateChat(result.Ok);
+          }
+          // Update local state
+          setSelectedWorkspace(result.Ok.workspaces[0] || "");
+          setEditedMembers(result.Ok.members);
+          setEditedName(result.Ok.name);
+        }
+      } catch (error) {
+        console.error("Failed to update chat:", error);
+      } finally {
+        setIsSaving(false);
+      }
+    };
+
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            {isSettingsView ? (
+              <IconButton size="small" onClick={() => setIsSettingsView(false)}>
+                <ArrowBackIcon />
+              </IconButton>
+            ) : (
+              <IconButton size="small" onClick={() => setIsSettingsView(true)}>
+                <SettingsIcon />
+              </IconButton>
+            )}
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && !isSettingsView && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography
+                      to={`user?id=${message.sender.toString()}`}
+                      component={Link}
+                      variant="subtitle2"
+                    >
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+
+        {!isMinimized && isSettingsView && (
+          <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Chat Settings
+            </Typography>
+
+            {chat.creator?.id !== profile?.id ? (
+              <Typography color="error">
+                Only the chat creator can modify settings
+              </Typography>
+            ) : chat.name === "private_chat" ? (
+              <FormControl fullWidth sx={{ mb: 2 }}>
+                <InputLabel>Workspace</InputLabel>
+                <Select
+                  value={selectedWorkspace}
+                  label="Workspace"
+                  onChange={(e) => setSelectedWorkspace(e.target.value)}
+                >
+                  {workspaces.map((workspace) => (
+                    <MenuItem key={workspace.id} value={workspace.id}>
+                      {workspace.name}
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            ) : (
+              <>
+                <TextField
+                  fullWidth
+                  label="Chat Name"
+                  value={formData.name}
+                  onChange={(e) => setFormData(prev => ({...prev, name: e.target.value}))}
+                  sx={{ mb: 2 }}
+                />
+                <WorkspaceSelect
+                  value={workspaces.filter(w => formData.workspaces.includes(w.id))}
+                  onChange={(newValue) => {
+                    setFormData(prev => ({
+                      ...prev,
+                      workspaces: newValue.map(w => w.id)
+                    }));
+                  }}
+                  workspaces={workspaces}
+                />
+
+                <AdminsSelect
+                  value={all_friends.filter(f => formData.admins.some(a => a.toString() === f.id))}
+                  onChange={(newValue) => {
+                    setFormData(prev => ({
+                      ...prev,
+                      admins: newValue.map(admin => admin.id)
+                    }));
+                  }}
+                  members={all_friends}
+                />
+
+                <MembersSelect
+                  value={all_friends.filter(f => formData.members.some(m => m.toString() === f.id))}
+                  onChange={(newValue) => {
+                    setFormData(prev => ({
+                      ...prev,
+                      members: newValue.map(member => member.id)
+                    }));
+                  }}
+                  users={all_friends}
+                />
+
+                <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
+                  <Button
+                    variant="contained"
+                    color="primary"
+                    fullWidth
+                    disabled={isSaving}
+                    onClick={() => {
+                      const updatedChat: Chat = {
+                        ...chat,
+                        name: formData.name,
+                        admins: formData.admins,
+                        creator: Principal.fromText(chat.creator.id),
+                        workspaces: formData.workspaces,
+                        members: formData.members,
+                      };
+                      handleSaveChat(updatedChat);
+                      setIsSettingsView(false);
+                    }}
+                  >
+                    Save Changes
+                  </Button>
+
+                  {chat.name !== "private_chat" && (
+                    <Button
+                      variant="contained"
+                      color="error"
+                      onClick={() => {
+                        if (
+                          window.confirm(
+                            "Are you sure you want to delete this chat? This action cannot be undone.",
+                          )
+                        ) {
+                          backendActor
+                            .delete_chat(chat.id)
+                            .then((result) => {
+                              if ("Ok" in result && onClose) {
+                                dispatch(
+                                  handleRedux("DELETE_CHAT", {
+                                    chat_id: chat.id,
+                                  }),
+                                );
+                                onClose(chat.id);
+                              }
+                            })
+                            .catch((error) => {
+                              console.error("Failed to delete chat:", error);
+                            });
+                        }
+                      }}
+                    >
+                      Delete Chat
+                    </Button>
+                  )}
+                </Box>
+              </>
+            )}
+          </Box>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+

# 2024-12-24 16:43:01.671482
+Uncaught TypeError: text.includes is not a function
+    at chatWindow.tsx:417:115
+    at Array.map (<anonymous>)
+    at onClick (chatWindow.tsx:417:49)
+

# 2024-12-24 16:59:51.957743
+after user click `Save Changes` show a loadder while waiting for .update_chat and then green check mark

# 2024-12-24 17:00:18.000872
+ after user click `Save Changes` show a loadder while waiting for .update_chat and then green check mark   here is my full code ```import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+  Button,
+  Autocomplete,
+  Chip,
+} from "@mui/material";
+import { MembersSelect, AdminsSelect, WorkspaceSelect } from "./index";
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+  ArrowBack as ArrowBackIcon,
+  Delete as DeleteIcon,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useDispatch, useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import { Link } from "react-router-dom";
+import { Chat } from "../../../declarations/backend/backend.did";
+import { handleRedux } from "../../redux/store/handleRedux";
+
+const ChatWindow = memo(
+  ({
+    chat,
+    onClose,
+    position,
+    onPositionChange,
+    onSendMessage,
+    onUpdateChat,
+  }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [formData, setFormData] = useState({
+      name: chat.name,
+      workspaces: chat.workspaces,
+      admins: chat.admins,
+      members: chat.members,
+    });
+    const { workspaces, all_friends, profile } = useSelector(
+      (state: any) => state.filesState,
+    );
+    const { backendActor } = useBackendContext();
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+    const [editedName, setEditedName] = useState(chat.name);
+    const [isSaving, setIsSaving] = useState(false);
+    const messagesEndRef = useRef(null);
+
+    useEffect(() => {
+      // setSelectedWorkspace(chat.workspaces[0] || "");
+      // setEditedMembers(chat.members);
+    }, [chat]);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+    const dispatch = useDispatch();
+
+    const handleSaveChat = async (updatedChat: Chat) => {
+      setIsSaving(true);
+      try {
+        // Keep existing Principals if they're already Principal objects
+        const formattedChat = {
+          ...updatedChat,
+          admins: updatedChat.admins.map((a) => Principal.fromText(a.id || a)),
+          creator:
+            updatedChat.creator instanceof Principal
+              ? updatedChat.creator
+              : Principal.fromText(updatedChat.creator.id),
+          members: updatedChat.members.map((m) =>
+            Principal.fromText(m.id || m),
+          ),
+          messages: updatedChat.messages.map((msg) => ({
+            ...msg,
+            sender:
+              msg.sender instanceof Principal
+                ? msg.sender
+                : Principal.fromText(msg.sender),
+            seen_by: msg.seen_by.map((s) =>
+              s instanceof Principal ? s : Principal.fromText(s),
+            ),
+            date:
+              typeof msg.date === "bigint"
+                ? msg.date
+                : BigInt(msg.date.toString()),
+          })),
+        };
+        const result = await backendActor.update_chat(formattedChat);
+        if ("Ok" in result) {
+          if (onUpdateChat) {
+            onUpdateChat(result.Ok);
+          }
+          // Update local state
+          // setSelectedWorkspace(result.Ok.workspaces[0] || "");
+          // setEditedMembers(result.Ok.members);
+          setEditedName(result.Ok.name);
+        }
+      } catch (error) {
+        console.error("Failed to update chat:", error);
+      } finally {
+        setIsSaving(false);
+      }
+    };
+
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            {isSettingsView ? (
+              <IconButton size="small" onClick={() => setIsSettingsView(false)}>
+                <ArrowBackIcon />
+              </IconButton>
+            ) : (
+              <IconButton size="small" onClick={() => setIsSettingsView(true)}>
+                <SettingsIcon />
+              </IconButton>
+            )}
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && !isSettingsView && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography
+                      to={`user?id=${message.sender.toString()}`}
+                      component={Link}
+                      variant="subtitle2"
+                    >
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+
+        {!isMinimized && isSettingsView && (
+          <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Chat Settings
+            </Typography>
+
+            {chat.creator?.id !== profile?.id ? (
+              <Typography color="error">
+                Only the chat creator can modify settings
+              </Typography>
+            ) : chat.name === "private_chat" ? (
+              <FormControl fullWidth sx={{ mb: 2 }}>
+                <InputLabel>Workspace</InputLabel>
+                <Select
+                  value={selectedWorkspace}
+                  label="Workspace"
+                  onChange={(e) => setSelectedWorkspace(e.target.value)}
+                >
+                  {workspaces.map((workspace) => (
+                    <MenuItem key={workspace.id} value={workspace.id}>
+                      {workspace.name}
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            ) : (
+              <>
+                <TextField
+                  fullWidth
+                  label="Chat Name"
+                  value={formData.name}
+                  onChange={(e) =>
+                    setFormData((prev) => ({ ...prev, name: e.target.value }))
+                  }
+                  sx={{ mb: 2 }}
+                />
+                <WorkspaceSelect
+                  value={workspaces.filter((w) =>
+                    formData.workspaces.includes(w.id),
+                  )}
+                  onChange={(newValue) => {
+                    setFormData((prev) => ({
+                      ...prev,
+                      workspaces: newValue.map((w) => w.id),
+                    }));
+                  }}
+                  workspaces={workspaces}
+                />
+
+                <AdminsSelect
+                  value={all_friends.filter((f) =>
+                    formData.admins.some((a) => a.toString() === f.id),
+                  )}
+                  onChange={(newValue) => {
+                    setFormData((prev) => ({
+                      ...prev,
+                      admins: newValue.map((admin) => admin.id),
+                    }));
+                  }}
+                  members={all_friends}
+                />
+
+                <MembersSelect
+                  value={all_friends.filter((f) =>
+                    formData.members.some((m) => m.toString() === f.id),
+                  )}
+                  onChange={(newValue) => {
+                    setFormData((prev) => ({
+                      ...prev,
+                      members: newValue.map((member) => member.id),
+                    }));
+                  }}
+                  users={all_friends}
+                />
+
+                <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
+                  <Button
+                    variant="contained"
+                    color="primary"
+                    fullWidth
+                    disabled={isSaving}
+                    onClick={() => {
+                      const updatedChat: Chat = {
+                        ...chat,
+                        name: formData.name,
+                        admins: formData.admins,
+                        creator: chat.creator,
+                        workspaces: formData.workspaces,
+                        members: formData.members,
+                      };
+                      handleSaveChat(updatedChat);
+                      setIsSettingsView(false);
+                    }}
+                  >
+                    Save Changes
+                  </Button>
+
+                  {chat.name !== "private_chat" && (
+                    <Button
+                      variant="contained"
+                      color="error"
+                      onClick={() => {
+                        if (
+                          window.confirm(
+                            "Are you sure you want to delete this chat? This action cannot be undone.",
+                          )
+                        ) {
+                          backendActor
+                            .delete_chat(chat.id)
+                            .then((result) => {
+                              if ("Ok" in result && onClose) {
+                                dispatch(
+                                  handleRedux("DELETE_CHAT", {
+                                    chat_id: chat.id,
+                                  }),
+                                );
+                                onClose(chat.id);
+                              }
+                            })
+                            .catch((error) => {
+                              console.error("Failed to delete chat:", error);
+                            });
+                        }
+                      }}
+                    >
+                      Delete Chat
+                    </Button>
+                  )}
+                </Box>
+              </>
+            )}
+          </Box>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+```

# 2024-12-24 17:23:54.049816
+import React, { useState, useCallback } from "react";
+import {
+  Avatar,
+  IconButton,
+  Menu,
+  MenuItem,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  Button,
+  TextField,
+  Typography,
+  Rating as UiRating,
+} from "@mui/material";
+import ChatWindow from "../../components/Chat/chatWindow";
+import { useNavigate } from "react-router-dom";
+import { Person, Message, Star } from "@mui/icons-material";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSnackbar } from "notistack";
+import { Principal } from "@dfinity/principal";
+import { Rating } from "../../../declarations/backend/backend.did";
+import { useSelector } from "react-redux";
+import { RootState } from "../../redux/reducers";
+import { randomString } from "../../DataProcessing/dataSamples";
+
+interface UserAvatarMenuProps {
+  user: {
+    id: string;
+    name: string;
+    photo?: Uint8Array;
+  };
+  onMessageClick?: () => void;
+}
+
+const UserAvatarMenu: React.FC<UserAvatarMenuProps> = ({
+  user,
+  onMessageClick,
+}) => {
+  const navigate = useNavigate();
+  const { backendActor } = useBackendContext();
+  const { enqueueSnackbar } = useSnackbar();
+
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [reviewOpen, setReviewOpen] = useState(false);
+  const [rating, setRating] = useState<number>(0);
+  const [comment, setComment] = useState("");
+
+  const handleClick = (event: React.MouseEvent<HTMLElement>) => {
+    setAnchorEl(event.currentTarget);
+  };
+
+  const handleClose = () => {
+    setAnchorEl(null);
+  };
+
+  const handleProfile = () => {
+    navigate(`/user?id=${user.id}`);
+    handleClose();
+  };
+
+  const [activeChat, setActiveChat] = useState<any>(null);
+  const [chatPosition, setChatPosition] = useState({ x: 0, y: 0 });
+  const { chats } = useSelector((state: RootState) => state.chatsState);
+  const { profile } = useSelector((state: RootState) => state.filesState);
+
+  const handleMessage = useCallback(() => {
+    // Use the already selected chats and profile
+    const existingChat = chats.find((chat) =>
+      chat.members.some(
+        (member) =>
+          member.toString() === user.id || member.__principal__ === user.id,
+      ),
+    );
+
+    if (!activeChat && existingChat) {
+      const position = {
+        x: window.innerWidth - 350,
+        y: window.innerHeight - 450,
+      };
+      setChatPosition(position);
+
+      const filteredMessages = existingChat.messages.filter((message) => {
+        const senderId =
+          message.sender instanceof Principal
+            ? message.sender.toString()
+            : message.sender.__principal__;
+
+        const isCurrentUser = senderId === profile?.id;
+        return !isCurrentUser || message.seen_by?.length > 0;
+      });
+
+      setActiveChat({
+        ...existingChat,
+        messages: filteredMessages,
+      });
+    } else if (!activeChat) {
+      const chatId = `chat-${user.id}`;
+      const newChat = {
+        id: chatId,
+        name: user.name,
+        messages: [],
+        members: [user.id],
+        admins: [user.id],
+      };
+
+      const position = {
+        x: window.innerWidth - 350,
+        y: window.innerHeight - 450,
+      };
+      setChatPosition(position);
+      setActiveChat(newChat);
+    }
+
+    handleClose();
+  }, [user, activeChat, handleClose, chats, profile]);
+
+  const handleCloseChat = useCallback(() => {
+    setActiveChat(null);
+  }, []);
+
+  const handleChatPositionChange = useCallback(
+    (chatId: string, position: { x: number; y: number }) => {
+      setChatPosition(position);
+    },
+    [],
+  );
+
+  const handleSendMessage = async (chatId: string, message: string) => {
+    try {
+      if (onMessageClick) {
+        await onMessageClick();
+      }
+
+      const newMessage: Message = {
+        id: randomString(),
+        date: BigInt(Date.now() * 1e6),
+        sender: Principal.fromText(profile.id),
+        seen_by: [],
+        message,
+        chat_id: chatId,
+      };
+
+      const result = await backendActor?.send_message(
+        [Principal.fromText(user.id)],
+        newMessage,
+      );
+      console.log({ result });
+
+      if (result?.Ok) {
+        enqueueSnackbar("Message sent successfully", { variant: "success" });
+      } else if (result?.Err) {
+        throw new Error(result.Err);
+      }
+    } catch (error) {
+      console.error("Error sending message:", error);
+      enqueueSnackbar(error.message || "Failed to send message", {
+        variant: "error",
+      });
+    }
+  };
+
+  const handleReviewClick = () => {
+    setReviewOpen(true);
+    handleClose();
+  };
+
+  const handleReviewSubmit = async () => {
+    try {
+      // Convert user.id string to Principal
+      const userPrincipal = Principal.fromText(user.id);
+
+      const ratingData: Rating = {
+        id: randomString(),
+        rating: rating,
+        comment: comment,
+        date: Date.now() * 1e6,
+        user_id: Principal.fromText(user.id),
+      };
+
+      const result = await backendActor?.rate_user(userPrincipal, ratingData);
+
+      if (result?.Ok) {
+        enqueueSnackbar("Review submitted successfully", {
+          variant: "success",
+        });
+      } else if (result?.Err) {
+        enqueueSnackbar(result.Err, { variant: "error" });
+      }
+    } catch (error) {
+      // console.error('Error submitting review:', error);
+      enqueueSnackbar("Failed to submit review " + error, { variant: "error" });
+    }
+    setReviewOpen(false);
+    setRating(0);
+    setComment("");
+  };
+
+  const getPhotoSrc = (photoData?: Uint8Array) => {
+    try {
+      return photoData && photoData.length > 0
+        ? `data:image/jpeg;base64,${Buffer.from(photoData).toString("base64")}`
+        : "";
+    } catch (e) {
+      console.error("Error converting photo:", e);
+      return "";
+    }
+  };
+
+  return (
+    <>
+      <IconButton onClick={handleClick}>
+        <Avatar src={getPhotoSrc(user.photo)} alt={user.name}>
+          {user.name?.charAt(0) || "A"}
+        </Avatar>
+      </IconButton>
+
+      <Menu anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={handleClose}>
+        <MenuItem onClick={handleProfile}>
+          <Person sx={{ mr: 1 }} /> Profile
+        </MenuItem>
+        <MenuItem onClick={handleMessage}>
+          <Message sx={{ mr: 1 }} /> Message
+        </MenuItem>
+        <MenuItem onClick={handleReviewClick}>
+          <Star sx={{ mr: 1 }} /> Review
+        </MenuItem>
+      </Menu>
+
+      <Dialog open={reviewOpen} onClose={() => setReviewOpen(false)}>
+        <DialogTitle>Review {user.name}</DialogTitle>
+        <DialogContent>
+          <Typography component="legend">Rating</Typography>
+          <UiRating
+            value={rating}
+            onChange={(_, newValue) => setRating(newValue || 0)}
+          />
+          <TextField
+            autoFocus
+            margin="dense"
+            label="Comment"
+            fullWidth
+            multiline
+            rows={4}
+            value={comment}
+            onChange={(e) => setComment(e.target.value)}
+          />
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={() => setReviewOpen(false)}>Cancel</Button>
+          <Button onClick={handleReviewSubmit}>Submit Review</Button>
+        </DialogActions>
+      </Dialog>
+
+      {activeChat && (
+        <ChatWindow
+          user={user}
+          chat={activeChat}
+          onClose={handleCloseChat}
+          position={chatPosition}
+          onPositionChange={handleChatPositionChange}
+          onSendMessage={handleSendMessage}
+        />
+      )}
+    </>
+  );
+};
+
+export default UserAvatarMenu;
+/Users/ahmed/Desktop/odoc/src/frontend/components/MainComponents/UserAvatarMenu.tsx when user click submit review show loader 

# 2024-12-24 17:24:29.272984
+y

# 2024-12-24 17:24:51.206659
+[plugin:vite:esbuild] Transform failed with 1 error:
+/Users/ahmed/Desktop/odoc/src/frontend/components/MainComponents/UserAvatarMenu.tsx:200:6: ERROR: Expected ";" but found "finally"
+/Users/ahmed/Desktop/odoc/src/frontend/components/MainComponents/UserAvatarMenu.tsx:200:6
+Expected ";" but found "finally"
+198|      setRating(0);
+199|      setComment("");
+200|      } finally {
+   |        ^
+201|        setIsSubmitting(false);
+202|    };

# 2024-12-24 17:29:28.475060
+at /Users/ahmed/Desktop/odoc/src/frontend/components/MuiComponents/walletUi.tsx where my code is import React, { useState } from "react";
+import {
+  Box,
+  Card,
+  CardContent,
+  Typography,
+  Button,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  TextField,
+  Select,
+  MenuItem,
+  IconButton,
+  Table,
+  TableBody,
+  TableCell,
+  TableHead,
+  TableRow,
+  Paper,
+  Stack,
+  Grid,
+  InputAdornment,
+} from "@mui/material";
+import {
+  AccountBalanceWallet,
+  ArrowDownward,
+  ArrowUpward,
+  Send,
+  Close,
+  ContentCopy,
+} from "@mui/icons-material";
+
+const defaultWallet = {
+  owner: "0x0000000000000000000000000000000000000000",
+  balance: 0,
+  debts: {},
+  total_debt: 0,
+  exchanges: [],
+  received: 0,
+  spent: 0,
+};
+
+const WalletPage = ({ wallet = defaultWallet }) => {
+  const [amount, setAmount] = useState("");
+  const [recipient, setRecipient] = useState("");
+  const [withdrawAddress, setWithdrawAddress] = useState("");
+  const [openDialog, setOpenDialog] = useState("");
+
+  // Mock users list
+  const users = [
+    { username: "alice", name: "Alice Johnson" },
+    { username: "bob", name: "Bob Smith" },
+    { username: "carol", name: "Carol White" },
+  ];
+
+  const handleClose = () => setOpenDialog("");
+
+  const handleCopyAddress = () => {
+    navigator.clipboard.writeText(wallet?.owner || "");
+    // You might want to use MUI's Snackbar here instead of alert
+    alert("Address copied to clipboard!");
+  };
+
+  const handleTransaction = (type) => {
+    if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
+      alert("Please enter a valid amount");
+      return;
+    }
+    console.log("Transaction:", { type, amount, recipient, withdrawAddress });
+    handleClose();
+    setAmount("");
+    setWithdrawAddress("");
+    setRecipient("");
+  };
+
+  const formatDate = (timestamp) => {
+    if (!timestamp) return "N/A";
+    return new Date(timestamp).toLocaleDateString();
+  };
+
+  return (
+    <Box sx={{ maxWidth: 1200, margin: "0 auto", p: 3 }}>
+      {/* Balance Card */}
+      <Card sx={{ mb: 4 }}>
+        <CardContent>
+          <Stack spacing={3}>
+            <Box display="flex" alignItems="center" gap={1}>
+              <AccountBalanceWallet />
+              <Typography variant="h5">Your Wallet</Typography>
+            </Box>
+
+            <Grid container spacing={3}>
+              <Grid item xs={12} md={6}>
+                <Typography color="text.secondary">
+                  Available Balance
+                </Typography>
+                <Typography variant="h3" component="div">
+                  ${wallet.balance.toFixed(2)}
+                </Typography>
+              </Grid>
+              <Grid item xs={12} md={6}>
+                <Typography color="text.secondary">Total Debts</Typography>
+                <Typography variant="h4" color="error">
+                  ${wallet.total_debt}
+                </Typography>
+              </Grid>
+              <Grid item xs={6}>
+                <Typography color="text.secondary">Total Received</Typography>
+                <Typography color="success.main" variant="h6">
+                  ${wallet.received}
+                </Typography>
+              </Grid>
+              <Grid item xs={6}>
+                <Typography color="text.secondary">Total Spent</Typography>
+                <Typography color="error" variant="h6">
+                  ${wallet.spent}
+                </Typography>
+              </Grid>
+            </Grid>
+          </Stack>
+        </CardContent>
+      </Card>
+
+      {/* Action Buttons */}
+      <Stack direction="row" spacing={2} sx={{ mb: 4 }}>
+        <Button
+          variant="outlined"
+          startIcon={<ArrowDownward />}
+          onClick={() => setOpenDialog("deposit")}
+          fullWidth
+        >
+          Deposit
+        </Button>
+        <Button
+          variant="outlined"
+          startIcon={<ArrowUpward />}
+          onClick={() => setOpenDialog("withdraw")}
+          fullWidth
+        >
+          Withdraw
+        </Button>
+        <Button
+          variant="outlined"
+          startIcon={<Send />}
+          onClick={() => setOpenDialog("pay")}
+          fullWidth
+        >
+          Pay
+        </Button>
+      </Stack>
+
+      {/* Transaction History */}
+      <Paper>
+        <Box p={3}>
+          <Typography variant="h6" gutterBottom>
+            Transaction History
+          </Typography>
+        </Box>
+        <Table>
+          <TableHead>
+            <TableRow>
+              <TableCell>Date</TableCell>
+              <TableCell>Type</TableCell>
+              <TableCell>From</TableCell>
+              <TableCell>To</TableCell>
+              <TableCell align="right">Amount</TableCell>
+            </TableRow>
+          </TableHead>
+          <TableBody>
+            {wallet.exchanges.length > 0 ? (
+              wallet.exchanges.map((exchange, index) => (
+                <TableRow key={index}>
+                  <TableCell>{formatDate(exchange.date_created)}</TableCell>
+                  <TableCell>{exchange.type}</TableCell>
+                  <TableCell>{exchange.from}</TableCell>
+                  <TableCell>{exchange.to}</TableCell>
+                  <TableCell
+                    align="right"
+                    sx={{
+                      color:
+                        exchange.type &&
+                        (exchange.type === "Deposit" ||
+                          exchange.type === "LocalReceive")
+                          ? "success.main"
+                          : "error.main",
+                    }}
+                  >
+                    ${Math.abs(exchange.amount).toFixed(2)}
+                  </TableCell>
+                </TableRow>
+              ))
+            ) : (
+              <TableRow>
+                <TableCell colSpan={5} align="center">
+                  <Typography color="text.secondary">
+                    No transactions yet
+                  </Typography>
+                </TableCell>
+              </TableRow>
+            )}
+          </TableBody>
+        </Table>
+      </Paper>
+
+      {/* Deposit Dialog */}
+      <Dialog
+        open={openDialog === "deposit"}
+        onClose={handleClose}
+        maxWidth="sm"
+        fullWidth
+      >
+        <DialogTitle>
+          Deposit Funds
+          <IconButton
+            onClick={handleClose}
+            sx={{ position: "absolute", right: 8, top: 8 }}
+          >
+            <Close />
+          </IconButton>
+        </DialogTitle>
+        <DialogContent>
+          <Box py={2}>
+            <Typography variant="subtitle2" gutterBottom>
+              Your Wallet Address
+            </Typography>
+            <TextField
+              fullWidth
+              variant="outlined"
+              value={wallet.owner}
+              InputProps={{
+                readOnly: true,
+                endAdornment: (
+                  <InputAdornment position="end">
+                    <IconButton onClick={handleCopyAddress}>
+                      <ContentCopy />
+                    </IconButton>
+                  </InputAdornment>
+                ),
+              }}
+            />
+            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
+              Send your funds to this address. The balance will be updated
+              automatically.
+            </Typography>
+          </Box>
+        </DialogContent>
+      </Dialog>
+
+      {/* Withdraw Dialog */}
+      <Dialog
+        open={openDialog === "withdraw"}
+        onClose={handleClose}
+        maxWidth="sm"
+        fullWidth
+      >
+        <DialogTitle>
+          Withdraw Funds
+          <IconButton
+            onClick={handleClose}
+            sx={{ position: "absolute", right: 8, top: 8 }}
+          >
+            <Close />
+          </IconButton>
+        </DialogTitle>
+        <DialogContent>
+          <Stack spacing={3} sx={{ mt: 2 }}>
+            <TextField
+              label="Amount"
+              type="number"
+              value={amount}
+              onChange={(e) => setAmount(e.target.value)}
+              fullWidth
+            />
+            <TextField
+              label="Withdrawal Address"
+              value={withdrawAddress}
+              onChange={(e) => setWithdrawAddress(e.target.value)}
+              fullWidth
+            />
+          </Stack>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={handleClose}>Cancel</Button>
+          <Button
+            onClick={() => handleTransaction("withdraw")}
+            variant="contained"
+          >
+            Confirm Withdrawal
+          </Button>
+        </DialogActions>
+      </Dialog>
+
+      {/* Pay Dialog */}
+      <Dialog
+        open={openDialog === "pay"}
+        onClose={handleClose}
+        maxWidth="sm"
+        fullWidth
+      >
+        <DialogTitle>
+          Pay Someone
+          <IconButton
+            onClick={handleClose}
+            sx={{ position: "absolute", right: 8, top: 8 }}
+          >
+            <Close />
+          </IconButton>
+        </DialogTitle>
+        <DialogContent>
+          <Stack spacing={3} sx={{ mt: 2 }}>
+            <Select
+              value={recipient}
+              onChange={(e) => setRecipient(e.target.value)}
+              displayEmpty
+              fullWidth
+            >
+              <MenuItem value="" disabled>
+                Select recipient
+              </MenuItem>
+              {users.map((user) => (
+                <MenuItem key={user.username} value={user.username}>
+                  {user.name} (@{user.username})
+                </MenuItem>
+              ))}
+            </Select>
+            <TextField
+              label="Amount"
+              type="number"
+              value={amount}
+              onChange={(e) => setAmount(e.target.value)}
+              fullWidth
+            />
+          </Stack>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={handleClose}>Cancel</Button>
+          <Button onClick={() => handleTransaction("pay")} variant="contained">
+            Send Payment
+          </Button>
+        </DialogActions>
+      </Dialog>
+    </Box>
+  );
+};
+
+export default WalletPage;
+when user chose to Pay Someone should be able to select recipient from all_friends and when click on send payment call internal_transaction(amount: f64, receiver: String, _type: ExchangeType) here pub enum ExchangeType {
+    Deposit,
+    Withdraw,
+    LocalReceive,
+    LocalSend,
+}

# 2024-12-24 17:29:51.006136
+y

# 2024-12-24 17:31:20.685657
+make snackbar message for the reuslts from internal_transaction giving it is  Result<(), String>

# 2024-12-24 17:32:33.807797
+when click send payment show a loder while calling backend

# 2024-12-24 17:34:24.658670
+when click confirm withdrawal call backend withdraw_ckusdt(amount: u64, address: String) and show loader while wating the backend call

# 2024-12-24 17:41:17.618168
+call async fn deposit_ckusdt() -> Result<Wallet, Error> {
+and then call redux to update the wallet import React, {useEffect} from "react";
+import "./App.css";
+import Pages from "./pages";
+import { BrowserRouter } from "react-router-dom";
+import useInitialData from "./redux/initialData/useInitialData";
+import { SnackbarProvider } from "notistack";
+import NavBar from "./components/MainComponents/NavBar";
+import Index from "./components/MainComponents/Index";
+import RegistrationForm from "./components/MainComponents/RegistrationForm";
+import SearchPopper from "./components/SearchComponent";
+import useSocket from "./websocket/use_socket";
+import { useBackendContext } from "./contexts/BackendContext";
+import { Box, CircularProgress } from "@mui/material";
+
+const App: React.FC = () => {
+  const { backendActor } = useBackendContext();
+  useInitialData();
+  useSocket();
+
+  let Loadder = (
+    <Box
+      style={{
+        display: "flex",
+        justifyContent: "center",
+        alignItems: "center",
+        height: "100vh", // This will make it center vertically for the whole viewport
+      }}
+    >
+      <CircularProgress size={100} />
+    </Box>
+  );
+  if (!backendActor) {
+    return Loadder;
+  }
+  
+  useEffect(() => {
+      (async ()=>{
+          // let res = backendActor?.getInitialData()
+      })()
+  },[])
+
+  return (
+    <BrowserRouter>
+      <SearchPopper />
+      <SnackbarProvider maxSnack={3}>
+        <RegistrationForm />
+        <Index />
+        <NavBar>
+          <Pages />
+        </NavBar>
+      </SnackbarProvider>
+    </BrowserRouter>
+  );
+};
+
+export default App;
+call redux for case "SET_WALLET":
+      return {
+        ...state,
+        wallet: action.wallet,
+      };` update only here /Users/ahmed/Desktop/odoc/src/frontend/App.tsx

# 2024-12-24 17:41:31.918393
+y

# 2024-12-24 17:42:41.210996
+Uncaught Error: Rendered more hooks than during the previous render.
+    at updateWorkInProgressHook (chunk-WMDJOG6V.js?v=06f71419:11678:21)
+    at updateEffectImpl (chunk-WMDJOG6V.js?v=06f71419:12074:22)
+    at updateEffect (chunk-WMDJOG6V.js?v=06f71419:12099:18)
+    at Object.useEffect (chunk-WMDJOG6V.js?v=06f71419:12703:22)
+    at useEffect (chunk-CMM6OKGN.js?v=06f71419:1078:29)
+    at App (App.tsx:38:3)
+    at renderWithHooks (chunk-WMDJOG6V.js?v=06f71419:11548:26)
+    at updateFunctionComponent (chunk-WMDJOG6V.js?v=06f71419:14582:28)
+    at beginWork (chunk-WMDJOG6V.js?v=06f71419:15924:22)
+    at HTMLUnknownElement.callCallback2 (chunk-WMDJOG6V.js?v=06f71419:3674:22)

# 2024-12-24 17:47:12.871882
+giving type BlockIndex = nat;
+type Subaccount = blob;
+// Number of nanoseconds since the UNIX epoch in UTC timezone.
+type Timestamp = nat64;
+// Number of nanoseconds between two [Timestamp]s.
+type Duration = nat64;
+type Tokens = nat;
+type TxIndex = nat;
+type Allowance = record { allowance : nat; expires_at : opt Timestamp };
+type AllowanceArgs = record { account : Account; spender : Account };
+type Approve = record {
+  fee : opt nat;
+  from : Account;
+  memo : opt blob;
+  created_at_time : opt Timestamp;
+  amount : nat;
+  expected_allowance : opt nat;
+  expires_at : opt Timestamp;
+  spender : Account;
+};
+type ApproveArgs = record {
+  fee : opt nat;
+  memo : opt blob;
+  from_subaccount : opt blob;
+  created_at_time : opt Timestamp;
+  amount : nat;
+  expected_allowance : opt nat;
+  expires_at : opt Timestamp;
+  spender : Account;
+};
+type ApproveError = variant {
+  GenericError : record { message : text; error_code : nat };
+  TemporarilyUnavailable;
+  Duplicate : record { duplicate_of : BlockIndex };
+  BadFee : record { expected_fee : nat };
+  AllowanceChanged : record { current_allowance : nat };
+  CreatedInFuture : record { ledger_time : Timestamp };
+  TooOld;
+  Expired : record { ledger_time : Timestamp };
+  InsufficientFunds : record { balance : nat };
+};
+type ApproveResult = variant { Ok : BlockIndex; Err : ApproveError };
+
+type HttpRequest = record {
+  url : text;
+  method : text;
+  body : blob;
+  headers : vec record { text; text };
+};
+type HttpResponse = record {
+  body : blob;
+  headers : vec record { text; text };
+  status_code : nat16;
+};
+
+type Account = record {
+    owner : principal;
+    subaccount : opt Subaccount;
+};
+
+type TransferArg = record {
+    from_subaccount : opt Subaccount;
+    to : Account;
+    amount : Tokens;
+    fee : opt Tokens;
+    memo : opt blob;
+    created_at_time: opt Timestamp;
+};
+
+type TransferError = variant {
+    BadFee : record { expected_fee : Tokens };
+    BadBurn : record { min_burn_amount : Tokens };
+    InsufficientFunds : record { balance : Tokens };
+    TooOld;
+    CreatedInFuture : record { ledger_time : Timestamp };
+    TemporarilyUnavailable;
+    Duplicate : record { duplicate_of : BlockIndex };
+    GenericError : record { error_code : nat; message : text };
+};
+
+type TransferResult = variant {
+    Ok : BlockIndex;
+    Err : TransferError;
+};
+
+// The value returned from the [icrc1_metadata] endpoint.
+type MetadataValue = variant {
+    Nat : nat;
+    Int : int;
+    Text : text;
+    Blob : blob;
+};
+
+type FeatureFlags = record {
+    icrc2 : bool;
+};
+
+// The initialization parameters of the Ledger
+type InitArgs = record {
+    minting_account : Account;
+    fee_collector_account : opt Account;
+    transfer_fee : nat;
+    decimals : opt nat8;
+    max_memo_length : opt nat16;
+    token_symbol : text;
+    token_name : text;
+    metadata : vec record { text; MetadataValue };
+    initial_balances : vec record { Account; nat };
+    feature_flags : opt FeatureFlags;
+    maximum_number_of_accounts : opt nat64;
+    accounts_overflow_trim_quantity : opt nat64;
+    archive_options : record {
+        num_blocks_to_archive : nat64;
+        max_transactions_per_response : opt nat64;
+        trigger_threshold : nat64;
+        max_message_size_bytes : opt nat64;
+        cycles_for_archive_creation : opt nat64;
+        node_max_memory_size_bytes : opt nat64;
+        controller_id : principal;
+        more_controller_ids : opt vec principal;
+    };
+};
+
+type ChangeFeeCollector = variant {
+    Unset; SetTo: Account;
+};
+
+type ChangeArchiveOptions = record {
+    num_blocks_to_archive : opt nat64;
+    max_transactions_per_response : opt nat64;
+    trigger_threshold : opt nat64;
+    max_message_size_bytes : opt nat64;
+    cycles_for_archive_creation : opt nat64;
+    node_max_memory_size_bytes : opt nat64;
+    controller_id : opt principal;
+    more_controller_ids : opt vec principal;
+};
+
+type UpgradeArgs = record {
+    metadata : opt vec record { text; MetadataValue };
+    token_symbol : opt text;
+    token_name : opt text;
+    transfer_fee : opt nat;
+    change_fee_collector : opt ChangeFeeCollector;
+    max_memo_length : opt nat16;
+    feature_flags : opt FeatureFlags;
+    maximum_number_of_accounts: opt nat64;
+    accounts_overflow_trim_quantity: opt nat64;
+    change_archive_options : opt ChangeArchiveOptions;
+};
+
+type LedgerArg = variant {
+    Init: InitArgs;
+    Upgrade: opt UpgradeArgs;
+};
+
+type GetTransactionsRequest = record {
+    // The index of the first tx to fetch.
+    start : TxIndex;
+    // The number of transactions to fetch.
+    length : nat;
+};
+
+type GetTransactionsResponse = record {
+    // The total number of transactions in the log.
+    log_length : nat;
+
+    // List of transaction that were available in the ledger when it processed the call.
+    //
+    // The transactions form a contiguous range, with the first transaction having index
+    // [first_index] (see below), and the last transaction having index
+    // [first_index] + len(transactions) - 1.
+    //
+    // The transaction range can be an arbitrary sub-range of the originally requested range.
+    transactions : vec Transaction;
+
+    // The index of the first transaction in [transactions].
+    // If the transaction vector is empty, the exact value of this field is not specified.
+    first_index : TxIndex;
+
+    // Encoding of instructions for fetching archived transactions whose indices fall into the
+    // requested range.
+    //
+    // For each entry `e` in [archived_transactions], `[e.from, e.from + len)` is a sub-range
+    // of the originally requested transaction range.
+    archived_transactions : vec record {
+        // The index of the first archived transaction you can fetch using the [callback].
+        start : TxIndex;
+
+        // The number of transactions you can fetch using the callback.
+        length : nat;
+
+        // The function you should call to fetch the archived transactions.
+        // The range of the transaction accessible using this function is given by [from]
+        // and [len] fields above.
+        callback : QueryArchiveFn;
+    };
+};
+
+
+// A prefix of the transaction range specified in the [GetTransactionsRequest] request.
+type TransactionRange = record {
+    // A prefix of the requested transaction range.
+    // The index of the first transaction is equal to [GetTransactionsRequest.from].
+    //
+    // Note that the number of transactions might be less than the requested
+    // [GetTransactionsRequest.length] for various reasons, for example:
+    //
+    // 1. The query might have hit the replica with an outdated state
+    //    that doesn't have the whole range yet.
+    // 2. The requested range is too large to fit into a single reply.
+    //
+    // NOTE: the list of transactions can be empty if:
+    //
+    // 1. [GetTransactionsRequest.length] was zero.
+    // 2. [GetTransactionsRequest.from] was larger than the last transaction known to
+    //    the canister.
+    transactions : vec Transaction;
+};
+
+// A function for fetching archived transaction.
+type QueryArchiveFn = func (GetTransactionsRequest) -> (TransactionRange) query;
+
+type Transaction = record {
+  burn : opt Burn;
+  kind : text;
+  mint : opt Mint;
+  approve : opt Approve;
+  timestamp : Timestamp;
+  transfer : opt Transfer;
+};
+
+type Burn = record {
+  from : Account;
+  memo : opt blob;
+  created_at_time : opt Timestamp;
+  amount : nat;
+  spender : opt Account;
+};
+
+type Mint = record {
+  to : Account;
+  memo : opt blob;
+  created_at_time : opt Timestamp;
+  amount : nat;
+};
+
+type Transfer = record {
+  to : Account;
+  fee : opt nat;
+  from : Account;
+  memo : opt blob;
+  created_at_time : opt Timestamp;
+  amount : nat;
+  spender : opt Account;
+};
+
+type Value = variant {
+    Blob : blob;
+    Text : text;
+    Nat : nat;
+    Nat64: nat64;
+    Int : int;
+    Array : vec Value;
+    Map : Map;
+};
+
+type Map = vec record { text; Value };
+
+type Block = Value;
+
+type GetBlocksArgs = record {
+    // The index of the first block to fetch.
+    start : BlockIndex;
+    // Max number of blocks to fetch.
+    length : nat;
+};
+
+// A prefix of the block range specified in the [GetBlocksArgs] request.
+type BlockRange = record {
+    // A prefix of the requested block range.
+    // The index of the first block is equal to [GetBlocksArgs.start].
+    //
+    // Note that the number of blocks might be less than the requested
+    // [GetBlocksArgs.length] for various reasons, for example:
+    //
+    // 1. The query might have hit the replica with an outdated state
+    //    that doesn't have the whole range yet.
+    // 2. The requested range is too large to fit into a single reply.
+    //
+    // NOTE: the list of blocks can be empty if:
+    //
+    // 1. [GetBlocksArgs.length] was zero.
+    // 2. [GetBlocksArgs.start] was larger than the last block known to
+    //    the canister.
+    blocks : vec Block;
+};
+
+// A function for fetching archived blocks.
+type QueryBlockArchiveFn = func (GetBlocksArgs) -> (BlockRange) query;
+
+// The result of a "get_blocks" call.
+type GetBlocksResponse = record {
+    // The index of the first block in "blocks".
+    // If the blocks vector is empty, the exact value of this field is not specified.
+    first_index : BlockIndex;
+
+    // The total number of blocks in the chain.
+    // If the chain length is positive, the index of the last block is `chain_len - 1`.
+    chain_length : nat64;
+
+    // System certificate for the hash of the latest block in the chain.
+    // Only present if `get_blocks` is called in a non-replicated query context.
+    certificate : opt blob;
+
+    // List of blocks that were available in the ledger when it processed the call.
+    //
+    // The blocks form a contiguous range, with the first block having index
+    // [first_block_index] (see below), and the last block having index
+    // [first_block_index] + len(blocks) - 1.
+    //
+    // The block range can be an arbitrary sub-range of the originally requested range.
+    blocks : vec Block;
+
+    // Encoding of instructions for fetching archived blocks.
+    archived_blocks : vec record {
+        // The index of the first archived block.
+        start : BlockIndex;
+
+        // The number of blocks that can be fetched.
+        length : nat;
+
+        // Callback to fetch the archived blocks.
+        callback : QueryBlockArchiveFn;
+    };
+};
+
+// Certificate for the block at `block_index`.
+type DataCertificate = record {
+    certificate : opt blob;
+    hash_tree : blob;
+};
+
+type StandardRecord = record { url : text; name : text };
+
+type TransferFromArgs = record {
+    spender_subaccount : opt Subaccount;
+    from : Account;
+    to : Account;
+    amount : Tokens;
+    fee : opt Tokens;
+    memo : opt blob;
+    created_at_time: opt Timestamp;
+};
+
+type TransferFromResult = variant {
+    Ok : BlockIndex;
+    Err : TransferFromError;
+};
+
+type TransferFromError = variant {
+    BadFee : record { expected_fee : Tokens };
+    BadBurn : record { min_burn_amount : Tokens };
+    InsufficientFunds : record { balance : Tokens };
+    InsufficientAllowance : record { allowance : Tokens };
+    TooOld;
+    CreatedInFuture : record { ledger_time : Timestamp };
+    Duplicate : record { duplicate_of : BlockIndex };
+    TemporarilyUnavailable;
+    GenericError : record { error_code : nat; message : text };
+};
+
+type ArchiveInfo = record {
+    canister_id: principal;
+    block_range_start: BlockIndex;
+    block_range_end: BlockIndex;
+};
+
+type ICRC3Value = variant {
+    Blob : blob;
+    Text : text;
+    Nat : nat;
+    Int : int;
+    Array : vec ICRC3Value;
+    Map : vec record { text; ICRC3Value };
+};
+
+type GetArchivesArgs = record {
+    // The last archive seen by the client.
+    // The Ledger will return archives coming
+    // after this one if set, otherwise it
+    // will return the first archives.
+    from : opt principal;
+};
+
+type GetArchivesResult = vec record {
+    // The id of the archive
+    canister_id : principal;
+
+    // The first block in the archive
+    start : nat;
+
+    // The last block in the archive
+    end : nat;
+};
+
+type GetBlocksResult = record {
+    // Total number of blocks in the
+    // block log
+    log_length : nat;
+
+    blocks : vec record { id : nat; block: ICRC3Value };
+
+    archived_blocks : vec record {
+        args : vec GetBlocksArgs;
+        callback : func (vec GetBlocksArgs) -> (GetBlocksResult) query;
+    };
+};
+
+type ICRC3DataCertificate = record {
+  // See https://internetcomputer.org/docs/current/references/ic-interface-spec#certification
+  certificate : blob;
+
+  // CBOR encoded hash_tree
+  hash_tree : blob;
+};
+
+type icrc21_consent_message_metadata = record {
+    language: text;
+    utc_offset_minutes: opt int16;
+};
+
+type icrc21_consent_message_spec = record {
+    metadata: icrc21_consent_message_metadata;
+    device_spec: opt variant {
+        GenericDisplay;
+        LineDisplay: record {
+            characters_per_line: nat16;
+            lines_per_page: nat16;
+        };
+    };
+};
+
+type icrc21_consent_message_request = record {
+    method: text;
+    arg: blob;
+    user_preferences: icrc21_consent_message_spec;
+};
+
+type icrc21_consent_message = variant {
+    GenericDisplayMessage: text;
+    LineDisplayMessage: record {
+        pages: vec record {
+            lines: vec text;
+        };
+    };
+};
+
+type icrc21_consent_info = record {
+    consent_message: icrc21_consent_message;
+    metadata: icrc21_consent_message_metadata;
+};
+
+type icrc21_error_info = record {
+    description: text;
+};
+
+type icrc21_error = variant {
+    UnsupportedCanisterCall: icrc21_error_info;
+    ConsentMessageUnavailable: icrc21_error_info;
+    InsufficientPayment: icrc21_error_info;
+
+    // Any error not covered by the above variants.
+    GenericError: record {
+       error_code: nat;
+       description: text;
+   };
+};
+
+type icrc21_consent_message_response = variant {
+    Ok: icrc21_consent_info;
+    Err: icrc21_error;
+};
+
+service : (ledger_arg : LedgerArg) -> {
+    archives : () -> (vec ArchiveInfo) query;
+    get_transactions : (GetTransactionsRequest) -> (GetTransactionsResponse) query;
+    get_blocks : (GetBlocksArgs) -> (GetBlocksResponse) query;
+    get_data_certificate : () -> (DataCertificate) query;
+
+    icrc1_name : () -> (text) query;
+    icrc1_symbol : () -> (text) query;
+    icrc1_decimals : () -> (nat8) query;
+    icrc1_metadata : () -> (vec record { text; MetadataValue }) query;
+    icrc1_total_supply : () -> (Tokens) query;
+    icrc1_fee : () -> (Tokens) query;
+    icrc1_minting_account : () -> (opt Account) query;
+    icrc1_balance_of : (Account) -> (Tokens) query;
+    icrc1_transfer : (TransferArg) -> (TransferResult);
+    icrc1_supported_standards : () -> (vec StandardRecord) query;
+
+    icrc2_approve : (ApproveArgs) -> (ApproveResult);
+    icrc2_allowance : (AllowanceArgs) -> (Allowance) query;
+    icrc2_transfer_from : (TransferFromArgs) -> (TransferFromResult);
+
+    icrc3_get_archives : (GetArchivesArgs) -> (GetArchivesResult) query;
+    icrc3_get_tip_certificate : () -> (opt ICRC3DataCertificate) query;
+    icrc3_get_blocks : (vec GetBlocksArgs) -> (GetBlocksResult) query;
+    icrc3_supported_block_types : () -> (vec record { block_type : text; url : text }) query;
+
+    icrc21_canister_call_consent_message: (icrc21_consent_message_request) -> (icrc21_consent_message_response);
+    icrc10_supported_standards : () -> (vec record { name : text; url : text }) query;
+}
+call ckUSDCActor.icrc1_balance_of(profile.id) before const result = await backendActor.deposit_ckusdt(); and check if it is more than 0 checkk the deposit_ckusdt else nothing

# 2024-12-24 17:47:32.021705
+n

# 2024-12-24 17:51:16.095131
+import React, { useEffect } from "react";
+import { useDispatch, useSelector } from "react-redux";
+import "./App.css";
+import Pages from "./pages";
+import { BrowserRouter } from "react-router-dom";
+import useInitialData from "./redux/initialData/useInitialData";
+import { SnackbarProvider } from "notistack";
+import NavBar from "./components/MainComponents/NavBar";
+import Index from "./components/MainComponents/Index";
+import RegistrationForm from "./components/MainComponents/RegistrationForm";
+import SearchPopper from "./components/SearchComponent";
+import useSocket from "./websocket/use_socket";
+import { useBackendContext } from "./contexts/BackendContext";
+import { Box, CircularProgress } from "@mui/material";
+import { Principal } from "@dfinity/principal";
+
+const App: React.FC = () => {
+  const dispatch = useDispatch();
+  const { profile } = useSelector((state: any) => state.filesState);
+  const { backendActor, ckUSDCActor } = useBackendContext();
+  useInitialData();
+  useSocket();
+
+  useEffect(() => {
+    if (backendActor && ckUSDCActor && profile?.id) {
+      (async () => {
+        try {
+          // Check CKUSDT balance first
+          const balance = await ckUSDCActor.icrc1_balance_of({
+            owner: Principal.fromText(profile.id),
+            subaccount: [],
+          });
+
+          if (Number(balance) > 0) {
+            const result = await backendActor.deposit_ckusdt();
+            console.log("Deposit CKUSDT result:", result);
+            if (result?.Ok) {
+              // Update wallet state in Redux
+              dispatch({ type: "SET_WALLET", wallet: result.Ok });
+            }
+          }
+        } catch (error) {
+          console.error("Error checking/depositing CKUSDT:", error);
+        }
+      })();
+    }
+  }, [backendActor, ckUSDCActor, profile, dispatch]);
+
+  let Loadder = (
+    <Box
+      style={{
+        display: "flex",
+        justifyContent: "center",
+        alignItems: "center",
+        height: "100vh", // This will make it center vertically for the whole viewport
+      }}
+    >
+      <CircularProgress size={100} />
+    </Box>
+  );
+
+  if (!backendActor) {
+    return Loadder;
+  }
+
+  return (
+    <BrowserRouter>
+      <SearchPopper />
+      <SnackbarProvider maxSnack={3}>
+        <RegistrationForm />
+        <Index />
+        <NavBar>
+          <Pages />
+        </NavBar>
+      </SnackbarProvider>
+    </BrowserRouter>
+  );
+};
+
+export default App;
+ if balance bigger then 0 show snackbar with progress shows you deposited value of balance

# 2024-12-24 17:59:05.807704
+```import React, { useState } from "react";
+import { useSelector } from "react-redux";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useSnackbar } from "notistack";
+import {
+  Box,
+  Card,
+  CardContent,
+  Typography,
+  Button,
+  Dialog,
+  CircularProgress,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  TextField,
+  Select,
+  MenuItem,
+  IconButton,
+  Table,
+  TableBody,
+  TableCell,
+  TableHead,
+  TableRow,
+  Paper,
+  Stack,
+  Grid,
+  InputAdornment,
+} from "@mui/material";
+import {
+  AccountBalanceWallet,
+  ArrowDownward,
+  ArrowUpward,
+  Send,
+  Close,
+  ContentCopy,
+} from "@mui/icons-material";
+
+const defaultWallet = {
+  owner: "0x0000000000000000000000000000000000000000",
+  balance: 0,
+  debts: {},
+  total_debt: 0,
+  exchanges: [],
+  received: 0,
+  spent: 0,
+};
+
+const WalletPage = ({ wallet = defaultWallet }) => {
+  const [amount, setAmount] = useState("");
+  const [recipient, setRecipient] = useState("");
+  const [withdrawAddress, setWithdrawAddress] = useState("");
+  const [openDialog, setOpenDialog] = useState("");
+  const [isProcessing, setIsProcessing] = useState(false);
+
+  const { backendActor } = useBackendContext();
+  const { all_friends } = useSelector((state: any) => state.filesState);
+  const { enqueueSnackbar } = useSnackbar();
+
+  const handleClose = () => setOpenDialog("");
+
+  const handleCopyAddress = () => {
+    navigator.clipboard.writeText(wallet?.owner || "");
+    // You might want to use MUI's Snackbar here instead of alert
+    alert("Address copied to clipboard!");
+  };
+
+  const handleTransaction = async (type) => {
+    if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
+      alert("Please enter a valid amount");
+      return;
+    }
+
+    setIsProcessing(true);
+    try {
+      let result;
+      if (type === "pay" && recipient) {
+        result = await backendActor.internal_transaction(
+          parseFloat(amount),
+          recipient,
+          { LocalSend: null }
+        );
+      } else if (type === "withdraw" && withdrawAddress) {
+        // Call withdraw_ckusdt for withdrawals
+        result = await backendActor.withdraw_ckusdt(
+          Number(amount), // Convert to u64
+          withdrawAddress
+        );
+      }
+      // console.log({result})
+
+      if ("Ok" in result) {
+        enqueueSnackbar("Transaction completed successfully", { variant: "success" });
+        handleClose();
+        setAmount("");
+        setWithdrawAddress("");
+        setRecipient("");
+      } else if ("Err" in result) {
+        enqueueSnackbar(JSON.stringify(result.Err), { variant: "error" });
+      }
+    } catch (error) {
+      console.error("Transaction failed:", error);
+      enqueueSnackbar(error.message || "Transaction failed", { variant: "error" });
+    } finally {
+      setIsProcessing(false);
+    }
+  };
+
+  const formatDate = (timestamp) => {
+    if (!timestamp) return "N/A";
+    return new Date(timestamp).toLocaleDateString();
+  };
+
+  return (
+    <Box sx={{ maxWidth: 1200, margin: "0 auto", p: 3 }}>
+      {/* Balance Card */}
+      <Card sx={{ mb: 4 }}>
+        <CardContent>
+          <Stack spacing={3}>
+            <Box display="flex" alignItems="center" gap={1}>
+              <AccountBalanceWallet />
+              <Typography variant="h5">Your Wallet</Typography>
+            </Box>
+
+            <Grid container spacing={3}>
+              <Grid item xs={12} md={6}>
+                <Typography color="text.secondary">
+                  Available Balance
+                </Typography>
+                <Typography variant="h3" component="div">
+                  ${wallet.balance.toFixed(2)}
+                </Typography>
+              </Grid>
+              <Grid item xs={12} md={6}>
+                <Typography color="text.secondary">Total Debts</Typography>
+                <Typography variant="h4" color="error">
+                  ${wallet.total_debt}
+                </Typography>
+              </Grid>
+              <Grid item xs={6}>
+                <Typography color="text.secondary">Total Received</Typography>
+                <Typography color="success.main" variant="h6">
+                  ${wallet.received}
+                </Typography>
+              </Grid>
+              <Grid item xs={6}>
+                <Typography color="text.secondary">Total Spent</Typography>
+                <Typography color="error" variant="h6">
+                  ${wallet.spent}
+                </Typography>
+              </Grid>
+            </Grid>
+          </Stack>
+        </CardContent>
+      </Card>
+
+      {/* Action Buttons */}
+      <Stack direction="row" spacing={2} sx={{ mb: 4 }}>
+        <Button
+          variant="outlined"
+          startIcon={<ArrowDownward />}
+          onClick={() => setOpenDialog("deposit")}
+          fullWidth
+        >
+          Deposit
+        </Button>
+        <Button
+          variant="outlined"
+          startIcon={<ArrowUpward />}
+          onClick={() => setOpenDialog("withdraw")}
+          fullWidth
+        >
+          Withdraw
+        </Button>
+        <Button
+          variant="outlined"
+          startIcon={<Send />}
+          onClick={() => setOpenDialog("pay")}
+          fullWidth
+        >
+          Pay
+        </Button>
+      </Stack>
+
+      {/* Transaction History */}
+      <Paper>
+        <Box p={3}>
+          <Typography variant="h6" gutterBottom>
+            Transaction History
+          </Typography>
+        </Box>
+        <Table>
+          <TableHead>
+            <TableRow>
+              <TableCell>Date</TableCell>
+              <TableCell>Type</TableCell>
+              <TableCell>From</TableCell>
+              <TableCell>To</TableCell>
+              <TableCell align="right">Amount</TableCell>
+            </TableRow>
+          </TableHead>
+          <TableBody>
+            {wallet.exchanges.length > 0 ? (
+              wallet.exchanges.map((exchange, index) => (
+                <TableRow key={index}>
+                  <TableCell>{formatDate(exchange.date_created)}</TableCell>
+                  <TableCell>{exchange.type}</TableCell>
+                  <TableCell>{exchange.from}</TableCell>
+                  <TableCell>{exchange.to}</TableCell>
+                  <TableCell
+                    align="right"
+                    sx={{
+                      color:
+                        exchange.type &&
+                        (exchange.type === "Deposit" ||
+                          exchange.type === "LocalReceive")
+                          ? "success.main"
+                          : "error.main",
+                    }}
+                  >
+                    ${Math.abs(exchange.amount).toFixed(2)}
+                  </TableCell>
+                </TableRow>
+              ))
+            ) : (
+              <TableRow>
+                <TableCell colSpan={5} align="center">
+                  <Typography color="text.secondary">
+                    No transactions yet
+                  </Typography>
+                </TableCell>
+              </TableRow>
+            )}
+          </TableBody>
+        </Table>
+      </Paper>
+
+      {/* Deposit Dialog */}
+      <Dialog
+        open={openDialog === "deposit"}
+        onClose={handleClose}
+        maxWidth="sm"
+        fullWidth
+      >
+        <DialogTitle>
+          Deposit Funds
+          <IconButton
+            onClick={handleClose}
+            sx={{ position: "absolute", right: 8, top: 8 }}
+          >
+            <Close />
+          </IconButton>
+        </DialogTitle>
+        <DialogContent>
+          <Box py={2}>
+            <Typography variant="subtitle2" gutterBottom>
+              Your Wallet Address
+            </Typography>
+            <TextField
+              fullWidth
+              variant="outlined"
+              value={wallet.owner}
+              InputProps={{
+                readOnly: true,
+                endAdornment: (
+                  <InputAdornment position="end">
+                    <IconButton onClick={handleCopyAddress}>
+                      <ContentCopy />
+                    </IconButton>
+                  </InputAdornment>
+                ),
+              }}
+            />
+            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
+              Send your funds to this address. The balance will be updated
+              automatically.
+            </Typography>
+          </Box>
+        </DialogContent>
+      </Dialog>
+
+      {/* Withdraw Dialog */}
+      <Dialog
+        open={openDialog === "withdraw"}
+        onClose={handleClose}
+        maxWidth="sm"
+        fullWidth
+      >
+        <DialogTitle>
+          Withdraw Funds
+          <IconButton
+            onClick={handleClose}
+            sx={{ position: "absolute", right: 8, top: 8 }}
+          >
+            <Close />
+          </IconButton>
+        </DialogTitle>
+        <DialogContent>
+          <Stack spacing={3} sx={{ mt: 2 }}>
+            <TextField
+              label="Amount"
+              type="number"
+              value={amount}
+              onChange={(e) => setAmount(e.target.value)}
+              fullWidth
+            />
+            <TextField
+              label="Withdrawal Address"
+              value={withdrawAddress}
+              onChange={(e) => setWithdrawAddress(e.target.value)}
+              fullWidth
+            />
+          </Stack>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={handleClose} disabled={isProcessing}>Cancel</Button>
+          <Button
+            onClick={() => handleTransaction("withdraw")}
+            variant="contained"
+            disabled={isProcessing}
+            startIcon={isProcessing ? <CircularProgress size={20} /> : null}
+          >
+            {isProcessing ? 'Processing...' : 'Confirm Withdrawal'}
+          </Button>
+        </DialogActions>
+      </Dialog>
+
+      {/* Pay Dialog */}
+      <Dialog
+        open={openDialog === "pay"}
+        onClose={handleClose}
+        maxWidth="sm"
+        fullWidth
+      >
+        <DialogTitle>
+          Pay Someone
+          <IconButton
+            onClick={handleClose}
+            sx={{ position: "absolute", right: 8, top: 8 }}
+          >
+            <Close />
+          </IconButton>
+        </DialogTitle>
+        <DialogContent>
+          <Stack spacing={3} sx={{ mt: 2 }}>
+            <Select
+              value={recipient}
+              onChange={(e) => setRecipient(e.target.value)}
+              displayEmpty
+              fullWidth
+            >
+              <MenuItem value="" disabled>
+                Select recipient
+              </MenuItem>
+              {all_friends.map((friend) => (
+                <MenuItem key={friend.id} value={friend.id}>
+                  {friend.name} ({friend.id.slice(0, 8)}...)
+                </MenuItem>
+              ))}
+            </Select>
+            <TextField
+              label="Amount"
+              type="number"
+              value={amount}
+              onChange={(e) => setAmount(e.target.value)}
+              fullWidth
+            />
+          </Stack>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={handleClose} disabled={isProcessing}>Cancel</Button>
+          <Button 
+            onClick={() => handleTransaction("pay")} 
+            variant="contained"
+            disabled={isProcessing}
+            startIcon={isProcessing ? <CircularProgress size={20} /> : null}
+          >
+            {isProcessing ? 'Processing...' : 'Send Payment'}
+          </Button>
+        </DialogActions>
+      </Dialog>
+    </Box>
+  );
+};
+
+export default WalletPage;
+``` at /Users/ahmed/Desktop/odoc/src/frontend/components/MuiComponents/walletUi.tsx the value values `From` and `To` are user princiapl check if the id in all_friends and review usern.name instead 

# 2024-12-24 17:59:53.905010
+if from id == profile.id show string "You" also if to id== profile.id show "You" 

# 2024-12-24 18:03:28.172421
+I think type is wrong. notice the data setrecute is like this `{  "wallet": {    "balance": 0,    "owner": "xv6bm-v3sp6-ivdhx-gg4aw-qurl2-2hybk-j6yya-tva76-xscfh-hdvvk-uae",    "total_debt": 0,    "spent": 0,    "exchanges": [      {        "to": "k22i7-ar6j3-rgukj-fpyjq-txekn-tgiqp-vwmto-paba5-5imjj-p4b3o-bqe",        "_type": {          "LocalSend": null        },        "date_created": 1735034235399287000,        "from": "xv6bm-v3sp6-ivdhx-gg4aw-qurl2-2hybk-j6yya-tva76-xscfh-hdvvk-uae",        "amount": 0      }    ],    "debts": [],    "received": 0  }}`

# 2024-12-24 18:05:08.479755
+notice the interface for exchange export interface Exchange {   'to' : string,   '_type' : ExchangeType,   'date_created' : number,   'from' : string,   'amount' : number, } export type ExchangeType = { 'Withdraw' : null } |   { 'Deposit' : null } |   { 'LocalSend' : null } |   { 'LocalReceive' : null };

# 2024-12-27 22:21:40.511253
+show chat window in form of dialog instead of movable window if porp.dialog=true import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+  Button,
+  Autocomplete,
+  Chip,
+} from "@mui/material";
+import { MembersSelect, AdminsSelect, WorkspaceSelect } from "./index";
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+  ArrowBack as ArrowBackIcon,
+  Delete as DeleteIcon,
+  Check,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useDispatch, useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import { Link } from "react-router-dom";
+import { Chat } from "../../../declarations/backend/backend.did";
+import { handleRedux } from "../../redux/store/handleRedux";
+
+const ChatWindow = memo(
+  ({
+    chat,
+    onClose,
+    position,
+    onPositionChange,
+    onSendMessage,
+    onUpdateChat,
+  }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [formData, setFormData] = useState({
+      name: chat.name,
+      workspaces: chat.workspaces,
+      admins: chat.admins,
+      members: chat.members,
+    });
+    const { workspaces, all_friends, profile } = useSelector(
+      (state: any) => state.filesState,
+    );
+    const { backendActor } = useBackendContext();
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+    const [editedName, setEditedName] = useState(chat.name);
+    const [isSaving, setIsSaving] = useState(false);
+    const [saveSuccess, setSaveSuccess] = useState(false);
+    const messagesEndRef = useRef(null);
+    const saveSuccessTimeout = useRef(null);
+
+    useEffect(() => {
+      // setSelectedWorkspace(chat.workspaces[0] || "");
+      // setEditedMembers(chat.members);
+    }, [chat]);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+    const dispatch = useDispatch();
+
+    const handleSaveChat = async (updatedChat: Chat) => {
+      setIsSaving(true);
+      try {
+        // Keep existing Principals if they're already Principal objects
+        const formattedChat = {
+          ...updatedChat,
+          admins: updatedChat.admins.map((a) => Principal.fromText(a.id || a)),
+          creator:
+            updatedChat.creator instanceof Principal
+              ? updatedChat.creator
+              : Principal.fromText(updatedChat.creator.id),
+          members: updatedChat.members.map((m) =>
+            Principal.fromText(m.id || m),
+          ),
+          messages: updatedChat.messages.map((msg) => ({
+            ...msg,
+            sender:
+              msg.sender instanceof Principal
+                ? msg.sender
+                : Principal.fromText(msg.sender),
+            seen_by: msg.seen_by.map((s) =>
+              s instanceof Principal ? s : Principal.fromText(s),
+            ),
+            date:
+              typeof msg.date === "bigint"
+                ? msg.date
+                : BigInt(msg.date.toString()),
+          })),
+        };
+        const result = await backendActor.update_chat(formattedChat);
+        if ("Ok" in result) {
+          if (onUpdateChat) {
+            onUpdateChat(result.Ok);
+          }
+          setEditedName(result.Ok.name);
+          setSaveSuccess(true);
+          if (saveSuccessTimeout.current) {
+            clearTimeout(saveSuccessTimeout.current);
+          }
+          saveSuccessTimeout.current = setTimeout(() => {
+            setSaveSuccess(false);
+          }, 2000);
+        }
+      } catch (error) {
+        console.error("Failed to update chat:", error);
+      } finally {
+        setIsSaving(false);
+      }
+    };
+
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            {isSettingsView ? (
+              <IconButton size="small" onClick={() => setIsSettingsView(false)}>
+                <ArrowBackIcon />
+              </IconButton>
+            ) : (
+              <IconButton size="small" onClick={() => setIsSettingsView(true)}>
+                <SettingsIcon />
+              </IconButton>
+            )}
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && !isSettingsView && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography
+                      to={`user?id=${message.sender.toString()}`}
+                      component={Link}
+                      variant="subtitle2"
+                    >
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+
+        {!isMinimized && isSettingsView && (
+          <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Chat Settings
+            </Typography>
+
+            {chat.creator?.id !== profile?.id ? (
+              <Typography color="error">
+                Only the chat creator can modify settings
+              </Typography>
+            ) : chat.name === "private_chat" ? (
+              <FormControl fullWidth sx={{ mb: 2 }}>
+                <InputLabel>Workspace</InputLabel>
+                <Select
+                  value={selectedWorkspace}
+                  label="Workspace"
+                  onChange={(e) => setSelectedWorkspace(e.target.value)}
+                >
+                  {workspaces.map((workspace) => (
+                    <MenuItem key={workspace.id} value={workspace.id}>
+                      {workspace.name}
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            ) : (
+              <>
+                <TextField
+                  fullWidth
+                  label="Chat Name"
+                  value={formData.name}
+                  onChange={(e) =>
+                    setFormData((prev) => ({ ...prev, name: e.target.value }))
+                  }
+                  sx={{ mb: 2 }}
+                />
+                <WorkspaceSelect
+                  value={workspaces.filter((w) =>
+                    formData.workspaces.includes(w.id),
+                  )}
+                  onChange={(newValue) => {
+                    setFormData((prev) => ({
+                      ...prev,
+                      workspaces: newValue.map((w) => w.id),
+                    }));
+                  }}
+                  workspaces={workspaces}
+                />
+
+                <AdminsSelect
+                  value={all_friends.filter((f) =>
+                    formData.admins.some((a) => a.toString() === f.id),
+                  )}
+                  onChange={(newValue) => {
+                    setFormData((prev) => ({
+                      ...prev,
+                      admins: newValue.map((admin) => admin.id),
+                    }));
+                  }}
+                  members={all_friends}
+                />
+
+                <MembersSelect
+                  value={all_friends.filter((f) =>
+                    formData.members.some((m) => m.toString() === f.id),
+                  )}
+                  onChange={(newValue) => {
+                    setFormData((prev) => ({
+                      ...prev,
+                      members: newValue.map((member) => member.id),
+                    }));
+                  }}
+                  users={all_friends}
+                />
+
+                <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
+                  <Button
+                    variant="contained"
+                    color={saveSuccess ? "success" : "primary"}
+                    fullWidth
+                    disabled={isSaving}
+                    startIcon={isSaving ? <CircularProgress size={20} /> : (saveSuccess ? <Check /> : null)}
+                    onClick={async () => {
+                      const updatedChat: Chat = {
+                        ...chat,
+                        name: formData.name,
+                        admins: formData.admins,
+                        creator: chat.creator,
+                        workspaces: formData.workspaces,
+                        members: formData.members,
+                      };
+                      await handleSaveChat(updatedChat);
+                      setIsSettingsView(false);
+                    }}
+                  >
+                    Save Changes
+                  </Button>
+
+                  {chat.name !== "private_chat" && (
+                    <Button
+                      variant="contained"
+                      color="error"
+                      onClick={() => {
+                        if (
+                          window.confirm(
+                            "Are you sure you want to delete this chat? This action cannot be undone.",
+                          )
+                        ) {
+                          backendActor
+                            .delete_chat(chat.id)
+                            .then((result) => {
+                              if ("Ok" in result && onClose) {
+                                dispatch(
+                                  handleRedux("DELETE_CHAT", {
+                                    chat_id: chat.id,
+                                  }),
+                                );
+                                onClose(chat.id);
+                              }
+                            })
+                            .catch((error) => {
+                              console.error("Failed to delete chat:", error);
+                            });
+                        }
+                      }}
+                    >
+                      Delete Chat
+                    </Button>
+                  )}
+                </Box>
+              </>
+            )}
+          </Box>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+

# 2024-12-27 22:23:35.911218
+Make another option prop for chat window which is dialog and if it is true show chat window in form of dialog instead of movable window here is full code import React, { memo, useCallback, useEffect, useRef, useState } from "react";
+import {
+  AppBar,
+  Box,
+  CircularProgress,
+  IconButton,
+  Paper,
+  TextField,
+  Toolbar,
+  Typography,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+  Button,
+  Autocomplete,
+  Chip,
+} from "@mui/material";
+import { MembersSelect, AdminsSelect, WorkspaceSelect } from "./index";
+import {
+  DragIndicator as DragHandle,
+  OpenInFull as OpenInFullIcon,
+  Send as SendIcon,
+  Settings as SettingsIcon,
+  ArrowBack as ArrowBackIcon,
+  Delete as DeleteIcon,
+  Check,
+} from "@mui/icons-material";
+import MinimizeIcon from "@mui/icons-material/Minimize";
+import CloseIcon from "@mui/icons-material/Close";
+import { useBackendContext } from "../../contexts/BackendContext";
+import { useDispatch, useSelector } from "react-redux";
+import { Principal } from "@dfinity/principal";
+import { randomString } from "../../DataProcessing/dataSamples";
+import formatTimestamp from "../../utils/time";
+import { isConstantNode } from "mathjs";
+import { Link } from "react-router-dom";
+import { Chat } from "../../../declarations/backend/backend.did";
+import { handleRedux } from "../../redux/store/handleRedux";
+
+const ChatWindow = memo(
+  ({
+    chat,
+    onClose,
+    position,
+    onPositionChange,
+    onSendMessage,
+    onUpdateChat,
+  }) => {
+    const [isDragging, setIsDragging] = useState(false);
+    const [isSettingsView, setIsSettingsView] = useState(false);
+    const [formData, setFormData] = useState({
+      name: chat.name,
+      workspaces: chat.workspaces,
+      admins: chat.admins,
+      members: chat.members,
+    });
+    const { workspaces, all_friends, profile } = useSelector(
+      (state: any) => state.filesState,
+    );
+    const { backendActor } = useBackendContext();
+    const [dragPosition, setDragPosition] = useState(position);
+    const [newMessage, setNewMessage] = useState("");
+    const [isMinimized, setIsMinimized] = useState(false);
+    const [isSending, setIsSending] = useState(false);
+    const [editedName, setEditedName] = useState(chat.name);
+    const [isSaving, setIsSaving] = useState(false);
+    const [saveSuccess, setSaveSuccess] = useState(false);
+    const messagesEndRef = useRef(null);
+    const saveSuccessTimeout = useRef(null);
+
+    useEffect(() => {
+      // setSelectedWorkspace(chat.workspaces[0] || "");
+      // setEditedMembers(chat.members);
+    }, [chat]);
+
+    const scrollToBottom = useCallback(() => {
+      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
+    }, []);
+
+    useEffect(() => {
+      scrollToBottom();
+    }, [chat.messages, scrollToBottom]);
+
+    const renderSenderName = (sender) => {
+      // Handle case where sender is a Principal object
+      if (sender instanceof Principal) {
+        const senderStr = sender.toString();
+        return senderStr === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Handle case where sender is an object with __principal__
+      if (sender?.toString()) {
+        return sender.toString() === profile?.id
+          ? "You"
+          : `${all_friends.find((u) => u.id === sender.toString())?.name || sender.toString().slice(8, 16)}`;
+      }
+      // Fallback
+      return "Unknown User";
+    };
+
+    const isCurrentUser = (sender) => {
+      if (sender instanceof Principal) {
+        return sender.toString() === profile?.id;
+      }
+      return sender?.__principal__ === profile?.id;
+    };
+    const handleSendMessage = useCallback(
+      async (e) => {
+        e.preventDefault();
+        if (!newMessage.trim() || !profile?.id || isSending) return;
+
+        try {
+          setIsSending(true);
+          await onSendMessage(chat.id, newMessage);
+          setNewMessage("");
+          scrollToBottom();
+        } catch (error) {
+          console.error("Error sending message:", error);
+        } finally {
+          setIsSending(false);
+        }
+      },
+      [
+        chat.id,
+        newMessage,
+        profile?.id,
+        isSending,
+        onSendMessage,
+        scrollToBottom,
+      ],
+    );
+
+    const handleDragStart = useCallback((e) => {
+      setIsDragging(true);
+      const boundingRect = e.currentTarget.getBoundingClientRect();
+      const offsetX = e.clientX - boundingRect.left;
+      const offsetY = e.clientY - boundingRect.top;
+      e.currentTarget.dataset.offsetX = offsetX;
+      e.currentTarget.dataset.offsetY = offsetY;
+    }, []);
+
+    const handleDrag = useCallback(
+      (e) => {
+        if (!isDragging || !e.clientX || !e.clientY) return;
+        const offsetX = parseFloat(e.currentTarget.dataset.offsetX);
+        const offsetY = parseFloat(e.currentTarget.dataset.offsetY);
+        setDragPosition({
+          x: Math.max(0, e.clientX - offsetX),
+          y: Math.max(0, e.clientY - offsetY),
+        });
+      },
+      [isDragging],
+    );
+
+    const handleDragEnd = useCallback(() => {
+      setIsDragging(false);
+      onPositionChange(chat.id, dragPosition);
+    }, [chat.id, dragPosition, onPositionChange]);
+    const dispatch = useDispatch();
+
+    const handleSaveChat = async (updatedChat: Chat) => {
+      setIsSaving(true);
+      try {
+        // Keep existing Principals if they're already Principal objects
+        const formattedChat = {
+          ...updatedChat,
+          admins: updatedChat.admins.map((a) => Principal.fromText(a.id || a)),
+          creator:
+            updatedChat.creator instanceof Principal
+              ? updatedChat.creator
+              : Principal.fromText(updatedChat.creator.id),
+          members: updatedChat.members.map((m) =>
+            Principal.fromText(m.id || m),
+          ),
+          messages: updatedChat.messages.map((msg) => ({
+            ...msg,
+            sender:
+              msg.sender instanceof Principal
+                ? msg.sender
+                : Principal.fromText(msg.sender),
+            seen_by: msg.seen_by.map((s) =>
+              s instanceof Principal ? s : Principal.fromText(s),
+            ),
+            date:
+              typeof msg.date === "bigint"
+                ? msg.date
+                : BigInt(msg.date.toString()),
+          })),
+        };
+        const result = await backendActor.update_chat(formattedChat);
+        if ("Ok" in result) {
+          if (onUpdateChat) {
+            onUpdateChat(result.Ok);
+          }
+          setEditedName(result.Ok.name);
+          setSaveSuccess(true);
+          if (saveSuccessTimeout.current) {
+            clearTimeout(saveSuccessTimeout.current);
+          }
+          saveSuccessTimeout.current = setTimeout(() => {
+            setSaveSuccess(false);
+          }, 2000);
+        }
+      } catch (error) {
+        console.error("Failed to update chat:", error);
+      } finally {
+        setIsSaving(false);
+      }
+    };
+
+    return (
+      <Paper
+        elevation={3}
+        sx={{
+          position: "fixed",
+          top: dragPosition.y,
+          left: dragPosition.x,
+          width: 320,
+          height: isMinimized ? "auto" : 400,
+          display: "flex",
+          flexDirection: "column",
+          zIndex: 1200,
+          resize: "both",
+          overflow: "hidden",
+        }}
+      >
+        <AppBar
+          position="static"
+          color="default"
+          elevation={1}
+          onMouseDown={handleDragStart}
+          onMouseMove={handleDrag}
+          onMouseUp={handleDragEnd}
+          onMouseLeave={() => setIsDragging(false)}
+          sx={{ cursor: "move" }}
+        >
+          <Toolbar variant="dense">
+            <DragHandle sx={{ mr: 1 }} />
+            <Typography variant="subtitle2" sx={{ flex: 1 }}>
+              {chat.name}
+            </Typography>
+            <IconButton
+              size="small"
+              onClick={() => setIsMinimized(!isMinimized)}
+            >
+              {isMinimized ? <OpenInFullIcon /> : <MinimizeIcon />}
+            </IconButton>
+            {isSettingsView ? (
+              <IconButton size="small" onClick={() => setIsSettingsView(false)}>
+                <ArrowBackIcon />
+              </IconButton>
+            ) : (
+              <IconButton size="small" onClick={() => setIsSettingsView(true)}>
+                <SettingsIcon />
+              </IconButton>
+            )}
+            <IconButton size="small" onClick={() => onClose(chat.id)}>
+              <CloseIcon />
+            </IconButton>
+          </Toolbar>
+        </AppBar>
+
+        {!isMinimized && !isSettingsView && (
+          <>
+            <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+              {chat.messages.map((message) => {
+                const isOwnMessage = isCurrentUser(message.sender);
+
+                return (
+                  <Paper
+                    key={message.id}
+                    sx={{
+                      p: 1,
+                      mb: 1,
+                      maxWidth: "80%",
+                      ml: isOwnMessage ? "auto" : 0,
+                      bgcolor: isOwnMessage
+                        ? "primary.dark"
+                        : "background.paper",
+                      color: isOwnMessage
+                        ? "primary.contrastText"
+                        : "text.primary",
+                    }}
+                  >
+                    <Typography
+                      to={`user?id=${message.sender.toString()}`}
+                      component={Link}
+                      variant="subtitle2"
+                    >
+                      {renderSenderName(message.sender)}
+                    </Typography>
+                    <Typography variant="body2">{message.message}</Typography>
+                    <Typography
+                      variant="caption"
+                      color={
+                        isOwnMessage ? "primary.contrastText" : "text.secondary"
+                      }
+                    >
+                      {formatTimestamp(message.date)}
+                    </Typography>
+                  </Paper>
+                );
+              })}
+              <div ref={messagesEndRef} />
+            </Box>
+
+            <Paper sx={{ p: 1 }}>
+              <form
+                onSubmit={handleSendMessage}
+                style={{ display: "flex", gap: 8 }}
+              >
+                <TextField
+                  size="small"
+                  value={newMessage}
+                  onChange={(e) => setNewMessage(e.target.value)}
+                  placeholder="Type your message..."
+                  fullWidth
+                  variant="outlined"
+                  disabled={isSending}
+                />
+                <IconButton
+                  type="submit"
+                  color="primary"
+                  size="small"
+                  disabled={isSending || !newMessage.trim()}
+                  sx={{
+                    position: "relative",
+                    width: 40, // Fixed width to prevent shifting
+                    height: 40, // Fixed height to prevent shifting
+                  }}
+                >
+                  {isSending ? (
+                    <CircularProgress size={24} color="primary" />
+                  ) : (
+                    <SendIcon />
+                  )}
+                </IconButton>
+              </form>
+            </Paper>
+          </>
+        )}
+
+        {!isMinimized && isSettingsView && (
+          <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
+            <Typography variant="h6" gutterBottom>
+              Chat Settings
+            </Typography>
+
+            {chat.creator?.id !== profile?.id ? (
+              <Typography color="error">
+                Only the chat creator can modify settings
+              </Typography>
+            ) : chat.name === "private_chat" ? (
+              <FormControl fullWidth sx={{ mb: 2 }}>
+                <InputLabel>Workspace</InputLabel>
+                <Select
+                  value={selectedWorkspace}
+                  label="Workspace"
+                  onChange={(e) => setSelectedWorkspace(e.target.value)}
+                >
+                  {workspaces.map((workspace) => (
+                    <MenuItem key={workspace.id} value={workspace.id}>
+                      {workspace.name}
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            ) : (
+              <>
+                <TextField
+                  fullWidth
+                  label="Chat Name"
+                  value={formData.name}
+                  onChange={(e) =>
+                    setFormData((prev) => ({ ...prev, name: e.target.value }))
+                  }
+                  sx={{ mb: 2 }}
+                />
+                <WorkspaceSelect
+                  value={workspaces.filter((w) =>
+                    formData.workspaces.includes(w.id),
+                  )}
+                  onChange={(newValue) => {
+                    setFormData((prev) => ({
+                      ...prev,
+                      workspaces: newValue.map((w) => w.id),
+                    }));
+                  }}
+                  workspaces={workspaces}
+                />
+
+                <AdminsSelect
+                  value={all_friends.filter((f) =>
+                    formData.admins.some((a) => a.toString() === f.id),
+                  )}
+                  onChange={(newValue) => {
+                    setFormData((prev) => ({
+                      ...prev,
+                      admins: newValue.map((admin) => admin.id),
+                    }));
+                  }}
+                  members={all_friends}
+                />
+
+                <MembersSelect
+                  value={all_friends.filter((f) =>
+                    formData.members.some((m) => m.toString() === f.id),
+                  )}
+                  onChange={(newValue) => {
+                    setFormData((prev) => ({
+                      ...prev,
+                      members: newValue.map((member) => member.id),
+                    }));
+                  }}
+                  users={all_friends}
+                />
+
+                <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
+                  <Button
+                    variant="contained"
+                    color={saveSuccess ? "success" : "primary"}
+                    fullWidth
+                    disabled={isSaving}
+                    startIcon={isSaving ? <CircularProgress size={20} /> : (saveSuccess ? <Check /> : null)}
+                    onClick={async () => {
+                      const updatedChat: Chat = {
+                        ...chat,
+                        name: formData.name,
+                        admins: formData.admins,
+                        creator: chat.creator,
+                        workspaces: formData.workspaces,
+                        members: formData.members,
+                      };
+                      await handleSaveChat(updatedChat);
+                      setIsSettingsView(false);
+                    }}
+                  >
+                    Save Changes
+                  </Button>
+
+                  {chat.name !== "private_chat" && (
+                    <Button
+                      variant="contained"
+                      color="error"
+                      onClick={() => {
+                        if (
+                          window.confirm(
+                            "Are you sure you want to delete this chat? This action cannot be undone.",
+                          )
+                        ) {
+                          backendActor
+                            .delete_chat(chat.id)
+                            .then((result) => {
+                              if ("Ok" in result && onClose) {
+                                dispatch(
+                                  handleRedux("DELETE_CHAT", {
+                                    chat_id: chat.id,
+                                  }),
+                                );
+                                onClose(chat.id);
+                              }
+                            })
+                            .catch((error) => {
+                              console.error("Failed to delete chat:", error);
+                            });
+                        }
+                      }}
+                    >
+                      Delete Chat
+                    </Button>
+                  )}
+                </Box>
+              </>
+            )}
+          </Box>
+        )}
+      </Paper>
+    );
+  },
+);
+
+export default ChatWindow;
+

# 2024-12-27 22:23:55.026015
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx

# 2024-12-27 22:24:00.671308
+here is the path /Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx

# 2024-12-27 22:24:18.228956
+y

# 2024-12-27 22:25:08.911739
+[plugin:vite:esbuild] Transform failed with 1 error:
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:256:8: ERROR: Expected ")" but found "{"
+/Users/ahmed/Desktop/odoc/src/frontend/components/Chat/chatWindow.tsx:256:8
+Expected ")" but found "{"
+254|          </AppBar>
+255|  
+256|          {!isMinimized && !isSettingsView && (
+   |          ^
+257|            <>
+258|              <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>

# 2024-12-29 15:17:50.932232
+at /Users/ahmed/Desktop/odoc/src/frontend/pages/discover/viewPost.tsx make the delete post dilog in sperate compnent

# 2025-01-24 17:29:48.137445
+y

# 2025-01-24 17:35:16.380519
+import React from "react";
+import {
+  Box,
+  Button,
+  Card,
+  CardContent,
+  CircularProgress,
+  Collapse,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogTitle,
+  IconButton,
+  Menu,
+  MenuItem,
+} from "@mui/material";
+import { Heart, MessageCircle, MoreVertical, ThumbsDown } from "lucide-react";
+import { keyframes, styled } from "@mui/material/styles";
+import { useSelector } from "react-redux";
+import { useSnackbar } from "notistack";
+import { formatRelativeTime } from "../../utils/time";
+import EditorComponent from "../../components/EditorComponent";
+import { deserializeContentTree } from "../../DataProcessing/deserlize/deserializeContents";
+import UserAvatarMenu from "../../components/MainComponents/UserAvatarMenu";
+import { useBackendContext } from "../../contexts/BackendContext";
+import serializeFileContents from "../../DataProcessing/serialize/serializeFileContents";
+import { Post, PostUser } from "../../../declarations/backend/backend.did";
+import { DndProvider } from "react-dnd";
+import { HTML5Backend } from "react-dnd-html5-backend";
+import CommentList from "./CommentList";
+
+interface ViewPostComponentProps {
+  post: PostUser;
+  handleDeletePost: (postId: string) => void;
+}
+
+const fadeIn = keyframes`
+  from {
+    opacity: 0;
+    transform: translateY(10px);
+  }
+  to {
+    opacity: 1;
+    transform: translateY(0);
+  }
+`;
+
+const PostCard = styled(Card)(({ theme }) => ({
+  background: "rgba(143,143,143,0.42)",
+  backdropFilter: "blur(16px) saturate(180%)",
+  border: "1px solid rgba(255, 255, 255, 0.125)",
+  borderRadius: theme.spacing(2),
+  padding: 0,
+  position: "static",
+  boxShadow: theme.shadows[1],
+  transition: theme.transitions.create(["transform", "box-shadow"], {
+    duration: theme.transitions.duration.shorter,
+  }),
+  overflow: "visible",
+  marginBottom: theme.spacing(2),
+  "&:hover": {
+    transform: "translateY(-5px)",
+    boxShadow: theme.shadows[8],
+  },
+  animation: `${fadeIn} 0.5s ease-out`,
+}));
+
+const StyledCardContent = styled(CardContent)(({ theme }) => ({
+  padding: theme.spacing(2),
+  "&:last-child": {
+    paddingBottom: theme.spacing(2),
+  },
+  overflow: "visible",
+  position: "static",
+}));
+
+const PostActionButton = styled(IconButton)(({ theme }) => ({
+  color: theme.palette.mode === "dark" ? "#E9D5FF" : "#6366F1",
+  transition: theme.transitions.create(["transform", "background-color"], {
+    duration: theme.transitions.duration.shorter,
+  }),
+  padding: theme.spacing(1),
+  borderRadius: theme.shape.borderRadius * 1.5,
+  "&:hover": {
+    transform: "scale(1.1)",
+    backgroundColor:
+      theme.palette.mode === "dark"
+        ? "rgba(139, 92, 246, 0.1)"
+        : "rgba(79, 70, 229, 0.1)",
+  },
+  "&:active": {
+    transform: "scale(0.95)",
+  },
+  "&.Mui-disabled": {
+    opacity: 0.8,
+    color: theme.palette.mode === "dark" ? "#9CA3AF" : "#4B5563",
+    "& span": {
+      color: theme.palette.mode === "dark" ? "#E5E7EB" : "#1F2937",
+      fontWeight: 500,
+    },
+  },
+}));
+
+const StyledMenu = styled(Menu)(({ theme }) => ({
+  "& .MuiPaper-root": {
+    backgroundColor:
+      theme.palette.mode === "dark"
+        ? "rgba(17, 24, 39, 0.95)"
+        : "rgba(255, 255, 255, 0.95)",
+    border: `1px solid ${
+      theme.palette.mode === "dark"
+        ? "rgba(139, 92, 246, 0.2)"
+        : "rgba(79, 70, 229, 0.2)"
+    }`,
+  },
+}));
+
+const StyledDialog = styled(Dialog)(({ theme }) => ({
+  "& .MuiPaper-root": {
+    backgroundColor:
+      theme.palette.mode === "dark"
+        ? "rgba(17, 24, 39, 0.95)"
+        : "rgba(255, 255, 255, 0.95)",
+    border: `1px solid ${
+      theme.palette.mode === "dark"
+        ? "rgba(139, 92, 246, 0.2)"
+        : "rgba(79, 70, 229, 0.2)"
+    }`,
+  },
+}));
+
+const ViewPostComponent: React.FC<ViewPostComponentProps> = ({
+  posts,
+  post,
+  handleDeletePost,
+  setPosts,
+}) => {
+  const { backendActor } = useBackendContext();
+  const { enqueueSnackbar } = useSnackbar();
+  const { profile } = useSelector((state: any) => state.filesState);
+  const [showComments, setShowComments] = React.useState(false);
+
+  const [voteLoading, setVoteLoad] = React.useState(false);
+  const [isChanged, setChanged] = React.useState(false);
+  const [isDeleting, setIsDeleting] = React.useState(false);
+  const [menuAnchorEl, setMenuAnchorEl] = React.useState<null | HTMLElement>(
+    null,
+  );
+  const [deleteDialogOpen, setDeleteDialogOpen] = React.useState(false);
+  const [votes, setVotes] = React.useState({
+    up: post.votes_up,
+    down: post.votes_down,
+  });
+
+  const contentTree = React.useRef([]);
+
+  const handleMenuClick = (event: React.MouseEvent<HTMLElement>) => {
+    setMenuAnchorEl(event.currentTarget);
+  };
+
+  const handleMenuClose = () => {
+    setMenuAnchorEl(null);
+  };
+
+  const handleDeleteClick = () => {
+    handleMenuClose();
+    setDeleteDialogOpen(true);
+  };
+
+  const handleDeleteConfirm = async () => {
+    setDeleteDialogOpen(false);
+    setIsDeleting(true);
+    try {
+      const res = await backendActor?.delete_post(post.id);
+      if (res?.Ok === null) {
+        enqueueSnackbar("Post deleted successfully", { variant: "success" });
+        handleDeletePost(post.id);
+      } else {
+        enqueueSnackbar(JSON.stringify(res?.Err), { variant: "error" });
+      }
+    } catch (error) {
+      console.error({ error });
+      enqueueSnackbar("Failed to delete post: " + error, { variant: "error" });
+    }
+  };
+
+  const onClickSave = async () => {
+    setChanged(false);
+    const newPostObj: Post = {
+      ...post,
+      tags: [],
+      content_tree: serializeFileContents(contentTree.current)[0][0][1],
+      creator: profile.id,
+      votes_up: votes.up,
+      votes_down: votes.down,
+    };
+
+    const result = await backendActor.save_post(newPostObj);
+    console.log({ result });
+  };
+
+  const onLike = async () => {
+    if (profile?.id === post.creator.id) {
+      enqueueSnackbar("You can't like your own post", { variant: "error" });
+      return;
+    }
+    setVoteLoad(true);
+    try {
+      const votesUp = votes.up.map((v) => v.toString());
+      if (votesUp.includes(profile?.id)) {
+        const res = await backendActor.unvote(post.id);
+        setVotes({ up: res.Ok.votes_up, down: res.Ok.votes_down });
+      } else {
+        const res = await backendActor.vote_up(post.id);
+        setVotes({ up: res.Ok.votes_up, down: res.Ok.votes_down });
+      }
+    } finally {
+      setVoteLoad(false);
+    }
+  };
+
+  const onDisLike = async () => {
+    if (profile?.id === post.creator.id) {
+      enqueueSnackbar("You can't dislike your own post", { variant: "error" });
+      return;
+    }
+    setVoteLoad(true);
+    try {
+      const votesDown = votes.down.map((v) => v.toString());
+      if (votesDown.includes(profile.id)) {
+        const res = await backendActor.unvote(post.id);
+        setVotes({ up: res.Ok.votes_up, down: res.Ok.votes_down });
+      } else {
+        const res = await backendActor.vote_down(post.id);
+        setVotes({ up: res.Ok.votes_up, down: res.Ok.votes_down });
+      }
+    } finally {
+      setVoteLoad(false);
+    }
+  };
+
+  if (isDeleting) {
+    return (
+      <PostCard>
+        <StyledCardContent>
+          <Box
+            sx={{
+              display: "flex",
+              justifyContent: "center",
+              alignItems: "center",
+              height: "10rem",
+            }}
+          >
+            <CircularProgress color="primary" />
+          </Box>
+        </StyledCardContent>
+      </PostCard>
+    );
+  }
+
+  return (
+    <PostCard>
+      <StyledCardContent>
+        <Box sx={{ display: "flex", alignItems: "center", mb: 2 }}>
+          <UserAvatarMenu sx={{ mr: 2 }} user={post.creator} />
+          <Box>
+            <Box sx={{ fontWeight: "bold" }}>{post.creator.name}</Box>
+            <Box sx={{ fontSize: "0.875rem" }}>
+              {formatRelativeTime(post.date_created)}
+            </Box>
+          </Box>
+          {profile?.id === post.creator.id && (
+            <IconButton sx={{ ml: "auto" }} onClick={handleMenuClick}>
+              <MoreVertical color="#E9D5FF" size={20} />
+            </IconButton>
+          )}
+          <StyledMenu
+            anchorEl={menuAnchorEl}
+            open={Boolean(menuAnchorEl)}
+            onClose={handleMenuClose}
+          >
+            <MenuItem
+              onClick={handleDeleteClick}
+              sx={{
+                "&:hover": {
+                  backgroundColor: "rgba(139, 92, 246, 0.1)",
+                },
+              }}
+            >
+              Delete Post
+            </MenuItem>
+          </StyledMenu>
+
+          <StyledDialog
+            open={deleteDialogOpen}
+            onClose={() => setDeleteDialogOpen(false)}
+          >
+            <DialogTitle>Delete Post</DialogTitle>
+            <DialogContent>
+              Are you sure you want to delete this post? This action cannot be
+              undone.
+            </DialogContent>
+            <DialogActions>
+              <Button
+                onClick={() => setDeleteDialogOpen(false)}
+                sx={{
+                  color: "#A78BFA",
+                  "&:hover": {
+                    backgroundColor: "rgba(139, 92, 246, 0.1)",
+                  },
+                }}
+              >
+                Cancel
+              </Button>
+              <Button
+                onClick={handleDeleteConfirm}
+                sx={{
+                  color: "#ff4444",
+                  "&:hover": {
+                    backgroundColor: "rgba(255, 68, 68, 0.1)",
+                  },
+                }}
+                autoFocus
+              >
+                Delete
+              </Button>
+            </DialogActions>
+          </StyledDialog>
+        </Box>
+
+        <Box sx={{ mb: 2 }}>
+          <DndProvider backend={HTML5Backend}>
+            <EditorComponent
+              editorKey={post.id}
+              readOnly={profile?.id !== post.creator.id}
+              id={post.id}
+              contentEditable={profile?.id === post.creator.id}
+              onChange={(content) => {
+                contentTree.current = { "": content };
+                if (!isChanged && post.creator.id === profile?.id) {
+                  setChanged(true);
+                }
+              }}
+              content={deserializeContentTree(post.content_tree)}
+            />
+          </DndProvider>
+        </Box>
+        <Box
+          sx={{
+            display: "flex",
+            alignItems: "center",
+            gap: 2,
+            color: "#A78BFA",
+          }}
+        >
+          <PostActionButton
+            disabled={
+              !profile || profile?.id === post.creator.id || voteLoading
+            }
+            onClick={onLike}
+          >
+            <Heart
+              size={20}
+              fill={
+                votes.up.map((v) => v.toString()).includes(profile?.id)
+                  ? "#A855F7"
+                  : "rgba(233,213,255,0)"
+              }
+            />
+            <Box component="span" sx={{ ml: 1, fontSize: "0.875rem" }}>
+              {post.children.length}
+            </Box>
+          </PostActionButton>
+
+          <PostActionButton
+            disabled={
+              !profile || profile?.id === post.creator.id || voteLoading
+            }
+            onClick={onDisLike}
+          >
+            <ThumbsDown
+              fill={
+                votes.down.map((v) => v.toString()).includes(profile?.id)
+                  ? "#A855F7"
+                  : "rgba(233,213,255,0)"
+              }
+              size={20}
+            />
+            <Box component="span" sx={{ ml: 1, fontSize: "0.875rem" }}>
+              {votes.down.length}
+            </Box>
+          </PostActionButton>
+
+          <PostActionButton
+            onClick={() => setShowComments(!showComments)}
+            sx={{
+              "& svg": {
+                transition: "transform 0.2s",
+                transform: showComments ? "rotate(180deg)" : "none",
+              },
+            }}
+          >
+            <MessageCircle
+              size={20}
+              fill={showComments ? "#A855F7" : "rgba(233,213,255,0)"}
+            />
+            <Box component="span" sx={{ ml: 1, fontSize: "0.875rem" }}>
+              {post.children.length}
+            </Box>
+          </PostActionButton>
+
+          {profile?.id === post.creator.id && (
+            <PostActionButton disabled={!isChanged} onClick={onClickSave}>
+              Save
+            </PostActionButton>
+          )}
+        </Box>
+
+        <Collapse in={showComments}>
+          <Box
+            sx={{
+              mt: 3,
+              borderTop: "1px solid rgba(139, 92, 246, 0.2)",
+              pt: 2,
+            }}
+          >
+            <CommentList
+              key={post.length}
+              post={post}
+              allPosts={posts}
+              onUpdate={async () => {
+                const updatedPosts = await backendActor.get_posts();
+                setPosts(updatedPosts);
+                const updatedPost = await backendActor.get_post(post.id);
+                setVotes({
+                  up: updatedPost.votes_up,
+                  down: updatedPost.votes_down,
+                });
+              }}
+            />
+          </Box>
+        </Collapse>
+      </StyledCardContent>
+    </PostCard>
+  );
+};
+
+export default ViewPostComponent;
+I add new new feature which is comment, however I want to rethink it all. And enable render the comments as users hit on comment button

# 2025-01-24 17:41:57.639857
+import React from "react";
+import {
+  Box,
+  Button,
+  Card,
+  CardContent,
+  CircularProgress,
+  Collapse,
+  Dialog,
+  DialogActions,
+  DialogContent,
+  DialogTitle,
+  IconButton,
+  Menu,
+  MenuItem,
+} from "@mui/material";
+import { Heart, MessageCircle, MoreVertical, ThumbsDown } from "lucide-react";
+import { keyframes, styled } from "@mui/material/styles";
+import { useSelector } from "react-redux";
+import { useSnackbar } from "notistack";
+import { formatRelativeTime } from "../../utils/time";
+import EditorComponent from "../../components/EditorComponent";
+import { deserializeContentTree } from "../../DataProcessing/deserlize/deserializeContents";
+import UserAvatarMenu from "../../components/MainComponents/UserAvatarMenu";
+import { useBackendContext } from "../../contexts/BackendContext";
+import serializeFileContents from "../../DataProcessing/serialize/serializeFileContents";
+import { Post, PostUser } from "../../../declarations/backend/backend.did";
+import { DndProvider } from "react-dnd";
+import { HTML5Backend } from "react-dnd-html5-backend";
+import CommentList from "./CommentList";
+
+interface ViewPostComponentProps {
+  post: PostUser;
+  handleDeletePost: (postId: string) => void;
+}
+
+const fadeIn = keyframes`
+  from {
+    opacity: 0;
+    transform: translateY(10px);
+  }
+  to {
+    opacity: 1;
+    transform: translateY(0);
+  }
+`;
+
+const PostCard = styled(Card)(({ theme }) => ({
+  background: "rgba(143,143,143,0.42)",
+  backdropFilter: "blur(16px) saturate(180%)",
+  border: "1px solid rgba(255, 255, 255, 0.125)",
+  borderRadius: theme.spacing(2),
+  padding: 0,
+  position: "static",
+  boxShadow: theme.shadows[1],
+  transition: theme.transitions.create(["transform", "box-shadow"], {
+    duration: theme.transitions.duration.shorter,
+  }),
+  overflow: "visible",
+  marginBottom: theme.spacing(2),
+  "&:hover": {
+    transform: "translateY(-5px)",
+    boxShadow: theme.shadows[8],
+  },
+  animation: `${fadeIn} 0.5s ease-out`,
+}));
+
+const StyledCardContent = styled(CardContent)(({ theme }) => ({
+  padding: theme.spacing(2),
+  "&:last-child": {
+    paddingBottom: theme.spacing(2),
+  },
+  overflow: "visible",
+  position: "static",
+}));
+
+const PostActionButton = styled(IconButton)(({ theme }) => ({
+  color: theme.palette.mode === "dark" ? "#E9D5FF" : "#6366F1",
+  transition: theme.transitions.create(["transform", "background-color"], {
+    duration: theme.transitions.duration.shorter,
+  }),
+  padding: theme.spacing(1),
+  borderRadius: theme.shape.borderRadius * 1.5,
+  "&:hover": {
+    transform: "scale(1.1)",
+    backgroundColor:
+      theme.palette.mode === "dark"
+        ? "rgba(139, 92, 246, 0.1)"
+        : "rgba(79, 70, 229, 0.1)",
+  },
+  "&:active": {
+    transform: "scale(0.95)",
+  },
+  "&.Mui-disabled": {
+    opacity: 0.8,
+    color: theme.palette.mode === "dark" ? "#9CA3AF" : "#4B5563",
+    "& span": {
+      color: theme.palette.mode === "dark" ? "#E5E7EB" : "#1F2937",
+      fontWeight: 500,
+    },
+  },
+}));
+
+const StyledMenu = styled(Menu)(({ theme }) => ({
+  "& .MuiPaper-root": {
+    backgroundColor:
+      theme.palette.mode === "dark"
+        ? "rgba(17, 24, 39, 0.95)"
+        : "rgba(255, 255, 255, 0.95)",
+    border: `1px solid ${
+      theme.palette.mode === "dark"
+        ? "rgba(139, 92, 246, 0.2)"
+        : "rgba(79, 70, 229, 0.2)"
+    }`,
+  },
+}));
+
+const StyledDialog = styled(Dialog)(({ theme }) => ({
+  "& .MuiPaper-root": {
+    backgroundColor:
+      theme.palette.mode === "dark"
+        ? "rgba(17, 24, 39, 0.95)"
+        : "rgba(255, 255, 255, 0.95)",
+    border: `1px solid ${
+      theme.palette.mode === "dark"
+        ? "rgba(139, 92, 246, 0.2)"
+        : "rgba(79, 70, 229, 0.2)"
+    }`,
+  },
+}));
+
+const ViewPostComponent: React.FC<ViewPostComponentProps> = ({
+  posts,
+  post,
+  handleDeletePost,
+  setPosts,
+}) => {
+  const { backendActor } = useBackendContext();
+  const { enqueueSnackbar } = useSnackbar();
+  const { profile } = useSelector((state: any) => state.filesState);
+  const [showComments, setShowComments] = React.useState(false);
+
+  const [voteLoading, setVoteLoad] = React.useState(false);
+  const [isChanged, setChanged] = React.useState(false);
+  const [isDeleting, setIsDeleting] = React.useState(false);
+  const [menuAnchorEl, setMenuAnchorEl] = React.useState<null | HTMLElement>(
+    null,
+  );
+  const [deleteDialogOpen, setDeleteDialogOpen] = React.useState(false);
+  const [votes, setVotes] = React.useState({
+    up: post.votes_up,
+    down: post.votes_down,
+  });
+
+  const contentTree = React.useRef([]);
+
+  const handleMenuClick = (event: React.MouseEvent<HTMLElement>) => {
+    setMenuAnchorEl(event.currentTarget);
+  };
+
+  const handleMenuClose = () => {
+    setMenuAnchorEl(null);
+  };
+
+  const handleDeleteClick = () => {
+    handleMenuClose();
+    setDeleteDialogOpen(true);
+  };
+
+  const handleDeleteConfirm = async () => {
+    setDeleteDialogOpen(false);
+    setIsDeleting(true);
+    try {
+      const res = await backendActor?.delete_post(post.id);
+      if (res?.Ok === null) {
+        enqueueSnackbar("Post deleted successfully", { variant: "success" });
+        handleDeletePost(post.id);
+      } else {
+        enqueueSnackbar(JSON.stringify(res?.Err), { variant: "error" });
+      }
+    } catch (error) {
+      console.error({ error });
+      enqueueSnackbar("Failed to delete post: " + error, { variant: "error" });
+    }
+  };
+
+  const onClickSave = async () => {
+    setChanged(false);
+    const newPostObj: Post = {
+      ...post,
+      tags: [],
+      content_tree: serializeFileContents(contentTree.current)[0][0][1],
+      creator: profile.id,
+      votes_up: votes.up,
+      votes_down: votes.down,
+    };
+
+    const result = await backendActor.save_post(newPostObj);
+    console.log({ result });
+  };
+
+  const onLike = async () => {
+    if (profile?.id === post.creator.id) {
+      enqueueSnackbar("You can't like your own post", { variant: "error" });
+      return;
+    }
+    setVoteLoad(true);
+    try {
+      const votesUp = votes.up.map((v) => v.toString());
+      if (votesUp.includes(profile?.id)) {
+        const res = await backendActor.unvote(post.id);
+        setVotes({ up: res.Ok.votes_up, down: res.Ok.votes_down });
+      } else {
+        const res = await backendActor.vote_up(post.id);
+        setVotes({ up: res.Ok.votes_up, down: res.Ok.votes_down });
+      }
+    } finally {
+      setVoteLoad(false);
+    }
+  };
+
+  const onDisLike = async () => {
+    if (profile?.id === post.creator.id) {
+      enqueueSnackbar("You can't dislike your own post", { variant: "error" });
+      return;
+    }
+    setVoteLoad(true);
+    try {
+      const votesDown = votes.down.map((v) => v.toString());
+      if (votesDown.includes(profile.id)) {
+        const res = await backendActor.unvote(post.id);
+        setVotes({ up: res.Ok.votes_up, down: res.Ok.votes_down });
+      } else {
+        const res = await backendActor.vote_down(post.id);
+        setVotes({ up: res.Ok.votes_up, down: res.Ok.votes_down });
+      }
+    } finally {
+      setVoteLoad(false);
+    }
+  };
+
+  if (isDeleting) {
+    return (
+      <PostCard>
+        <StyledCardContent>
+          <Box
+            sx={{
+              display: "flex",
+              justifyContent: "center",
+              alignItems: "center",
+              height: "10rem",
+            }}
+          >
+            <CircularProgress color="primary" />
+          </Box>
+        </StyledCardContent>
+      </PostCard>
+    );
+  }
+
+  return (
+    <PostCard>
+      <StyledCardContent>
+        <Box sx={{ display: "flex", alignItems: "center", mb: 2 }}>
+          <UserAvatarMenu sx={{ mr: 2 }} user={post.creator} />
+          <Box>
+            <Box sx={{ fontWeight: "bold" }}>{post.creator.name}</Box>
+            <Box sx={{ fontSize: "0.875rem" }}>
+              {formatRelativeTime(post.date_created)}
+            </Box>
+          </Box>
+          {profile?.id === post.creator.id && (
+            <IconButton sx={{ ml: "auto" }} onClick={handleMenuClick}>
+              <MoreVertical color="#E9D5FF" size={20} />
+            </IconButton>
+          )}
+          <StyledMenu
+            anchorEl={menuAnchorEl}
+            open={Boolean(menuAnchorEl)}
+            onClose={handleMenuClose}
+          >
+            <MenuItem
+              onClick={handleDeleteClick}
+              sx={{
+                "&:hover": {
+                  backgroundColor: "rgba(139, 92, 246, 0.1)",
+                },
+              }}
+            >
+              Delete Post
+            </MenuItem>
+          </StyledMenu>
+
+          <StyledDialog
+            open={deleteDialogOpen}
+            onClose={() => setDeleteDialogOpen(false)}
+          >
+            <DialogTitle>Delete Post</DialogTitle>
+            <DialogContent>
+              Are you sure you want to delete this post? This action cannot be
+              undone.
+            </DialogContent>
+            <DialogActions>
+              <Button
+                onClick={() => setDeleteDialogOpen(false)}
+                sx={{
+                  color: "#A78BFA",
+                  "&:hover": {
+                    backgroundColor: "rgba(139, 92, 246, 0.1)",
+                  },
+                }}
+              >
+                Cancel
+              </Button>
+              <Button
+                onClick={handleDeleteConfirm}
+                sx={{
+                  color: "#ff4444",
+                  "&:hover": {
+                    backgroundColor: "rgba(255, 68, 68, 0.1)",
+                  },
+                }}
+                autoFocus
+              >
+                Delete
+              </Button>
+            </DialogActions>
+          </StyledDialog>
+        </Box>
+
+        <Box sx={{ mb: 2 }}>
+          <DndProvider backend={HTML5Backend}>
+            <EditorComponent
+              editorKey={post.id}
+              readOnly={profile?.id !== post.creator.id}
+              id={post.id}
+              contentEditable={profile?.id === post.creator.id}
+              onChange={(content) => {
+                contentTree.current = { "": content };
+                if (!isChanged && post.creator.id === profile?.id) {
+                  setChanged(true);
+                }
+              }}
+              content={deserializeContentTree(post.content_tree)}
+            />
+          </DndProvider>
+        </Box>
+        <Box
+          sx={{
+            display: "flex",
+            alignItems: "center",
+            gap: 2,
+            color: "#A78BFA",
+          }}
+        >
+          <PostActionButton
+            disabled={
+              !profile || profile?.id === post.creator.id || voteLoading
+            }
+            onClick={onLike}
+          >
+            <Heart
+              size={20}
+              fill={
+                votes.up.map((v) => v.toString()).includes(profile?.id)
+                  ? "#A855F7"
+                  : "rgba(233,213,255,0)"
+              }
+            />
+            <Box component="span" sx={{ ml: 1, fontSize: "0.875rem" }}>
+              {post.children.length}
+            </Box>
+          </PostActionButton>
+
+          <PostActionButton
+            disabled={
+              !profile || profile?.id === post.creator.id || voteLoading
+            }
+            onClick={onDisLike}
+          >
+            <ThumbsDown
+              fill={
+                votes.down.map((v) => v.toString()).includes(profile?.id)
+                  ? "#A855F7"
+                  : "rgba(233,213,255,0)"
+              }
+              size={20}
+            />
+            <Box component="span" sx={{ ml: 1, fontSize: "0.875rem" }}>
+              {votes.down.length}
+            </Box>
+          </PostActionButton>
+
+          <PostActionButton
+            onClick={() => setShowComments(!showComments)}
+            sx={{
+              "& svg": {
+                transition: "transform 0.2s",
+                transform: showComments ? "rotate(180deg)" : "none",
+              },
+            }}
+          >
+            <MessageCircle
+              size={20}
+              fill={showComments ? "#A855F7" : "rgba(233,213,255,0)"}
+            />
+            <Box component="span" sx={{ ml: 1, fontSize: "0.875rem" }}>
+              {post.children.length}
+            </Box>
+          </PostActionButton>
+
+          {profile?.id === post.creator.id && (
+            <PostActionButton disabled={!isChanged} onClick={onClickSave}>
+              Save
+            </PostActionButton>
+          )}
+        </Box>
+
+        <Collapse in={showComments}>
+          <Box
+            sx={{
+              mt: 3,
+              borderTop: "1px solid rgba(139, 92, 246, 0.2)",
+              pt: 2,
+            }}
+          >
+            <CommentList
+              key={post.length}
+              post={post}
+              allPosts={posts}
+              onUpdate={async () => {
+                const updatedPosts = await backendActor.get_posts();
+                setPosts(updatedPosts);
+                const updatedPost = await backendActor.get_post(post.id);
+                setVotes({
+                  up: updatedPost.votes_up,
+                  down: updatedPost.votes_down,
+                });
+              }}
+            />
+          </Box>
+        </Collapse>
+      </StyledCardContent>
+    </PostCard>
+  );
+};
+
+export default ViewPostComponent;
+I add new new feature which is comment, however I want to rethink it all. And enable render the comments as users hit on comment button            

# 2025-01-24 17:42:53.039748
+y

# 2025-01-24 18:38:04.114960
+import { Route, Routes } from "react-router-dom";
+import React, { useEffect, useState } from "react";
+import LandingPage from "./LandingPage";
+import Index from "./fileContentPage";
+import ShareFilePage from "./ShareFilePage";
+import ProfilePage from "./profile";
+import Discover from "./discover/index";
+import UserProfile from "./User";
+import ContractsHistory from "./Profile/ContractsHistory";
+import Web3WalletUI from "../components/MuiComponents/walletUi";
+import { useSelector } from "react-redux";
+import { useBackendContext } from "../contexts/BackendContext";
+import OfferPage from "./OfferPage";
+import SubscriptionPlans from "./subscrptions";
+import SNSWhitepaper from "./snsWhitePaper";
+import SNSVoting from "./votePage";
+import ProductManagerDashboard from "./dashBoardPage";
+import DummyShares from "./sharesContract";
+import AffiliateDashboard from "./affiliate";
+import AffiliateRedirect from "./affiliateRedirect";
+
+function Pages() {
+  const [posts, setPosts] = useState([]);
+  const { profile, profile_history, wallet, friends } = useSelector(
+    (state: any) => state.filesState,
+  );
+  const { login, logout, backendActor } = useBackendContext();
+  const { isLoggedIn } = useSelector((state: any) => state.uiState);
+
+  useEffect(() => {
+    const fetchPosts = async () => {
+      if (backendActor) {
+        try {
+          // Fetch first 20 posts
+          const fetchedPosts = await backendActor.get_posts(
+            BigInt(0),
+            BigInt(20),
+          );
+
+          setPosts(fetchedPosts);
+        } catch (error) {
+          console.error("Error fetching posts:", error);
+        }
+      }
+    };
+
+    fetchPosts();
+  }, [backendActor]);
+
+  const MainPage = () => {
+    if (profile_history?.actions_rate >= 1) {
+      return <ProductManagerDashboard />;
+    }
+    return <LandingPage isLoggedIn={isLoggedIn} login={login} />;
+  };
+  return (
+    <Routes>
+      <Route path="/" element={<MainPage />} />
+      <Route path="/dashboard" element={<ProductManagerDashboard />} />
+      <Route
+        path="/about"
+        element={<LandingPage isLoggedIn={isLoggedIn} login={login} />}
+      />
+      <Route
+        path="/discover"
+        element={<Discover key={posts.length} posts={posts} />}
+      />
+      <Route path="/wallet" element={<Web3WalletUI wallet={wallet} />} />
+      <Route
+        path="/profile"
+        element={
+          <ProfilePage
+            friends={friends}
+            profile={profile}
+            history={profile_history}
+          />
+        }
+      />
+      <Route path="/share/*" element={<ShareFilePage />} />
+      <Route path="/user/*" element={<UserProfile />} />
+      {/*<Route path="/chats/*" element={<ChatsPage />} />*/}
+      <Route path="/contracts/*" element={<ContractsHistory />} />
+      <Route
+        path="/offer"
+        element={<OfferPage isLoggedIn={isLoggedIn} login={login} />}
+      />
+
+      <Route path="/subscriptions" element={<SubscriptionPlans />} />
+      <Route path="/white_paper" element={<SNSWhitepaper />} />
+      <Route path="/vote" element={<SNSVoting />} />
+      <Route path="/shares_contract" element={<DummyShares />} />
+      <Route path="/affiliate" element={<AffiliateDashboard />} />
+      <Route path="/f" element={<AffiliateRedirect />} />
+      <Route path="/*" element={<Index />} />
+    </Routes>
+  );
+}
+
+export default Pages;
+do not use `const [posts, setPosts] = useState([]);` instead use redux for that /Users/ahmed/Desktop/odoc/src/frontend/redux/reducers/filesReducer.ts add new cases for add post, delete post, update posts, set posts

# 2025-01-24 18:38:57.216675
+y

# 2025-01-25 14:08:05.708946
+make the icons of the social buttons have 3d depth import React from 'react';
+import YouTubeIcon from '@mui/icons-material/YouTube';
+import InstagramIcon from '@mui/icons-material/Instagram';
+import { IconButton, SvgIcon } from '@mui/material';
+import { useSelector } from 'react-redux';
+
+const XIcon = (props) => (
+  <SvgIcon {...props}>
+    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
+  </SvgIcon>
+);
+
+const DiscordIcon = (props) => (
+  <SvgIcon {...props}>
+    <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z" />
+  </SvgIcon>
+);
+
+const SocialButton = () => {
+  const { isDarkMode } = useSelector((state: any) => state.uiState);
+
+  const socialLinks = [
+    {
+      name: 'X',
+      url: 'https://x.com/odoc_ic',
+      icon: XIcon,
+      color: isDarkMode ? '#000000' : '#000000',
+    },
+    {
+      name: 'YouTube',
+      url: 'https://www.youtube.com/@alihusham1560',
+      icon: YouTubeIcon,
+      color: isDarkMode ? '#FF0000' : '#dc2626',
+    },
+    {
+      name: 'Instagram',
+      url: 'https://www.instagram.com/odoc_ic',
+      icon: InstagramIcon,
+      color: isDarkMode ? '#E4405F' : '#db2777',
+    },
+    {
+      name: 'Discord',
+      url: 'https://discord.gg/uxMJHBk8',
+      icon: DiscordIcon,
+      color: isDarkMode ? '#5865F2' : '#4f46e5',
+    }
+  ];
+
+  const handleClick = (url) => {
+    window.open(url, '_blank', 'noopener,noreferrer');
+  };
+
+  return (
+    <div className="flex items-center justify-center p-4">
+      {socialLinks.map((social, index) => {
+        const Icon = social.icon;
+        return (
+          <IconButton
+            key={social.name}
+            onClick={() => handleClick(social.url)}
+            aria-label={`Visit our ${social.name}`}
+            sx={{
+              width: 48,
+              height: 48,
+              margin: '0 24px',
+              background: social.color,
+              transition: 'all 0.3s ease-in-out',
+              '&:hover': {
+                background: social.color,
+                transform: 'scale(1.1)',
+                boxShadow: isDarkMode ? '0 4px 12px rgba(0,0,0,0.3)' : '0 4px 12px rgba(0,0,0,0.15)',
+                '& .MuiSvgIcon-root': {
+                  transform: 'rotate(12deg)',
+                },
+              },
+              '& .MuiSvgIcon-root': {
+                color: '#fff',
+                transition: 'transform 0.3s ease-in-out',
+                fontSize: social.name === 'X' ? 20 : 24, // Slightly smaller X icon for better proportions
+              },
+            }}
+          >
+            <Icon />
+          </IconButton>
+        );
+      })}
+    </div>
+  );
+};
+
+export default SocialButton;
+

# 2025-01-25 14:08:07.520591
+y

# 2025-01-25 15:21:12.007630
+make my landing page compnent responsive 
